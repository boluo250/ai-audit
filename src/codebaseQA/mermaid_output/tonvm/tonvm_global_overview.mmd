## 项目整体业务流程说明

tonvm 项目是一个完整的 TON 虚拟机实现，包含从底层数据存储到高级指令执行的完整技术栈。整体业务流程分为七个核心阶段：

1. **系统初始化阶段** - 通过 cp0 模块初始化操作码表，配置虚拟机基础环境
2. **数据存储层** - db 模块提供 Cell 的存储、序列化和管理功能
3. **数据结构层** - cells 模块管理 Cell 的生命周期和使用跟踪
4. **序列化层** - boc 模块处理 Bag of Cells 的序列化和反序列化
5. **密码学层** - crypto 模块提供哈希计算和 BLS 签名功能
6. **执行引擎层** - vm 模块实现指令调度和执行控制
7. **操作指令层** - ops 模块执行具体的虚拟机指令操作

各模块通过明确的接口协作，形成了一个高度模块化、可扩展的虚拟机架构。

## 合并后的完整业务流程图

```mermaid
sequenceDiagram
    participant User as User/Client
    participant CP0 as cp0::init_op_cp0
    participant OpcodeTable as OpcodeTable
    participant VM as VmState
    participant DispatchTable as DispatchTable
    participant DBOC as DynamicBagOfCellsDbImpl
    participant CellLoader as CellLoader
    participant CellBuilder as CellBuilder
    participant CellUsageTree as CellUsageTree
    participant BagOfCells as BagOfCells
    participant CellSerializationInfo as CellSerializationInfo
    participant Hasher as Hasher
    participant Stack as Stack
    participant Continuation as Continuation
    participant ControlRegs as ControlRegs
    participant StackParser as StackParser
    participant Atom as Atom
    participant Cell as Cell
    participant Tuple as Tuple
    participant Debug as Debug

    %% ========== Phase 1: System Initialization ==========
    Note over User,Debug: Phase 1: System Initialization & Opcode Table Setup
    
    User->>CP0: init_op_cp0(bool enable_debug)
    CP0->>OpcodeTable: new OpcodeTable("TEST CODEPAGE", Codepage::test_cp)
    OpcodeTable-->>CP0: OpcodeTable instance
    
    CP0->>OpcodeTable: register_stack_ops(*op_cp0)
    CP0->>OpcodeTable: register_tuple_ops(*op_cp0)
    CP0->>OpcodeTable: register_arith_ops(*op_cp0)
    CP0->>OpcodeTable: register_cell_ops(*op_cp0)
    CP0->>OpcodeTable: register_continuation_ops(*op_cp0)
    CP0->>OpcodeTable: register_dictionary_ops(*op_cp0)
    CP0->>OpcodeTable: register_ton_ops(*op_cp0)
    CP0->>OpcodeTable: register_debug_ops(*op_cp0)
    CP0->>OpcodeTable: register_codepage_ops(*op_cp0)
    
    CP0->>OpcodeTable: finalize()
    OpcodeTable-->>CP0: finalized table
    
    CP0->>DispatchTable: register_table(Codepage::test_cp)
    DispatchTable-->>User: System initialized

    %% ========== Phase 2: Database & Storage Layer ==========
    Note over User,Debug: Phase 2: Database & Storage Layer Initialization
    
    User->>DBOC: DynamicBagOfCellsDbImpl()
    DBOC->>DBOC: initialize storage backend
    
    User->>CellLoader: CellLoader(need_data)
    CellLoader->>CellLoader: initialize cell loading capabilities
    
    User->>BagOfCells: BagOfCells()
    BagOfCells->>BagOfCells: initialize BOC container

    %% ========== Phase 3: Cell Management & Usage Tracking ==========
    Note over User,Debug: Phase 3: Cell Management & Usage Tracking
    
    User->>CellBuilder: CellBuilder()
    CellBuilder->>CellBuilder: initialize with refs_cnt(0)
    
    User->>CellUsageTree: root_ptr()
    CellUsageTree->>CellUsageTree: create root node
    CellUsageTree-->>User: NodePtr{shared_ptr, 1}
    
    User->>CellUsageTree: create_child(ref_id)
    CellUsageTree->>CellUsageTree: create_node(node_id)
    CellUsageTree-->>User: New NodePtr for child

    %% ========== Phase 4: BOC Serialization & Processing ==========
    Note over User,Debug: Phase 4: BOC Serialization & Cell Processing
    
    User->>BagOfCells: add_root(td::Ref<vm::Cell> add_root)
    BagOfCells->>BagOfCells: validate virtualization level == 0
    BagOfCells->>BagOfCells: roots.emplace_back(std::move(add_root), -1)
    
    User->>BagOfCells: import_cells()
    BagOfCells->>BagOfCells: import_cell(root.cell, 0)
    BagOfCells->>CellLoader: parse(parser, ext_cell_creator)
    CellLoader->>CellSerializationInfo: init(td::Slice data, int ref_byte_size)
    CellSerializationInfo->>CellSerializationInfo: parse serialization format
    CellSerializationInfo->>CellSerializationInfo: calculate offsets and lengths
    CellSerializationInfo-->>CellLoader: serialization info
    CellLoader-->>BagOfCells: loaded_cell

    %% ========== Phase 5: Cryptographic Operations ==========
    Note over User,Debug: Phase 5: Cryptographic Hash Processing
    
    User->>Hasher: Hasher(int hash_id)
    alt hash_id == KECCAK256 || hash_id == KECCAK512
        Hasher->>Hasher: create HasherImplKeccak
    else hash_id in [SHA256, SHA512, BLAKE2B]
        Hasher->>Hasher: create HasherImplEVP with OpenSSL
    end
    
    User->>Hasher: append(td::ConstBitPtr data, unsigned size)
    Hasher->>Hasher: buffer data and process in chunks
    
    User->>Hasher: finish()
    Hasher->>Hasher: complete hash calculation
    Hasher-->>User: td::BufferSlice hash result

    %% ========== Phase 6: VM Execution Engine ==========
    Note over User,Debug: Phase 6: VM Execution Engine & Dispatch
    
    User->>VM: VmState initialization
    VM->>VM: init_cregs(bool same_c3, bool push_0)
    VM->>ControlRegs: set_c0(quit0), set_c1(quit1), set_c2(ExcQuitCont)
    
    User->>VM: execute instruction
    VM->>DispatchTable: get_table(Codepage cp)
    DispatchTable-->>VM: dispatch table
    VM->>OpcodeTable: dispatch(VmState* st, CellSlice& cs)
    OpcodeTable->>OpcodeTable: lookup_instr(cs, opcode, bits)
    OpcodeTable-->>VM: instruction found
    
    VM->>Stack: manipulate stack based on instruction
    VM->>Continuation: manage execution flow
    Continuation->>ControlRegs: access control registers
    ControlRegs-->>Continuation: register values

    %% ========== Phase 7: Instruction Execution ==========
    Note over User,Debug: Phase 7: High-Level Instruction Execution
    
    %% Execution Control Operations
    VM->>VM: exec_execute(VmState* st)
    VM->>Stack: pop_cont()
    Stack-->>VM: continuation
    VM->>VM: call(continuation)
    
    %% Conditional Operations
    VM->>VM: exec_if(VmState* st)
    VM->>Stack: pop_bool(), pop_cont()
    Stack-->>VM: condition, continuation
    alt condition is true
        VM->>VM: call(continuation)
    end
    
    %% Tuple Operations
    VM->>VM: exec_mktuple(VmState* st, unsigned args)
    VM->>Stack: pop n elements
    Stack-->>VM: elements
    VM->>Tuple: create tuple from elements
    Tuple-->>VM: new_tuple
    VM->>Stack: push(new_tuple)
    
    %% Loop Control
    VM->>VM: exec_repeat(VmState* st)
    VM->>Stack: pop_long(), pop_cont()
    Stack-->>VM: count, body_continuation
    loop count times
        VM->>VM: call(body_continuation)
    end

    %% ========== Phase 8: Utility & Debug Support ==========
    Note over User,Debug: Phase 8: Utility Functions & Debug Support
    
    User->>StackParser: parse_stack_entries(td::Slice str, bool prefix_only)
    StackParser->>StackParser: parse_stack_entry_in(td::Slice& str_ref)
    alt hexadecimal format
        StackParser->>StackParser: parse "0x" or "x{}" format
    else binary format
        StackParser->>StackParser: parse "b{}" format
    else numeric
        StackParser->>StackParser: convert to RefInt
    end
    StackParser-->>User: std::vector<vm::StackEntry>
    
    User->>Atom: find(td::Slice name, bool create)
    Atom->>Atom: compute_hash(td::Slice name) using double hashing
    Atom->>Atom: search in hashtable with collision resolution
    alt found existing atom
        Atom-->>User: Ref<Atom>(existing)
    else create new atom
        Atom->>Atom: atomic compare_exchange_strong insertion
        Atom-->>User: Ref<Atom>(new_atom)
    end
    
    %% Debug Operations
    alt debug enabled
        VM->>Debug: exec_dump_stack(VmState* st)
        Debug->>Stack: dump stack contents
        Debug->>Debug: output formatted stack trace
        
        VM->>Debug: exec_dump_value(VmState* st)
        Debug->>Stack: pop value
        Debug->>Debug: output formatted value representation
    end

    %% ========== Phase 9: Resource Management & Cleanup ==========
    Note over User,Debug: Phase 9: Resource Management & Cleanup
    
    VM->>ControlRegs: serialize(CellBuilder& cb)
    ControlRegs->>ControlRegs: serialize all registers to dictionary
    ControlRegs-->>VM: serialization complete
    
    VM->>Continuation: serialize_ref(CellBuilder& cb)
    Continuation->>Continuation: serialize continuation state
    Continuation-->>VM: serialization complete
    
    User->>BagOfCells: serialize_to_slice()
    BagOfCells->>BagOfCells: compute_sizes()
    BagOfCells->>BagOfCells: serialize all cells and roots
    BagOfCells-->>User: td::Slice serialized_data
    
    Note over User,Debug: System ready for next execution cycle or shutdown
```