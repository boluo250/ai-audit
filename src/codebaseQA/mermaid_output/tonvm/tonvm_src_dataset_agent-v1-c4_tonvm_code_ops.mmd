## 业务流程总结

tonvm_ops 项目实现了 TON VM 的完整操作指令集，包括执行控制、栈操作、元组操作、调试功能等核心业务流程。主要功能模块包括：

1. **执行控制操作**：exec_execute、exec_callx_args、exec_jmpx 等函数处理虚拟机的基本执行流程
2. **条件执行操作**：exec_if、exec_ifnot、exec_if_else 等函数实现条件分支逻辑
3. **循环控制操作**：exec_repeat、exec_while、exec_until 等函数提供循环执行能力
4. **元组操作**：exec_mktuple、exec_untuple、exec_tuple_index 等函数处理元组数据结构
5. **栈操作**：exec_push_null、exec_is_null 等基础栈操作函数
6. **调试功能**：exec_dummy_debug、exec_dump_stack、exec_dump_value 等调试辅助函数
7. **辅助功能**：包括各种 getter/setter 函数和工具函数，如 compute_len_debug_str、dump_dummy_debug_str 等

## 优化后的完整业务流程图

```mermaid
sequenceDiagram
    participant User as User/Caller
    participant VM as VmState
    participant Stack as Stack
    participant Cont as Continuation
    participant ChildVM as Child VmState
    participant OpcodeTable as OpcodeTable
    participant CellSlice as CellSlice
    participant RefInt256 as RefInt256
    participant Cell as Cell
    participant Tuple as Tuple
    participant Dictionary as Dictionary
    participant Builder as Builder
    participant BitSlice as BitSlice
    participant Debug as Debug Output

    %% ========== 调试系统初始化 ==========
    Note over User,Debug: 调试系统初始化和配置
    User->>OpcodeTable: set_debug_enabled(bool enabled)
    OpcodeTable->>OpcodeTable: 设置全局调试开关状态
    OpcodeTable-->>User: void

    User->>OpcodeTable: register_debug_ops()
    OpcodeTable->>OpcodeTable: 根据调试状态注册调试指令集
    OpcodeTable-->>User: void

    %% ========== 基础执行控制操作 ==========
    Note over User,VM: 基础执行控制流程
    User->>VM: exec_execute(VmState* st)
    VM->>Stack: pop_cont()
    Stack-->>VM: continuation
    VM->>VM: call(continuation)
    VM-->>User: int result

    User->>VM: exec_callx_args(VmState* st, unsigned args)
    VM->>VM: extract params and retvals from args
    VM->>Stack: pop_cont()
    Stack-->>VM: continuation
    VM->>VM: call(continuation, params, retvals)
    VM-->>User: int result

    User->>VM: exec_callx_args_p(VmState* st, unsigned args)
    VM->>VM: extract params from args
    VM->>Stack: pop_cont()
    Stack-->>VM: continuation
    VM->>VM: call(continuation, params, -1)
    VM-->>User: int result

    %% ========== 跳转操作 ==========
    Note over User,VM: 跳转控制操作
    User->>VM: exec_jmpx(VmState* st)
    VM->>Stack: pop_cont()
    Stack-->>VM: continuation
    VM->>VM: jump(continuation)
    VM-->>User: int result

    User->>VM: exec_jmpx_args(VmState* st, unsigned args)
    VM->>VM: extract params from args
    VM->>Stack: pop_cont()
    Stack-->>VM: continuation
    VM->>VM: jump(continuation, params)
    VM-->>User: int result

    %% ========== 条件执行操作 ==========
    Note over User,VM: 条件分支执行
    User->>VM: exec_if(VmState* st)
    VM->>Stack: pop_bool()
    Stack-->>VM: condition
    VM->>Stack: pop_cont()
    Stack-->>VM: continuation
    alt condition is true
        VM->>VM: call(continuation)
    else condition is false
        VM->>VM: skip execution
    end
    VM-->>User: int result

    User->>VM: exec_ifnot(VmState* st)
    VM->>Stack: pop_bool()
    Stack-->>VM: condition
    VM->>Stack: pop_cont()
    Stack-->>VM: continuation
    alt condition is false
        VM->>VM: call(continuation)
    else condition is true
        VM->>VM: skip execution
    end
    VM-->>User: int result

    User->>VM: exec_if_else(VmState* st)
    VM->>Stack: pop_bool()
    Stack-->>VM: condition
    VM->>Stack: pop_cont() (else_cont)
    Stack-->>VM: else_continuation
    VM->>Stack: pop_cont() (if_cont)
    Stack-->>VM: if_continuation
    alt condition is true
        VM->>VM: call(if_continuation)
    else condition is false
        VM->>VM: call(else_continuation)
    end
    VM-->>User: int result

    %% ========== 条件跳转操作 ==========
    Note over User,VM: 条件跳转控制
    User->>VM: exec_ifret(VmState* st)
    VM->>Stack: pop_bool()
    Stack-->>VM: condition
    alt condition is true
        VM->>VM: ret()
    else condition is false
        VM->>VM: continue execution
    end
    VM-->>User: int result

    User->>VM: exec_ifnotret(VmState* st)
    VM->>Stack: pop_bool()
    Stack-->>VM: condition
    alt condition is false
        VM->>VM: ret()
    else condition is true
        VM->>VM: continue execution
    end
    VM-->>User: int result

    User->>VM: exec_if_jmp(VmState* st)
    VM->>Stack: pop_bool()
    Stack-->>VM: condition
    VM->>Stack: pop_cont()
    Stack-->>VM: continuation
    alt condition is true
        VM->>VM: jump(continuation)
    else condition is false
        VM->>VM: continue execution
    end
    VM-->>User: int result

    User->>VM: exec_ifnot_jmp(VmState* st)
    VM->>Stack: pop_bool()
    Stack-->>VM: condition
    VM->>Stack: pop_cont()
    Stack-->>VM: continuation
    alt condition is false
        VM->>VM: jump(continuation)
    else condition is true
        VM->>VM: continue execution
    end
    VM-->>User: int result

    %% ========== 循环控制操作 ==========
    Note over User,VM: 循环控制流程
    User->>VM: exec_repeat(VmState* st)
    VM->>Stack: pop_long()
    Stack-->>VM: count
    VM->>Stack: pop_cont()
    Stack-->>VM: body_continuation
    loop count times
        VM->>VM: call(body_continuation)
    end
    VM-->>User: int result

    User->>VM: exec_repeat_end(VmState* st)
    VM->>Stack: pop_long()
    Stack-->>VM: count
    VM->>Stack: pop_cont()
    Stack-->>VM: body_continuation
    loop count times
        VM->>VM: call(body_continuation)
        alt break condition met
            VM->>VM: break loop
        end
    end
    VM-->>User: int result

    User->>VM: exec_until(VmState* st)
    VM->>Stack: pop_cont()
    Stack-->>VM: body_continuation
    loop until condition true
        VM->>VM: call(body_continuation)
        VM->>Stack: pop_bool()
        Stack-->>VM: condition
        alt condition is true
            VM->>VM: break loop
        end
    end
    VM-->>User: int result

    User->>VM: exec_while(VmState* st)
    VM->>Stack: pop_cont()
    Stack-->>VM: body_continuation
    VM->>Stack: pop_cont()
    Stack-->>VM: cond_continuation
    loop while condition true
        VM->>VM: call(cond_continuation)
        VM->>Stack: pop_bool()
        Stack-->>VM: condition
        alt condition is true
            VM->>VM: call(body_continuation)
        else condition is false
            VM->>VM: break loop
        end
    end
    VM-->>User: int result

    User->>VM: exec_again(VmState* st)
    VM->>Stack: pop_cont()
    Stack-->>VM: body_continuation
    loop infinite
        VM->>VM: call(body_continuation)
    end
    VM-->>User: int result

    %% ========== 基础栈操作 ==========
    Note over User,Stack: 基础栈操作
    User->>VM: exec_push_null(VmState* st)
    VM->>Stack: push(null)
    VM-->>User: int result

    User->>VM: exec_is_null(VmState* st)
    VM->>Stack: pop()
    Stack-->>VM: value
    VM->>VM: check if value is null
    VM->>Stack: push(boolean_result)
    VM-->>User: int result

    %% ========== 元组创建操作 ==========
    Note over User,Tuple: 元组创建和构造
    User->>VM: exec_mktuple(VmState* st, unsigned args)
    VM->>VM: extract n from args
    VM->>VM: exec_mktuple_common(st, n)
    VM-->>User: int result

    User->>VM: exec_mktuple_var(VmState* st)
    VM->>Stack: pop_long()
    Stack-->>VM: n
    VM->>VM: exec_mktuple_common(st, n)
    VM-->>User: int result

    User->>VM: exec_mktuple_common(VmState* st, int n)
    VM->>Stack: pop n elements
    Stack-->>VM: elements
    VM->>Tuple: create tuple from elements
    Tuple-->>VM: new_tuple
    VM->>Stack: push(new_tuple)
    VM-->>User: int result

    %% ========== 元组索引访问操作 ==========
    Note over User,Tuple: 元组索引访问
    User->>VM: exec_tuple_index(VmState* st, unsigned args)
    VM->>VM: extract k from args
    VM->>VM: exec_tuple_index_common(st, k, false)
    VM-->>User: int result

    User->>VM: exec_tuple_index_var(VmState* st)
    VM->>Stack: pop_long()
    Stack-->>VM: k
    VM->>VM: exec_tuple_index_common(st, k, false)
    VM-->>User: int result

    User->>VM: exec_tuple_index_common(VmState* st, int k, bool quiet)
    VM->>Stack: pop_tuple()
    Stack-->>VM: tuple
    VM->>Tuple: get element at index k
    alt index valid
        Tuple-->>VM: element
        VM->>Stack: push(element)
    else index invalid and not quiet
        VM->>VM: throw exception
    else index invalid and quiet
        VM->>Stack: push(null)
    end
    VM-->>User: int result

    %% ========== 元组安全索引操作 ==========
    Note over User,Tuple: 元组安全索引访问
    User->>VM: exec_tuple_quiet_index(VmState* st, unsigned args)
    VM->>VM: extract k from args
    VM->>VM: exec_tuple_quiet_index_common(st, k)
    VM-->>User: int result

    User->>VM: exec_tuple_quiet_index_var(VmState* st)
    VM->>Stack: pop_long()
    Stack-->>VM: k
    VM->>VM: exec_tuple_quiet_index_common(st, k)
    VM-->>User: int result

    User->>VM: exec_tuple_quiet_index_common(VmState* st, int k)
    VM->>VM: exec_tuple_index_common(st, k, true)
    VM-->>User: int result

    %% ========== 元组解构操作 ==========
    Note over User,Tuple: 元组解构和展开
    User->>VM: exec_untuple(VmState* st, unsigned args)
    VM->>VM: extract n from args
    VM->>VM: exec_untuple_common(st, n)
    VM-->>User: int result

    User->>VM: exec_untuple_var(VmState* st)
    VM->>Stack: pop_long()
    Stack-->>VM: n
    VM->>VM: exec_untuple_common(st, n)
    VM-->>User: int result

    User->>VM: exec_untuple_common(VmState* st, int n)
    VM->>Stack: pop_tuple()
    Stack-->>VM: tuple
    VM->>VM: do_explode_tuple(st, tuple, n, n)
    VM-->>User: int result

    User->>VM: do_explode_tuple(VmState* st, tuple, int m, int n)
    VM->>Tuple: get tuple length
    Tuple-->>VM: tuple_length
    alt tuple_length == n
        loop m times
            VM->>Tuple: get element at index i
            Tuple-->>VM: element
            VM->>Stack: push(element)
        end
    else tuple_length != n
        VM->>VM: throw exception
    end
    VM-->>User: int result

    %% ========== 元组部分解构操作 ==========
    Note over User,Tuple: 元组部分解构
    User->>VM: exec_untuple_first(VmState* st, unsigned args)
    VM->>VM: extract k from args
    VM->>VM: exec_untuple_first_common(st, k)
    VM-->>User: int result

    User->>VM: exec_untuple_first_var(VmState* st)
    VM->>Stack: pop_long()
    Stack-->>VM: k
    VM->>VM: exec_untuple_first_common(st, k)
    VM-->>User: int result

    User->>VM: exec_untuple_first_common(VmState* st, int k)
    VM->>Stack: pop_tuple()
    Stack-->>VM: tuple
    VM->>Tuple: get tuple length
    Tuple-->>VM: n
    alt k <= n
        VM->>VM: do_explode_tuple(st, tuple, k, -1)
        VM->>Tuple: create new tuple from remaining elements
        Tuple-->>VM: remaining_tuple
        VM->>Stack: push(remaining_tuple)
    else k > n
        VM->>VM: throw exception
    end
    VM-->>User: int result

    %% ========== 元组完全展开操作 ==========
    Note over User,Tuple: 元组完全展开
    User->>VM: exec_explode_tuple(VmState* st, unsigned args)
    VM->>VM: extract n from args
    VM->>VM: exec_explode_tuple_common(st, n)
    VM-->>User: int result

    User->>VM: exec_explode_tuple_var(VmState*