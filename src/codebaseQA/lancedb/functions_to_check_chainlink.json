[{"type": "FunctionDefinition", "name": "BUILDClaim.getFactory", "start_line": 64, "end_line": 66, "offset_start": 2604, "offset_end": 2698, "content": "function getFactory() external view override returns (BUILDFactory) {\n    return i_factory;\n  }", "contract_name": "BUILDClaim", "contract_code": "{\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint256;\n\n  /// @notice The unlock state for a season at a given time\n  struct UnlockState {\n    uint256 unlockElapsedDuration; // The amount of time that has elapsed since\n      // the unlock delay started\n    bool isBeforeUnlock; // Whether the unlock period has started (including the delay)\n    bool isUnlocking; // Whether the unlock period is in progress\n  }\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDClaim 1.0.0\";\n\n  /// @notice The claimed and early claimed states for a user per season\n  mapping(address user => mapping(uint256 seasonId => UserState)) private s_userStates;\n\n  /// @notice The global states for a season\n  mapping(uint256 seasonId => GlobalState globalState) private s_globalStates;\n\n  /// @notice The project token\n  IERC20 private immutable i_token;\n\n  /// @notice The factory that deployed this contract\n  BUILDFactory private immutable i_factory;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @notice constructor\n  /// @param token The project token\n  constructor(\n    address token\n  ) {\n    i_token = IERC20(token);\n    i_factory = BUILDFactory(msg.sender);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getFactory() external view override returns (BUILDFactory) {\n    return i_factory;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getToken() external view override returns (IERC20) {\n    return i_token;\n  }\n\n  /// @inheritdoc IERC165\n  function supportsInterface(\n    bytes4 interfaceId\n  ) external pure override returns (bool) {\n    return interfaceId == type(IBUILDClaim).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  // ================================================================\n  // |                        Token Deposits                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function deposit(\n    uint256 amount\n  ) external override nonReentrant whenClaimNotPaused onlyProjectAdmin {\n    // only callable when factory contract is open\n    if (!i_factory.isOpen()) {\n      revert Closable.AlreadyClosed();\n    }\n\n    uint256 balanceBefore = i_token.balanceOf(address(this));\n    uint256 totalDeposited = i_factory.addTotalDeposited(address(i_token), amount);\n    i_token.safeTransferFrom(msg.sender, address(this), amount);\n    uint256 balanceAfter = i_token.balanceOf(address(this));\n    if (balanceBefore + amount != balanceAfter) {\n      revert InvalidDeposit(balanceBefore, balanceAfter);\n    }\n\n    emit Deposited(address(i_token), msg.sender, amount, totalDeposited);\n  }\n\n  // ================================================================\n  // |                       Token Withdrawals                      |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function withdraw() external override nonReentrant onlyProjectAdmin {\n    (IBUILDFactory.Withdrawal memory withdrawal, uint256 totalWithdrawn) =\n      i_factory.executeWithdraw(address(i_token));\n    i_token.safeTransfer(withdrawal.recipient, withdrawal.amount);\n    emit Withdrawn(address(i_token), withdrawal.recipient, withdrawal.amount, totalWithdrawn);\n  }\n\n  // ================================================================\n  // |                         Token Claims                         |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function claim(\n    address user,\n    ClaimParams[] calldata params\n  ) external override nonReentrant whenClaimNotPaused {\n    _claim(user, params);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getGlobalState(\n    uint256 seasonId\n  ) external view returns (GlobalState memory) {\n    return s_globalStates[seasonId];\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getUserState(\n    UserSeasonId[] calldata usersAndSeasonIds\n  ) external view returns (UserState[] memory) {\n    uint256 count = usersAndSeasonIds.length;\n    UserState[] memory states = new UserState[](count);\n    for (uint256 i; i < count; ++i) {\n      states[i] = s_userStates[usersAndSeasonIds[i].user][usersAndSeasonIds[i].seasonId];\n    }\n    return states;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getCurrentClaimValues(\n    address user,\n    uint256 seasonId,\n    uint256 maxTokenAmount\n  ) external view returns (ClaimableState memory) {\n    (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n      i_factory.getProjectSeasonConfig(address(i_token), seasonId);\n    UnlockState memory unlockState =\n      _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n    return _getClaimableState(\n      config, s_globalStates[seasonId], s_userStates[user][seasonId], unlockState, maxTokenAmount\n    );\n  }\n\n  /// @notice Validates if the user is eligible to claim the amount of tokens for a season\n  /// A merkle tree's leaf consists of a user address, their max token amount for the season and a\n  /// salt\n  /// @param root The merkle root of a season\n  /// @param user The user's address\n  /// @param proof The merkle proof of the user's address, max token amount and salt\n  /// @param maxTokenAmount The user's total claimable token amount for the season\n  /// @param isEarlyClaim Whether the user is claiming early\n  /// @param salt A randomly generated salt to prevent brute-force guessing of merkle proofs\n  /// @return bool Returns true if the user's proof, maxTokenAmount and salt are valid\n  function _verifyMerkleProof(\n    bytes32 root,\n    address user,\n    bytes32[] memory proof,\n    uint256 maxTokenAmount,\n    bool isEarlyClaim,\n    uint256 salt\n  ) private pure returns (bool) {\n    bytes32 leaf =\n      keccak256(bytes.concat(keccak256(abi.encode(user, maxTokenAmount, isEarlyClaim, salt))));\n    return MerkleProof.verify(proof, root, leaf);\n  }\n\n  /// @notice Calculates the amount of tokens that can be claimed by a user for a season\n  /// without requiring an early claim at a particular timestamp.\n  /// This amount is the sum of the base tokens amount that is released all at once after the\n  /// unlock delay and the unlocked amount that is released linearly over the unlock duration.\n  /// This does not factor in any claimed amounts\n  /// @param config The project season config\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param unlockState The unlock state for the season\n  /// @param maxTokenAmount The maximum token amount for the user\n  /// @return ClaimableState The amount of tokens that can be claimed\n  function _getClaimableState(\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    IBUILDClaim.GlobalState memory globalState,\n    UserState memory userState,\n    UnlockState memory unlockState,\n    uint256 maxTokenAmount\n  ) internal pure returns (ClaimableState memory) {\n    ClaimableState memory claimableState;\n    claimableState.base =\n      (maxTokenAmount * config.baseTokenClaimBps) / PERCENTAGE_BASIS_POINTS_DENOMINATOR;\n    claimableState.bonus = maxTokenAmount - claimableState.base;\n\n    if (config.tokenAmount == 0 || (config.isRefunding && userState.claimed == 0)) {\n      return claimableState;\n    }\n\n    claimableState.claimed = userState.claimed;\n\n    if (userState.hasEarlyClaimed || unlockState.isBeforeUnlock) return claimableState;\n    // calculate share of loyalty pool to receive\n    // The loyalty bonus is informative only in the unlock period, as it is not\n    // claimable until the vesting is completed.\n    claimableState.loyaltyBonus = maxTokenAmount * globalState.totalLoyalty\n      / (config.tokenAmount - globalState.totalLoyaltyIneligible);\n\n    if (unlockState.isUnlocking) {\n      // unlock period is in progress\n      claimableState.vested =\n        (claimableState.bonus * unlockState.unlockElapsedDuration) / config.unlockDuration;\n      claimableState.claimable =\n        claimableState.base + claimableState.vested - claimableState.claimed;\n      claimableState.earlyVestableBonus =\n        _calcEarlyVestableBonus(claimableState, config, unlockState.unlockElapsedDuration);\n    } else {\n      // unlock completed\n      claimableState.claimable =\n        maxTokenAmount + claimableState.loyaltyBonus - claimableState.claimed;\n    }\n\n    return claimableState;\n  }\n\n  /// @notice Calculates the amount of bonus tokens that can be claimed early\n  /// @param claimableState The claimable state for the user\n  /// @param config The project season config\n  /// @param timeElapsed The amount of time that has elapsed since the unlock delay started\n  /// @return uint256 The amount of bonus tokens that can be claimed early\n  function _calcEarlyVestableBonus(\n    ClaimableState memory claimableState,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 timeElapsed\n  ) private pure returns (uint256) {\n    return FixedPointMathLib.mulWadDown(\n      claimableState.bonus - claimableState.vested,\n      FixedPointMathLib.divWadDown(config.earlyVestRatioMinBps, PERCENTAGE_BASIS_POINTS_DENOMINATOR)\n        + (\n          FixedPointMathLib.divWadDown(\n            config.earlyVestRatioMaxBps - config.earlyVestRatioMinBps,\n            PERCENTAGE_BASIS_POINTS_DENOMINATOR\n          ) * timeElapsed\n        ) / config.unlockDuration\n    );\n  }\n\n  /// @notice Returns the unlock progress for a season\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockDelay The delay before the unlock period starts\n  /// @param unlockDuration The duration of the unlock period\n  /// @param targetTime The timestamp to evaluate the unlock progress at\n  /// @return UnlockState The unlock state for the target time\n  function _getUnlockState(\n    uint256 unlockStartsAt,\n    uint256 unlockDelay,\n    uint256 unlockDuration,\n    uint256 targetTime\n  ) internal pure returns (UnlockState memory) {\n    uint256 unlockDelayEndsAt = unlockStartsAt + unlockDelay;\n    if (targetTime < unlockDelayEndsAt) {\n      return UnlockState({isBeforeUnlock: true, isUnlocking: false, unlockElapsedDuration: 0});\n    }\n    return UnlockState({\n      isBeforeUnlock: false,\n      isUnlocking: targetTime < unlockDelayEndsAt + unlockDuration,\n      unlockElapsedDuration: targetTime - unlockDelayEndsAt\n    });\n  }\n\n  /// @notice Validates the claim parameters for a user\n  /// @param user The user address\n  /// @param userState The user state for the season\n  /// @param param The claim parameters for a user\n  /// @param config The project season config\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockState The unlock state for the season\n  /// @dev Reverts if the claim parameters are invalid\n  /// @dev Reverts if the unlock period has not started yet, including the configured unlock delay\n  /// @dev Reverts if the project season does not exist for the given token address\n  /// @dev Reverts if the user's proof is invalid\n  /// @dev Reverts if user attempts to earlyClaim after previously early claiming during the unlock\n  /// period\n  function _validateClaimParams(\n    address user,\n    UserState memory userState,\n    ClaimParams memory param,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 unlockStartsAt,\n    UnlockState memory unlockState\n  ) private view {\n    if (user == address(0)) {\n      revert InvalidUser(user);\n    }\n    if (unlockStartsAt == 0) {\n      revert IBUILDFactory.SeasonDoesNotExist(param.seasonId);\n    }\n    if (unlockState.isBeforeUnlock) {\n      revert UnlockNotStarted(param.seasonId);\n    }\n    if (config.tokenAmount == 0) {\n      revert IBUILDFactory.ProjectSeasonDoesNotExist(param.seasonId, address(i_token));\n    }\n    if (\n      !_verifyMerkleProof(\n        config.merkleRoot, user, param.proof, param.maxTokenAmount, param.isEarlyClaim, param.salt\n      )\n    ) {\n      revert InvalidMerkleProof();\n    }\n    if (unlockState.isUnlocking && param.isEarlyClaim && userState.hasEarlyClaimed) {\n      revert InvalidEarlyClaim(user, param.seasonId);\n    }\n    if (userState.claimed == 0 && config.isRefunding) {\n      // If the user hasn't claimed for this season before the refunding starts, the user will\n      // be refunded their allocated credits but can no longer claim tokens\n      revert IBUILDFactory.ProjectSeasonIsRefunding(address(i_token), param.seasonId);\n    }\n  }\n\n  /// @notice Util function that claims tokens for a user for multiple seasons\n  /// @param user The user address\n  /// @param params An array of claim params including the season ID, proof, and max token amount\n  /// for each season\n  function _claim(address user, ClaimParams[] memory params) private {\n    uint256 totalClaimableAmount;\n    bool isEarlyClaim = false;\n\n    // Cache array length outside loop\n    uint256 paramsLength = params.length;\n    for (uint256 i = 0; i < paramsLength; ++i) {\n      ClaimParams memory param = params[i];\n      if (param.isEarlyClaim) {\n        isEarlyClaim = true;\n      }\n      (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n        i_factory.getProjectSeasonConfig(address(i_token), param.seasonId);\n\n      UserState memory userState = s_userStates[user][param.seasonId];\n      UnlockState memory unlockState =\n        _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n\n      _validateClaimParams(user, userState, param, config, unlockStartsAt, unlockState);\n\n      if (userState.hasEarlyClaimed) {\n        continue;\n      }\n\n      GlobalState storage globalState = s_globalStates[param.seasonId];\n      ClaimableState memory claimableState =\n        _getClaimableState(config, globalState, userState, unlockState, param.maxTokenAmount);\n\n      // short-circuit on potential zero claim value before consuming refundable amount\n      // if regular claim, claimable must be > 0\n      // if early claim, earlyClaimable must be > 0\n      if (\n        (claimableState.claimable == 0 && !param.isEarlyClaim)\n          || (\n            claimableState.claimable == 0 && claimableState.earlyVestableBonus == 0\n              && param.isEarlyClaim\n          )\n      ) {\n        continue;\n      }\n\n      if (claimableState.claimed == 0) {\n        // User is claiming for the first time for this particular season, so the project can no\n        // longer reclaim the refundable amount for this user's credits\n        i_factory.reduceRefundableAmount(address(i_token), param.seasonId, param.maxTokenAmount);\n      }\n      uint256 toBeClaimed = claimableState.claimable;\n      if (unlockState.isUnlocking && param.isEarlyClaim) {\n        globalState.totalLoyalty +=\n          claimableState.bonus - claimableState.vested - claimableState.earlyVestableBonus;\n        globalState.totalLoyaltyIneligible += param.maxTokenAmount;\n        userState.hasEarlyClaimed = true;\n        toBeClaimed += claimableState.earlyVestableBonus;\n      }\n\n      totalClaimableAmount += toBeClaimed;\n      _updateClaimedAmounts(\n        user,\n        globalState,\n        userState,\n        param,\n        toBeClaimed,\n        param.isEarlyClaim ? claimableState.earlyVestableBonus : 0\n      );\n    }\n\n    if (isEarlyClaim && user != msg.sender) {\n      if (\n        !i_factory.getDelegateRegistry().checkDelegateForContract({\n          to: msg.sender,\n          from: user,\n          contract_: address(i_factory),\n          rights: bytes32(0)\n        })\n      ) {\n        revert InvalidSender(msg.sender);\n      }\n    }\n\n    if (totalClaimableAmount == 0) {\n      return;\n    }\n    i_token.safeTransfer(user, totalClaimableAmount);\n  }\n\n  /// @notice Updates the claimed amounts for a user and the season\n  /// @param user The user address\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param param The input parameters for the claim\n  /// @param toBeClaimed The amount of tokens to be claimed by the user\n  /// @param earlyVestableBonus The amount of bonus tokens that can be claimed early\n  /// @dev This function is called when a user claims tokens\n  function _updateClaimedAmounts(\n    address user,\n    GlobalState storage globalState,\n    UserState memory userState,\n    ClaimParams memory param,\n    uint256 toBeClaimed,\n    uint256 earlyVestableBonus\n  ) private {\n    userState.claimed += uint248(toBeClaimed);\n    s_userStates[user][param.seasonId] = userState;\n\n    globalState.totalClaimed += toBeClaimed;\n\n    emit Claimed(\n      user,\n      param.seasonId,\n      toBeClaimed,\n      param.isEarlyClaim,\n      earlyVestableBonus,\n      userState.claimed,\n      globalState.totalClaimed,\n      globalState.totalLoyalty,\n      globalState.totalLoyaltyIneligible\n    );\n  }\n\n  /// @notice Only callable by the factory contract admin\n  modifier onlyProjectAdmin() {\n    if (msg.sender != i_factory.getProjectConfig(address(i_token)).admin) {\n      revert IAccessControl.AccessControlUnauthorizedAccount(msg.sender, keccak256(\"PROJECT_ADMIN\"));\n    }\n    _;\n  }\n\n  /// @notice Only callable when claim contract is not paused\n  modifier whenClaimNotPaused() {\n    if (i_factory.isClaimContractPaused(address(i_token))) {\n      revert Pausable.EnforcedPause();\n    }\n    _;\n  }\n}", "modifiers": [], "stateMutability": "view", "returnParameters": null, "visibility": "external", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol"}, {"type": "FunctionDefinition", "name": "BUILDClaim.getToken", "start_line": 69, "end_line": 71, "offset_start": 2733, "offset_end": 2817, "content": "function getToken() external view override returns (IERC20) {\n    return i_token;\n  }", "contract_name": "BUILDClaim", "contract_code": "{\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint256;\n\n  /// @notice The unlock state for a season at a given time\n  struct UnlockState {\n    uint256 unlockElapsedDuration; // The amount of time that has elapsed since\n      // the unlock delay started\n    bool isBeforeUnlock; // Whether the unlock period has started (including the delay)\n    bool isUnlocking; // Whether the unlock period is in progress\n  }\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDClaim 1.0.0\";\n\n  /// @notice The claimed and early claimed states for a user per season\n  mapping(address user => mapping(uint256 seasonId => UserState)) private s_userStates;\n\n  /// @notice The global states for a season\n  mapping(uint256 seasonId => GlobalState globalState) private s_globalStates;\n\n  /// @notice The project token\n  IERC20 private immutable i_token;\n\n  /// @notice The factory that deployed this contract\n  BUILDFactory private immutable i_factory;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @notice constructor\n  /// @param token The project token\n  constructor(\n    address token\n  ) {\n    i_token = IERC20(token);\n    i_factory = BUILDFactory(msg.sender);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getFactory() external view override returns (BUILDFactory) {\n    return i_factory;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getToken() external view override returns (IERC20) {\n    return i_token;\n  }\n\n  /// @inheritdoc IERC165\n  function supportsInterface(\n    bytes4 interfaceId\n  ) external pure override returns (bool) {\n    return interfaceId == type(IBUILDClaim).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  // ================================================================\n  // |                        Token Deposits                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function deposit(\n    uint256 amount\n  ) external override nonReentrant whenClaimNotPaused onlyProjectAdmin {\n    // only callable when factory contract is open\n    if (!i_factory.isOpen()) {\n      revert Closable.AlreadyClosed();\n    }\n\n    uint256 balanceBefore = i_token.balanceOf(address(this));\n    uint256 totalDeposited = i_factory.addTotalDeposited(address(i_token), amount);\n    i_token.safeTransferFrom(msg.sender, address(this), amount);\n    uint256 balanceAfter = i_token.balanceOf(address(this));\n    if (balanceBefore + amount != balanceAfter) {\n      revert InvalidDeposit(balanceBefore, balanceAfter);\n    }\n\n    emit Deposited(address(i_token), msg.sender, amount, totalDeposited);\n  }\n\n  // ================================================================\n  // |                       Token Withdrawals                      |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function withdraw() external override nonReentrant onlyProjectAdmin {\n    (IBUILDFactory.Withdrawal memory withdrawal, uint256 totalWithdrawn) =\n      i_factory.executeWithdraw(address(i_token));\n    i_token.safeTransfer(withdrawal.recipient, withdrawal.amount);\n    emit Withdrawn(address(i_token), withdrawal.recipient, withdrawal.amount, totalWithdrawn);\n  }\n\n  // ================================================================\n  // |                         Token Claims                         |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function claim(\n    address user,\n    ClaimParams[] calldata params\n  ) external override nonReentrant whenClaimNotPaused {\n    _claim(user, params);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getGlobalState(\n    uint256 seasonId\n  ) external view returns (GlobalState memory) {\n    return s_globalStates[seasonId];\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getUserState(\n    UserSeasonId[] calldata usersAndSeasonIds\n  ) external view returns (UserState[] memory) {\n    uint256 count = usersAndSeasonIds.length;\n    UserState[] memory states = new UserState[](count);\n    for (uint256 i; i < count; ++i) {\n      states[i] = s_userStates[usersAndSeasonIds[i].user][usersAndSeasonIds[i].seasonId];\n    }\n    return states;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getCurrentClaimValues(\n    address user,\n    uint256 seasonId,\n    uint256 maxTokenAmount\n  ) external view returns (ClaimableState memory) {\n    (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n      i_factory.getProjectSeasonConfig(address(i_token), seasonId);\n    UnlockState memory unlockState =\n      _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n    return _getClaimableState(\n      config, s_globalStates[seasonId], s_userStates[user][seasonId], unlockState, maxTokenAmount\n    );\n  }\n\n  /// @notice Validates if the user is eligible to claim the amount of tokens for a season\n  /// A merkle tree's leaf consists of a user address, their max token amount for the season and a\n  /// salt\n  /// @param root The merkle root of a season\n  /// @param user The user's address\n  /// @param proof The merkle proof of the user's address, max token amount and salt\n  /// @param maxTokenAmount The user's total claimable token amount for the season\n  /// @param isEarlyClaim Whether the user is claiming early\n  /// @param salt A randomly generated salt to prevent brute-force guessing of merkle proofs\n  /// @return bool Returns true if the user's proof, maxTokenAmount and salt are valid\n  function _verifyMerkleProof(\n    bytes32 root,\n    address user,\n    bytes32[] memory proof,\n    uint256 maxTokenAmount,\n    bool isEarlyClaim,\n    uint256 salt\n  ) private pure returns (bool) {\n    bytes32 leaf =\n      keccak256(bytes.concat(keccak256(abi.encode(user, maxTokenAmount, isEarlyClaim, salt))));\n    return MerkleProof.verify(proof, root, leaf);\n  }\n\n  /// @notice Calculates the amount of tokens that can be claimed by a user for a season\n  /// without requiring an early claim at a particular timestamp.\n  /// This amount is the sum of the base tokens amount that is released all at once after the\n  /// unlock delay and the unlocked amount that is released linearly over the unlock duration.\n  /// This does not factor in any claimed amounts\n  /// @param config The project season config\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param unlockState The unlock state for the season\n  /// @param maxTokenAmount The maximum token amount for the user\n  /// @return ClaimableState The amount of tokens that can be claimed\n  function _getClaimableState(\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    IBUILDClaim.GlobalState memory globalState,\n    UserState memory userState,\n    UnlockState memory unlockState,\n    uint256 maxTokenAmount\n  ) internal pure returns (ClaimableState memory) {\n    ClaimableState memory claimableState;\n    claimableState.base =\n      (maxTokenAmount * config.baseTokenClaimBps) / PERCENTAGE_BASIS_POINTS_DENOMINATOR;\n    claimableState.bonus = maxTokenAmount - claimableState.base;\n\n    if (config.tokenAmount == 0 || (config.isRefunding && userState.claimed == 0)) {\n      return claimableState;\n    }\n\n    claimableState.claimed = userState.claimed;\n\n    if (userState.hasEarlyClaimed || unlockState.isBeforeUnlock) return claimableState;\n    // calculate share of loyalty pool to receive\n    // The loyalty bonus is informative only in the unlock period, as it is not\n    // claimable until the vesting is completed.\n    claimableState.loyaltyBonus = maxTokenAmount * globalState.totalLoyalty\n      / (config.tokenAmount - globalState.totalLoyaltyIneligible);\n\n    if (unlockState.isUnlocking) {\n      // unlock period is in progress\n      claimableState.vested =\n        (claimableState.bonus * unlockState.unlockElapsedDuration) / config.unlockDuration;\n      claimableState.claimable =\n        claimableState.base + claimableState.vested - claimableState.claimed;\n      claimableState.earlyVestableBonus =\n        _calcEarlyVestableBonus(claimableState, config, unlockState.unlockElapsedDuration);\n    } else {\n      // unlock completed\n      claimableState.claimable =\n        maxTokenAmount + claimableState.loyaltyBonus - claimableState.claimed;\n    }\n\n    return claimableState;\n  }\n\n  /// @notice Calculates the amount of bonus tokens that can be claimed early\n  /// @param claimableState The claimable state for the user\n  /// @param config The project season config\n  /// @param timeElapsed The amount of time that has elapsed since the unlock delay started\n  /// @return uint256 The amount of bonus tokens that can be claimed early\n  function _calcEarlyVestableBonus(\n    ClaimableState memory claimableState,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 timeElapsed\n  ) private pure returns (uint256) {\n    return FixedPointMathLib.mulWadDown(\n      claimableState.bonus - claimableState.vested,\n      FixedPointMathLib.divWadDown(config.earlyVestRatioMinBps, PERCENTAGE_BASIS_POINTS_DENOMINATOR)\n        + (\n          FixedPointMathLib.divWadDown(\n            config.earlyVestRatioMaxBps - config.earlyVestRatioMinBps,\n            PERCENTAGE_BASIS_POINTS_DENOMINATOR\n          ) * timeElapsed\n        ) / config.unlockDuration\n    );\n  }\n\n  /// @notice Returns the unlock progress for a season\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockDelay The delay before the unlock period starts\n  /// @param unlockDuration The duration of the unlock period\n  /// @param targetTime The timestamp to evaluate the unlock progress at\n  /// @return UnlockState The unlock state for the target time\n  function _getUnlockState(\n    uint256 unlockStartsAt,\n    uint256 unlockDelay,\n    uint256 unlockDuration,\n    uint256 targetTime\n  ) internal pure returns (UnlockState memory) {\n    uint256 unlockDelayEndsAt = unlockStartsAt + unlockDelay;\n    if (targetTime < unlockDelayEndsAt) {\n      return UnlockState({isBeforeUnlock: true, isUnlocking: false, unlockElapsedDuration: 0});\n    }\n    return UnlockState({\n      isBeforeUnlock: false,\n      isUnlocking: targetTime < unlockDelayEndsAt + unlockDuration,\n      unlockElapsedDuration: targetTime - unlockDelayEndsAt\n    });\n  }\n\n  /// @notice Validates the claim parameters for a user\n  /// @param user The user address\n  /// @param userState The user state for the season\n  /// @param param The claim parameters for a user\n  /// @param config The project season config\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockState The unlock state for the season\n  /// @dev Reverts if the claim parameters are invalid\n  /// @dev Reverts if the unlock period has not started yet, including the configured unlock delay\n  /// @dev Reverts if the project season does not exist for the given token address\n  /// @dev Reverts if the user's proof is invalid\n  /// @dev Reverts if user attempts to earlyClaim after previously early claiming during the unlock\n  /// period\n  function _validateClaimParams(\n    address user,\n    UserState memory userState,\n    ClaimParams memory param,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 unlockStartsAt,\n    UnlockState memory unlockState\n  ) private view {\n    if (user == address(0)) {\n      revert InvalidUser(user);\n    }\n    if (unlockStartsAt == 0) {\n      revert IBUILDFactory.SeasonDoesNotExist(param.seasonId);\n    }\n    if (unlockState.isBeforeUnlock) {\n      revert UnlockNotStarted(param.seasonId);\n    }\n    if (config.tokenAmount == 0) {\n      revert IBUILDFactory.ProjectSeasonDoesNotExist(param.seasonId, address(i_token));\n    }\n    if (\n      !_verifyMerkleProof(\n        config.merkleRoot, user, param.proof, param.maxTokenAmount, param.isEarlyClaim, param.salt\n      )\n    ) {\n      revert InvalidMerkleProof();\n    }\n    if (unlockState.isUnlocking && param.isEarlyClaim && userState.hasEarlyClaimed) {\n      revert InvalidEarlyClaim(user, param.seasonId);\n    }\n    if (userState.claimed == 0 && config.isRefunding) {\n      // If the user hasn't claimed for this season before the refunding starts, the user will\n      // be refunded their allocated credits but can no longer claim tokens\n      revert IBUILDFactory.ProjectSeasonIsRefunding(address(i_token), param.seasonId);\n    }\n  }\n\n  /// @notice Util function that claims tokens for a user for multiple seasons\n  /// @param user The user address\n  /// @param params An array of claim params including the season ID, proof, and max token amount\n  /// for each season\n  function _claim(address user, ClaimParams[] memory params) private {\n    uint256 totalClaimableAmount;\n    bool isEarlyClaim = false;\n\n    // Cache array length outside loop\n    uint256 paramsLength = params.length;\n    for (uint256 i = 0; i < paramsLength; ++i) {\n      ClaimParams memory param = params[i];\n      if (param.isEarlyClaim) {\n        isEarlyClaim = true;\n      }\n      (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n        i_factory.getProjectSeasonConfig(address(i_token), param.seasonId);\n\n      UserState memory userState = s_userStates[user][param.seasonId];\n      UnlockState memory unlockState =\n        _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n\n      _validateClaimParams(user, userState, param, config, unlockStartsAt, unlockState);\n\n      if (userState.hasEarlyClaimed) {\n        continue;\n      }\n\n      GlobalState storage globalState = s_globalStates[param.seasonId];\n      ClaimableState memory claimableState =\n        _getClaimableState(config, globalState, userState, unlockState, param.maxTokenAmount);\n\n      // short-circuit on potential zero claim value before consuming refundable amount\n      // if regular claim, claimable must be > 0\n      // if early claim, earlyClaimable must be > 0\n      if (\n        (claimableState.claimable == 0 && !param.isEarlyClaim)\n          || (\n            claimableState.claimable == 0 && claimableState.earlyVestableBonus == 0\n              && param.isEarlyClaim\n          )\n      ) {\n        continue;\n      }\n\n      if (claimableState.claimed == 0) {\n        // User is claiming for the first time for this particular season, so the project can no\n        // longer reclaim the refundable amount for this user's credits\n        i_factory.reduceRefundableAmount(address(i_token), param.seasonId, param.maxTokenAmount);\n      }\n      uint256 toBeClaimed = claimableState.claimable;\n      if (unlockState.isUnlocking && param.isEarlyClaim) {\n        globalState.totalLoyalty +=\n          claimableState.bonus - claimableState.vested - claimableState.earlyVestableBonus;\n        globalState.totalLoyaltyIneligible += param.maxTokenAmount;\n        userState.hasEarlyClaimed = true;\n        toBeClaimed += claimableState.earlyVestableBonus;\n      }\n\n      totalClaimableAmount += toBeClaimed;\n      _updateClaimedAmounts(\n        user,\n        globalState,\n        userState,\n        param,\n        toBeClaimed,\n        param.isEarlyClaim ? claimableState.earlyVestableBonus : 0\n      );\n    }\n\n    if (isEarlyClaim && user != msg.sender) {\n      if (\n        !i_factory.getDelegateRegistry().checkDelegateForContract({\n          to: msg.sender,\n          from: user,\n          contract_: address(i_factory),\n          rights: bytes32(0)\n        })\n      ) {\n        revert InvalidSender(msg.sender);\n      }\n    }\n\n    if (totalClaimableAmount == 0) {\n      return;\n    }\n    i_token.safeTransfer(user, totalClaimableAmount);\n  }\n\n  /// @notice Updates the claimed amounts for a user and the season\n  /// @param user The user address\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param param The input parameters for the claim\n  /// @param toBeClaimed The amount of tokens to be claimed by the user\n  /// @param earlyVestableBonus The amount of bonus tokens that can be claimed early\n  /// @dev This function is called when a user claims tokens\n  function _updateClaimedAmounts(\n    address user,\n    GlobalState storage globalState,\n    UserState memory userState,\n    ClaimParams memory param,\n    uint256 toBeClaimed,\n    uint256 earlyVestableBonus\n  ) private {\n    userState.claimed += uint248(toBeClaimed);\n    s_userStates[user][param.seasonId] = userState;\n\n    globalState.totalClaimed += toBeClaimed;\n\n    emit Claimed(\n      user,\n      param.seasonId,\n      toBeClaimed,\n      param.isEarlyClaim,\n      earlyVestableBonus,\n      userState.claimed,\n      globalState.totalClaimed,\n      globalState.totalLoyalty,\n      globalState.totalLoyaltyIneligible\n    );\n  }\n\n  /// @notice Only callable by the factory contract admin\n  modifier onlyProjectAdmin() {\n    if (msg.sender != i_factory.getProjectConfig(address(i_token)).admin) {\n      revert IAccessControl.AccessControlUnauthorizedAccount(msg.sender, keccak256(\"PROJECT_ADMIN\"));\n    }\n    _;\n  }\n\n  /// @notice Only callable when claim contract is not paused\n  modifier whenClaimNotPaused() {\n    if (i_factory.isClaimContractPaused(address(i_token))) {\n      revert Pausable.EnforcedPause();\n    }\n    _;\n  }\n}", "modifiers": [], "stateMutability": "view", "returnParameters": null, "visibility": "external", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol"}, {"type": "FunctionDefinition", "name": "BUILDClaim.supportsInterface", "start_line": 74, "end_line": 78, "offset_start": 2848, "offset_end": 3046, "content": "function supportsInterface(\n    bytes4 interfaceId\n  ) external pure override returns (bool) {\n    return interfaceId == type(IBUILDClaim).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }", "contract_name": "BUILDClaim", "contract_code": "{\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint256;\n\n  /// @notice The unlock state for a season at a given time\n  struct UnlockState {\n    uint256 unlockElapsedDuration; // The amount of time that has elapsed since\n      // the unlock delay started\n    bool isBeforeUnlock; // Whether the unlock period has started (including the delay)\n    bool isUnlocking; // Whether the unlock period is in progress\n  }\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDClaim 1.0.0\";\n\n  /// @notice The claimed and early claimed states for a user per season\n  mapping(address user => mapping(uint256 seasonId => UserState)) private s_userStates;\n\n  /// @notice The global states for a season\n  mapping(uint256 seasonId => GlobalState globalState) private s_globalStates;\n\n  /// @notice The project token\n  IERC20 private immutable i_token;\n\n  /// @notice The factory that deployed this contract\n  BUILDFactory private immutable i_factory;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @notice constructor\n  /// @param token The project token\n  constructor(\n    address token\n  ) {\n    i_token = IERC20(token);\n    i_factory = BUILDFactory(msg.sender);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getFactory() external view override returns (BUILDFactory) {\n    return i_factory;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getToken() external view override returns (IERC20) {\n    return i_token;\n  }\n\n  /// @inheritdoc IERC165\n  function supportsInterface(\n    bytes4 interfaceId\n  ) external pure override returns (bool) {\n    return interfaceId == type(IBUILDClaim).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  // ================================================================\n  // |                        Token Deposits                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function deposit(\n    uint256 amount\n  ) external override nonReentrant whenClaimNotPaused onlyProjectAdmin {\n    // only callable when factory contract is open\n    if (!i_factory.isOpen()) {\n      revert Closable.AlreadyClosed();\n    }\n\n    uint256 balanceBefore = i_token.balanceOf(address(this));\n    uint256 totalDeposited = i_factory.addTotalDeposited(address(i_token), amount);\n    i_token.safeTransferFrom(msg.sender, address(this), amount);\n    uint256 balanceAfter = i_token.balanceOf(address(this));\n    if (balanceBefore + amount != balanceAfter) {\n      revert InvalidDeposit(balanceBefore, balanceAfter);\n    }\n\n    emit Deposited(address(i_token), msg.sender, amount, totalDeposited);\n  }\n\n  // ================================================================\n  // |                       Token Withdrawals                      |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function withdraw() external override nonReentrant onlyProjectAdmin {\n    (IBUILDFactory.Withdrawal memory withdrawal, uint256 totalWithdrawn) =\n      i_factory.executeWithdraw(address(i_token));\n    i_token.safeTransfer(withdrawal.recipient, withdrawal.amount);\n    emit Withdrawn(address(i_token), withdrawal.recipient, withdrawal.amount, totalWithdrawn);\n  }\n\n  // ================================================================\n  // |                         Token Claims                         |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function claim(\n    address user,\n    ClaimParams[] calldata params\n  ) external override nonReentrant whenClaimNotPaused {\n    _claim(user, params);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getGlobalState(\n    uint256 seasonId\n  ) external view returns (GlobalState memory) {\n    return s_globalStates[seasonId];\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getUserState(\n    UserSeasonId[] calldata usersAndSeasonIds\n  ) external view returns (UserState[] memory) {\n    uint256 count = usersAndSeasonIds.length;\n    UserState[] memory states = new UserState[](count);\n    for (uint256 i; i < count; ++i) {\n      states[i] = s_userStates[usersAndSeasonIds[i].user][usersAndSeasonIds[i].seasonId];\n    }\n    return states;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getCurrentClaimValues(\n    address user,\n    uint256 seasonId,\n    uint256 maxTokenAmount\n  ) external view returns (ClaimableState memory) {\n    (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n      i_factory.getProjectSeasonConfig(address(i_token), seasonId);\n    UnlockState memory unlockState =\n      _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n    return _getClaimableState(\n      config, s_globalStates[seasonId], s_userStates[user][seasonId], unlockState, maxTokenAmount\n    );\n  }\n\n  /// @notice Validates if the user is eligible to claim the amount of tokens for a season\n  /// A merkle tree's leaf consists of a user address, their max token amount for the season and a\n  /// salt\n  /// @param root The merkle root of a season\n  /// @param user The user's address\n  /// @param proof The merkle proof of the user's address, max token amount and salt\n  /// @param maxTokenAmount The user's total claimable token amount for the season\n  /// @param isEarlyClaim Whether the user is claiming early\n  /// @param salt A randomly generated salt to prevent brute-force guessing of merkle proofs\n  /// @return bool Returns true if the user's proof, maxTokenAmount and salt are valid\n  function _verifyMerkleProof(\n    bytes32 root,\n    address user,\n    bytes32[] memory proof,\n    uint256 maxTokenAmount,\n    bool isEarlyClaim,\n    uint256 salt\n  ) private pure returns (bool) {\n    bytes32 leaf =\n      keccak256(bytes.concat(keccak256(abi.encode(user, maxTokenAmount, isEarlyClaim, salt))));\n    return MerkleProof.verify(proof, root, leaf);\n  }\n\n  /// @notice Calculates the amount of tokens that can be claimed by a user for a season\n  /// without requiring an early claim at a particular timestamp.\n  /// This amount is the sum of the base tokens amount that is released all at once after the\n  /// unlock delay and the unlocked amount that is released linearly over the unlock duration.\n  /// This does not factor in any claimed amounts\n  /// @param config The project season config\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param unlockState The unlock state for the season\n  /// @param maxTokenAmount The maximum token amount for the user\n  /// @return ClaimableState The amount of tokens that can be claimed\n  function _getClaimableState(\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    IBUILDClaim.GlobalState memory globalState,\n    UserState memory userState,\n    UnlockState memory unlockState,\n    uint256 maxTokenAmount\n  ) internal pure returns (ClaimableState memory) {\n    ClaimableState memory claimableState;\n    claimableState.base =\n      (maxTokenAmount * config.baseTokenClaimBps) / PERCENTAGE_BASIS_POINTS_DENOMINATOR;\n    claimableState.bonus = maxTokenAmount - claimableState.base;\n\n    if (config.tokenAmount == 0 || (config.isRefunding && userState.claimed == 0)) {\n      return claimableState;\n    }\n\n    claimableState.claimed = userState.claimed;\n\n    if (userState.hasEarlyClaimed || unlockState.isBeforeUnlock) return claimableState;\n    // calculate share of loyalty pool to receive\n    // The loyalty bonus is informative only in the unlock period, as it is not\n    // claimable until the vesting is completed.\n    claimableState.loyaltyBonus = maxTokenAmount * globalState.totalLoyalty\n      / (config.tokenAmount - globalState.totalLoyaltyIneligible);\n\n    if (unlockState.isUnlocking) {\n      // unlock period is in progress\n      claimableState.vested =\n        (claimableState.bonus * unlockState.unlockElapsedDuration) / config.unlockDuration;\n      claimableState.claimable =\n        claimableState.base + claimableState.vested - claimableState.claimed;\n      claimableState.earlyVestableBonus =\n        _calcEarlyVestableBonus(claimableState, config, unlockState.unlockElapsedDuration);\n    } else {\n      // unlock completed\n      claimableState.claimable =\n        maxTokenAmount + claimableState.loyaltyBonus - claimableState.claimed;\n    }\n\n    return claimableState;\n  }\n\n  /// @notice Calculates the amount of bonus tokens that can be claimed early\n  /// @param claimableState The claimable state for the user\n  /// @param config The project season config\n  /// @param timeElapsed The amount of time that has elapsed since the unlock delay started\n  /// @return uint256 The amount of bonus tokens that can be claimed early\n  function _calcEarlyVestableBonus(\n    ClaimableState memory claimableState,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 timeElapsed\n  ) private pure returns (uint256) {\n    return FixedPointMathLib.mulWadDown(\n      claimableState.bonus - claimableState.vested,\n      FixedPointMathLib.divWadDown(config.earlyVestRatioMinBps, PERCENTAGE_BASIS_POINTS_DENOMINATOR)\n        + (\n          FixedPointMathLib.divWadDown(\n            config.earlyVestRatioMaxBps - config.earlyVestRatioMinBps,\n            PERCENTAGE_BASIS_POINTS_DENOMINATOR\n          ) * timeElapsed\n        ) / config.unlockDuration\n    );\n  }\n\n  /// @notice Returns the unlock progress for a season\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockDelay The delay before the unlock period starts\n  /// @param unlockDuration The duration of the unlock period\n  /// @param targetTime The timestamp to evaluate the unlock progress at\n  /// @return UnlockState The unlock state for the target time\n  function _getUnlockState(\n    uint256 unlockStartsAt,\n    uint256 unlockDelay,\n    uint256 unlockDuration,\n    uint256 targetTime\n  ) internal pure returns (UnlockState memory) {\n    uint256 unlockDelayEndsAt = unlockStartsAt + unlockDelay;\n    if (targetTime < unlockDelayEndsAt) {\n      return UnlockState({isBeforeUnlock: true, isUnlocking: false, unlockElapsedDuration: 0});\n    }\n    return UnlockState({\n      isBeforeUnlock: false,\n      isUnlocking: targetTime < unlockDelayEndsAt + unlockDuration,\n      unlockElapsedDuration: targetTime - unlockDelayEndsAt\n    });\n  }\n\n  /// @notice Validates the claim parameters for a user\n  /// @param user The user address\n  /// @param userState The user state for the season\n  /// @param param The claim parameters for a user\n  /// @param config The project season config\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockState The unlock state for the season\n  /// @dev Reverts if the claim parameters are invalid\n  /// @dev Reverts if the unlock period has not started yet, including the configured unlock delay\n  /// @dev Reverts if the project season does not exist for the given token address\n  /// @dev Reverts if the user's proof is invalid\n  /// @dev Reverts if user attempts to earlyClaim after previously early claiming during the unlock\n  /// period\n  function _validateClaimParams(\n    address user,\n    UserState memory userState,\n    ClaimParams memory param,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 unlockStartsAt,\n    UnlockState memory unlockState\n  ) private view {\n    if (user == address(0)) {\n      revert InvalidUser(user);\n    }\n    if (unlockStartsAt == 0) {\n      revert IBUILDFactory.SeasonDoesNotExist(param.seasonId);\n    }\n    if (unlockState.isBeforeUnlock) {\n      revert UnlockNotStarted(param.seasonId);\n    }\n    if (config.tokenAmount == 0) {\n      revert IBUILDFactory.ProjectSeasonDoesNotExist(param.seasonId, address(i_token));\n    }\n    if (\n      !_verifyMerkleProof(\n        config.merkleRoot, user, param.proof, param.maxTokenAmount, param.isEarlyClaim, param.salt\n      )\n    ) {\n      revert InvalidMerkleProof();\n    }\n    if (unlockState.isUnlocking && param.isEarlyClaim && userState.hasEarlyClaimed) {\n      revert InvalidEarlyClaim(user, param.seasonId);\n    }\n    if (userState.claimed == 0 && config.isRefunding) {\n      // If the user hasn't claimed for this season before the refunding starts, the user will\n      // be refunded their allocated credits but can no longer claim tokens\n      revert IBUILDFactory.ProjectSeasonIsRefunding(address(i_token), param.seasonId);\n    }\n  }\n\n  /// @notice Util function that claims tokens for a user for multiple seasons\n  /// @param user The user address\n  /// @param params An array of claim params including the season ID, proof, and max token amount\n  /// for each season\n  function _claim(address user, ClaimParams[] memory params) private {\n    uint256 totalClaimableAmount;\n    bool isEarlyClaim = false;\n\n    // Cache array length outside loop\n    uint256 paramsLength = params.length;\n    for (uint256 i = 0; i < paramsLength; ++i) {\n      ClaimParams memory param = params[i];\n      if (param.isEarlyClaim) {\n        isEarlyClaim = true;\n      }\n      (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n        i_factory.getProjectSeasonConfig(address(i_token), param.seasonId);\n\n      UserState memory userState = s_userStates[user][param.seasonId];\n      UnlockState memory unlockState =\n        _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n\n      _validateClaimParams(user, userState, param, config, unlockStartsAt, unlockState);\n\n      if (userState.hasEarlyClaimed) {\n        continue;\n      }\n\n      GlobalState storage globalState = s_globalStates[param.seasonId];\n      ClaimableState memory claimableState =\n        _getClaimableState(config, globalState, userState, unlockState, param.maxTokenAmount);\n\n      // short-circuit on potential zero claim value before consuming refundable amount\n      // if regular claim, claimable must be > 0\n      // if early claim, earlyClaimable must be > 0\n      if (\n        (claimableState.claimable == 0 && !param.isEarlyClaim)\n          || (\n            claimableState.claimable == 0 && claimableState.earlyVestableBonus == 0\n              && param.isEarlyClaim\n          )\n      ) {\n        continue;\n      }\n\n      if (claimableState.claimed == 0) {\n        // User is claiming for the first time for this particular season, so the project can no\n        // longer reclaim the refundable amount for this user's credits\n        i_factory.reduceRefundableAmount(address(i_token), param.seasonId, param.maxTokenAmount);\n      }\n      uint256 toBeClaimed = claimableState.claimable;\n      if (unlockState.isUnlocking && param.isEarlyClaim) {\n        globalState.totalLoyalty +=\n          claimableState.bonus - claimableState.vested - claimableState.earlyVestableBonus;\n        globalState.totalLoyaltyIneligible += param.maxTokenAmount;\n        userState.hasEarlyClaimed = true;\n        toBeClaimed += claimableState.earlyVestableBonus;\n      }\n\n      totalClaimableAmount += toBeClaimed;\n      _updateClaimedAmounts(\n        user,\n        globalState,\n        userState,\n        param,\n        toBeClaimed,\n        param.isEarlyClaim ? claimableState.earlyVestableBonus : 0\n      );\n    }\n\n    if (isEarlyClaim && user != msg.sender) {\n      if (\n        !i_factory.getDelegateRegistry().checkDelegateForContract({\n          to: msg.sender,\n          from: user,\n          contract_: address(i_factory),\n          rights: bytes32(0)\n        })\n      ) {\n        revert InvalidSender(msg.sender);\n      }\n    }\n\n    if (totalClaimableAmount == 0) {\n      return;\n    }\n    i_token.safeTransfer(user, totalClaimableAmount);\n  }\n\n  /// @notice Updates the claimed amounts for a user and the season\n  /// @param user The user address\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param param The input parameters for the claim\n  /// @param toBeClaimed The amount of tokens to be claimed by the user\n  /// @param earlyVestableBonus The amount of bonus tokens that can be claimed early\n  /// @dev This function is called when a user claims tokens\n  function _updateClaimedAmounts(\n    address user,\n    GlobalState storage globalState,\n    UserState memory userState,\n    ClaimParams memory param,\n    uint256 toBeClaimed,\n    uint256 earlyVestableBonus\n  ) private {\n    userState.claimed += uint248(toBeClaimed);\n    s_userStates[user][param.seasonId] = userState;\n\n    globalState.totalClaimed += toBeClaimed;\n\n    emit Claimed(\n      user,\n      param.seasonId,\n      toBeClaimed,\n      param.isEarlyClaim,\n      earlyVestableBonus,\n      userState.claimed,\n      globalState.totalClaimed,\n      globalState.totalLoyalty,\n      globalState.totalLoyaltyIneligible\n    );\n  }\n\n  /// @notice Only callable by the factory contract admin\n  modifier onlyProjectAdmin() {\n    if (msg.sender != i_factory.getProjectConfig(address(i_token)).admin) {\n      revert IAccessControl.AccessControlUnauthorizedAccount(msg.sender, keccak256(\"PROJECT_ADMIN\"));\n    }\n    _;\n  }\n\n  /// @notice Only callable when claim contract is not paused\n  modifier whenClaimNotPaused() {\n    if (i_factory.isClaimContractPaused(address(i_token))) {\n      revert Pausable.EnforcedPause();\n    }\n    _;\n  }\n}", "modifiers": [], "stateMutability": "pure", "returnParameters": null, "visibility": "external", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol"}, {"type": "FunctionDefinition", "name": "BUILDClaim.deposit", "start_line": 85, "end_line": 102, "offset_start": 3292, "offset_end": 3993, "content": "function deposit(\n    uint256 amount\n  ) external override nonReentrant whenClaimNotPaused onlyProjectAdmin {\n    // only callable when factory contract is open\n    if (!i_factory.isOpen()) {\n      revert Closable.AlreadyClosed();\n    }\n\n    uint256 balanceBefore = i_token.balanceOf(address(this));\n    uint256 totalDeposited = i_factory.addTotalDeposited(address(i_token), amount);\n    i_token.safeTransferFrom(msg.sender, address(this), amount);\n    uint256 balanceAfter = i_token.balanceOf(address(this));\n    if (balanceBefore + amount != balanceAfter) {\n      revert InvalidDeposit(balanceBefore, balanceAfter);\n    }\n\n    emit Deposited(address(i_token), msg.sender, amount, totalDeposited);\n  }", "contract_name": "BUILDClaim", "contract_code": "{\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint256;\n\n  /// @notice The unlock state for a season at a given time\n  struct UnlockState {\n    uint256 unlockElapsedDuration; // The amount of time that has elapsed since\n      // the unlock delay started\n    bool isBeforeUnlock; // Whether the unlock period has started (including the delay)\n    bool isUnlocking; // Whether the unlock period is in progress\n  }\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDClaim 1.0.0\";\n\n  /// @notice The claimed and early claimed states for a user per season\n  mapping(address user => mapping(uint256 seasonId => UserState)) private s_userStates;\n\n  /// @notice The global states for a season\n  mapping(uint256 seasonId => GlobalState globalState) private s_globalStates;\n\n  /// @notice The project token\n  IERC20 private immutable i_token;\n\n  /// @notice The factory that deployed this contract\n  BUILDFactory private immutable i_factory;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @notice constructor\n  /// @param token The project token\n  constructor(\n    address token\n  ) {\n    i_token = IERC20(token);\n    i_factory = BUILDFactory(msg.sender);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getFactory() external view override returns (BUILDFactory) {\n    return i_factory;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getToken() external view override returns (IERC20) {\n    return i_token;\n  }\n\n  /// @inheritdoc IERC165\n  function supportsInterface(\n    bytes4 interfaceId\n  ) external pure override returns (bool) {\n    return interfaceId == type(IBUILDClaim).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  // ================================================================\n  // |                        Token Deposits                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function deposit(\n    uint256 amount\n  ) external override nonReentrant whenClaimNotPaused onlyProjectAdmin {\n    // only callable when factory contract is open\n    if (!i_factory.isOpen()) {\n      revert Closable.AlreadyClosed();\n    }\n\n    uint256 balanceBefore = i_token.balanceOf(address(this));\n    uint256 totalDeposited = i_factory.addTotalDeposited(address(i_token), amount);\n    i_token.safeTransferFrom(msg.sender, address(this), amount);\n    uint256 balanceAfter = i_token.balanceOf(address(this));\n    if (balanceBefore + amount != balanceAfter) {\n      revert InvalidDeposit(balanceBefore, balanceAfter);\n    }\n\n    emit Deposited(address(i_token), msg.sender, amount, totalDeposited);\n  }\n\n  // ================================================================\n  // |                       Token Withdrawals                      |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function withdraw() external override nonReentrant onlyProjectAdmin {\n    (IBUILDFactory.Withdrawal memory withdrawal, uint256 totalWithdrawn) =\n      i_factory.executeWithdraw(address(i_token));\n    i_token.safeTransfer(withdrawal.recipient, withdrawal.amount);\n    emit Withdrawn(address(i_token), withdrawal.recipient, withdrawal.amount, totalWithdrawn);\n  }\n\n  // ================================================================\n  // |                         Token Claims                         |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function claim(\n    address user,\n    ClaimParams[] calldata params\n  ) external override nonReentrant whenClaimNotPaused {\n    _claim(user, params);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getGlobalState(\n    uint256 seasonId\n  ) external view returns (GlobalState memory) {\n    return s_globalStates[seasonId];\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getUserState(\n    UserSeasonId[] calldata usersAndSeasonIds\n  ) external view returns (UserState[] memory) {\n    uint256 count = usersAndSeasonIds.length;\n    UserState[] memory states = new UserState[](count);\n    for (uint256 i; i < count; ++i) {\n      states[i] = s_userStates[usersAndSeasonIds[i].user][usersAndSeasonIds[i].seasonId];\n    }\n    return states;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getCurrentClaimValues(\n    address user,\n    uint256 seasonId,\n    uint256 maxTokenAmount\n  ) external view returns (ClaimableState memory) {\n    (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n      i_factory.getProjectSeasonConfig(address(i_token), seasonId);\n    UnlockState memory unlockState =\n      _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n    return _getClaimableState(\n      config, s_globalStates[seasonId], s_userStates[user][seasonId], unlockState, maxTokenAmount\n    );\n  }\n\n  /// @notice Validates if the user is eligible to claim the amount of tokens for a season\n  /// A merkle tree's leaf consists of a user address, their max token amount for the season and a\n  /// salt\n  /// @param root The merkle root of a season\n  /// @param user The user's address\n  /// @param proof The merkle proof of the user's address, max token amount and salt\n  /// @param maxTokenAmount The user's total claimable token amount for the season\n  /// @param isEarlyClaim Whether the user is claiming early\n  /// @param salt A randomly generated salt to prevent brute-force guessing of merkle proofs\n  /// @return bool Returns true if the user's proof, maxTokenAmount and salt are valid\n  function _verifyMerkleProof(\n    bytes32 root,\n    address user,\n    bytes32[] memory proof,\n    uint256 maxTokenAmount,\n    bool isEarlyClaim,\n    uint256 salt\n  ) private pure returns (bool) {\n    bytes32 leaf =\n      keccak256(bytes.concat(keccak256(abi.encode(user, maxTokenAmount, isEarlyClaim, salt))));\n    return MerkleProof.verify(proof, root, leaf);\n  }\n\n  /// @notice Calculates the amount of tokens that can be claimed by a user for a season\n  /// without requiring an early claim at a particular timestamp.\n  /// This amount is the sum of the base tokens amount that is released all at once after the\n  /// unlock delay and the unlocked amount that is released linearly over the unlock duration.\n  /// This does not factor in any claimed amounts\n  /// @param config The project season config\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param unlockState The unlock state for the season\n  /// @param maxTokenAmount The maximum token amount for the user\n  /// @return ClaimableState The amount of tokens that can be claimed\n  function _getClaimableState(\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    IBUILDClaim.GlobalState memory globalState,\n    UserState memory userState,\n    UnlockState memory unlockState,\n    uint256 maxTokenAmount\n  ) internal pure returns (ClaimableState memory) {\n    ClaimableState memory claimableState;\n    claimableState.base =\n      (maxTokenAmount * config.baseTokenClaimBps) / PERCENTAGE_BASIS_POINTS_DENOMINATOR;\n    claimableState.bonus = maxTokenAmount - claimableState.base;\n\n    if (config.tokenAmount == 0 || (config.isRefunding && userState.claimed == 0)) {\n      return claimableState;\n    }\n\n    claimableState.claimed = userState.claimed;\n\n    if (userState.hasEarlyClaimed || unlockState.isBeforeUnlock) return claimableState;\n    // calculate share of loyalty pool to receive\n    // The loyalty bonus is informative only in the unlock period, as it is not\n    // claimable until the vesting is completed.\n    claimableState.loyaltyBonus = maxTokenAmount * globalState.totalLoyalty\n      / (config.tokenAmount - globalState.totalLoyaltyIneligible);\n\n    if (unlockState.isUnlocking) {\n      // unlock period is in progress\n      claimableState.vested =\n        (claimableState.bonus * unlockState.unlockElapsedDuration) / config.unlockDuration;\n      claimableState.claimable =\n        claimableState.base + claimableState.vested - claimableState.claimed;\n      claimableState.earlyVestableBonus =\n        _calcEarlyVestableBonus(claimableState, config, unlockState.unlockElapsedDuration);\n    } else {\n      // unlock completed\n      claimableState.claimable =\n        maxTokenAmount + claimableState.loyaltyBonus - claimableState.claimed;\n    }\n\n    return claimableState;\n  }\n\n  /// @notice Calculates the amount of bonus tokens that can be claimed early\n  /// @param claimableState The claimable state for the user\n  /// @param config The project season config\n  /// @param timeElapsed The amount of time that has elapsed since the unlock delay started\n  /// @return uint256 The amount of bonus tokens that can be claimed early\n  function _calcEarlyVestableBonus(\n    ClaimableState memory claimableState,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 timeElapsed\n  ) private pure returns (uint256) {\n    return FixedPointMathLib.mulWadDown(\n      claimableState.bonus - claimableState.vested,\n      FixedPointMathLib.divWadDown(config.earlyVestRatioMinBps, PERCENTAGE_BASIS_POINTS_DENOMINATOR)\n        + (\n          FixedPointMathLib.divWadDown(\n            config.earlyVestRatioMaxBps - config.earlyVestRatioMinBps,\n            PERCENTAGE_BASIS_POINTS_DENOMINATOR\n          ) * timeElapsed\n        ) / config.unlockDuration\n    );\n  }\n\n  /// @notice Returns the unlock progress for a season\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockDelay The delay before the unlock period starts\n  /// @param unlockDuration The duration of the unlock period\n  /// @param targetTime The timestamp to evaluate the unlock progress at\n  /// @return UnlockState The unlock state for the target time\n  function _getUnlockState(\n    uint256 unlockStartsAt,\n    uint256 unlockDelay,\n    uint256 unlockDuration,\n    uint256 targetTime\n  ) internal pure returns (UnlockState memory) {\n    uint256 unlockDelayEndsAt = unlockStartsAt + unlockDelay;\n    if (targetTime < unlockDelayEndsAt) {\n      return UnlockState({isBeforeUnlock: true, isUnlocking: false, unlockElapsedDuration: 0});\n    }\n    return UnlockState({\n      isBeforeUnlock: false,\n      isUnlocking: targetTime < unlockDelayEndsAt + unlockDuration,\n      unlockElapsedDuration: targetTime - unlockDelayEndsAt\n    });\n  }\n\n  /// @notice Validates the claim parameters for a user\n  /// @param user The user address\n  /// @param userState The user state for the season\n  /// @param param The claim parameters for a user\n  /// @param config The project season config\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockState The unlock state for the season\n  /// @dev Reverts if the claim parameters are invalid\n  /// @dev Reverts if the unlock period has not started yet, including the configured unlock delay\n  /// @dev Reverts if the project season does not exist for the given token address\n  /// @dev Reverts if the user's proof is invalid\n  /// @dev Reverts if user attempts to earlyClaim after previously early claiming during the unlock\n  /// period\n  function _validateClaimParams(\n    address user,\n    UserState memory userState,\n    ClaimParams memory param,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 unlockStartsAt,\n    UnlockState memory unlockState\n  ) private view {\n    if (user == address(0)) {\n      revert InvalidUser(user);\n    }\n    if (unlockStartsAt == 0) {\n      revert IBUILDFactory.SeasonDoesNotExist(param.seasonId);\n    }\n    if (unlockState.isBeforeUnlock) {\n      revert UnlockNotStarted(param.seasonId);\n    }\n    if (config.tokenAmount == 0) {\n      revert IBUILDFactory.ProjectSeasonDoesNotExist(param.seasonId, address(i_token));\n    }\n    if (\n      !_verifyMerkleProof(\n        config.merkleRoot, user, param.proof, param.maxTokenAmount, param.isEarlyClaim, param.salt\n      )\n    ) {\n      revert InvalidMerkleProof();\n    }\n    if (unlockState.isUnlocking && param.isEarlyClaim && userState.hasEarlyClaimed) {\n      revert InvalidEarlyClaim(user, param.seasonId);\n    }\n    if (userState.claimed == 0 && config.isRefunding) {\n      // If the user hasn't claimed for this season before the refunding starts, the user will\n      // be refunded their allocated credits but can no longer claim tokens\n      revert IBUILDFactory.ProjectSeasonIsRefunding(address(i_token), param.seasonId);\n    }\n  }\n\n  /// @notice Util function that claims tokens for a user for multiple seasons\n  /// @param user The user address\n  /// @param params An array of claim params including the season ID, proof, and max token amount\n  /// for each season\n  function _claim(address user, ClaimParams[] memory params) private {\n    uint256 totalClaimableAmount;\n    bool isEarlyClaim = false;\n\n    // Cache array length outside loop\n    uint256 paramsLength = params.length;\n    for (uint256 i = 0; i < paramsLength; ++i) {\n      ClaimParams memory param = params[i];\n      if (param.isEarlyClaim) {\n        isEarlyClaim = true;\n      }\n      (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n        i_factory.getProjectSeasonConfig(address(i_token), param.seasonId);\n\n      UserState memory userState = s_userStates[user][param.seasonId];\n      UnlockState memory unlockState =\n        _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n\n      _validateClaimParams(user, userState, param, config, unlockStartsAt, unlockState);\n\n      if (userState.hasEarlyClaimed) {\n        continue;\n      }\n\n      GlobalState storage globalState = s_globalStates[param.seasonId];\n      ClaimableState memory claimableState =\n        _getClaimableState(config, globalState, userState, unlockState, param.maxTokenAmount);\n\n      // short-circuit on potential zero claim value before consuming refundable amount\n      // if regular claim, claimable must be > 0\n      // if early claim, earlyClaimable must be > 0\n      if (\n        (claimableState.claimable == 0 && !param.isEarlyClaim)\n          || (\n            claimableState.claimable == 0 && claimableState.earlyVestableBonus == 0\n              && param.isEarlyClaim\n          )\n      ) {\n        continue;\n      }\n\n      if (claimableState.claimed == 0) {\n        // User is claiming for the first time for this particular season, so the project can no\n        // longer reclaim the refundable amount for this user's credits\n        i_factory.reduceRefundableAmount(address(i_token), param.seasonId, param.maxTokenAmount);\n      }\n      uint256 toBeClaimed = claimableState.claimable;\n      if (unlockState.isUnlocking && param.isEarlyClaim) {\n        globalState.totalLoyalty +=\n          claimableState.bonus - claimableState.vested - claimableState.earlyVestableBonus;\n        globalState.totalLoyaltyIneligible += param.maxTokenAmount;\n        userState.hasEarlyClaimed = true;\n        toBeClaimed += claimableState.earlyVestableBonus;\n      }\n\n      totalClaimableAmount += toBeClaimed;\n      _updateClaimedAmounts(\n        user,\n        globalState,\n        userState,\n        param,\n        toBeClaimed,\n        param.isEarlyClaim ? claimableState.earlyVestableBonus : 0\n      );\n    }\n\n    if (isEarlyClaim && user != msg.sender) {\n      if (\n        !i_factory.getDelegateRegistry().checkDelegateForContract({\n          to: msg.sender,\n          from: user,\n          contract_: address(i_factory),\n          rights: bytes32(0)\n        })\n      ) {\n        revert InvalidSender(msg.sender);\n      }\n    }\n\n    if (totalClaimableAmount == 0) {\n      return;\n    }\n    i_token.safeTransfer(user, totalClaimableAmount);\n  }\n\n  /// @notice Updates the claimed amounts for a user and the season\n  /// @param user The user address\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param param The input parameters for the claim\n  /// @param toBeClaimed The amount of tokens to be claimed by the user\n  /// @param earlyVestableBonus The amount of bonus tokens that can be claimed early\n  /// @dev This function is called when a user claims tokens\n  function _updateClaimedAmounts(\n    address user,\n    GlobalState storage globalState,\n    UserState memory userState,\n    ClaimParams memory param,\n    uint256 toBeClaimed,\n    uint256 earlyVestableBonus\n  ) private {\n    userState.claimed += uint248(toBeClaimed);\n    s_userStates[user][param.seasonId] = userState;\n\n    globalState.totalClaimed += toBeClaimed;\n\n    emit Claimed(\n      user,\n      param.seasonId,\n      toBeClaimed,\n      param.isEarlyClaim,\n      earlyVestableBonus,\n      userState.claimed,\n      globalState.totalClaimed,\n      globalState.totalLoyalty,\n      globalState.totalLoyaltyIneligible\n    );\n  }\n\n  /// @notice Only callable by the factory contract admin\n  modifier onlyProjectAdmin() {\n    if (msg.sender != i_factory.getProjectConfig(address(i_token)).admin) {\n      revert IAccessControl.AccessControlUnauthorizedAccount(msg.sender, keccak256(\"PROJECT_ADMIN\"));\n    }\n    _;\n  }\n\n  /// @notice Only callable when claim contract is not paused\n  modifier whenClaimNotPaused() {\n    if (i_factory.isClaimContractPaused(address(i_token))) {\n      revert Pausable.EnforcedPause();\n    }\n    _;\n  }\n}", "modifiers": [null, null, null], "stateMutability": null, "returnParameters": [], "visibility": "external", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol"}, {"type": "FunctionDefinition", "name": "BUILDClaim.withdraw", "start_line": 109, "end_line": 114, "offset_start": 4239, "offset_end": 4599, "content": "function withdraw() external override nonReentrant onlyProjectAdmin {\n    (IBUILDFactory.Withdrawal memory withdrawal, uint256 totalWithdrawn) =\n      i_factory.executeWithdraw(address(i_token));\n    i_token.safeTransfer(withdrawal.recipient, withdrawal.amount);\n    emit Withdrawn(address(i_token), withdrawal.recipient, withdrawal.amount, totalWithdrawn);\n  }", "contract_name": "BUILDClaim", "contract_code": "{\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint256;\n\n  /// @notice The unlock state for a season at a given time\n  struct UnlockState {\n    uint256 unlockElapsedDuration; // The amount of time that has elapsed since\n      // the unlock delay started\n    bool isBeforeUnlock; // Whether the unlock period has started (including the delay)\n    bool isUnlocking; // Whether the unlock period is in progress\n  }\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDClaim 1.0.0\";\n\n  /// @notice The claimed and early claimed states for a user per season\n  mapping(address user => mapping(uint256 seasonId => UserState)) private s_userStates;\n\n  /// @notice The global states for a season\n  mapping(uint256 seasonId => GlobalState globalState) private s_globalStates;\n\n  /// @notice The project token\n  IERC20 private immutable i_token;\n\n  /// @notice The factory that deployed this contract\n  BUILDFactory private immutable i_factory;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @notice constructor\n  /// @param token The project token\n  constructor(\n    address token\n  ) {\n    i_token = IERC20(token);\n    i_factory = BUILDFactory(msg.sender);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getFactory() external view override returns (BUILDFactory) {\n    return i_factory;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getToken() external view override returns (IERC20) {\n    return i_token;\n  }\n\n  /// @inheritdoc IERC165\n  function supportsInterface(\n    bytes4 interfaceId\n  ) external pure override returns (bool) {\n    return interfaceId == type(IBUILDClaim).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  // ================================================================\n  // |                        Token Deposits                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function deposit(\n    uint256 amount\n  ) external override nonReentrant whenClaimNotPaused onlyProjectAdmin {\n    // only callable when factory contract is open\n    if (!i_factory.isOpen()) {\n      revert Closable.AlreadyClosed();\n    }\n\n    uint256 balanceBefore = i_token.balanceOf(address(this));\n    uint256 totalDeposited = i_factory.addTotalDeposited(address(i_token), amount);\n    i_token.safeTransferFrom(msg.sender, address(this), amount);\n    uint256 balanceAfter = i_token.balanceOf(address(this));\n    if (balanceBefore + amount != balanceAfter) {\n      revert InvalidDeposit(balanceBefore, balanceAfter);\n    }\n\n    emit Deposited(address(i_token), msg.sender, amount, totalDeposited);\n  }\n\n  // ================================================================\n  // |                       Token Withdrawals                      |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function withdraw() external override nonReentrant onlyProjectAdmin {\n    (IBUILDFactory.Withdrawal memory withdrawal, uint256 totalWithdrawn) =\n      i_factory.executeWithdraw(address(i_token));\n    i_token.safeTransfer(withdrawal.recipient, withdrawal.amount);\n    emit Withdrawn(address(i_token), withdrawal.recipient, withdrawal.amount, totalWithdrawn);\n  }\n\n  // ================================================================\n  // |                         Token Claims                         |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function claim(\n    address user,\n    ClaimParams[] calldata params\n  ) external override nonReentrant whenClaimNotPaused {\n    _claim(user, params);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getGlobalState(\n    uint256 seasonId\n  ) external view returns (GlobalState memory) {\n    return s_globalStates[seasonId];\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getUserState(\n    UserSeasonId[] calldata usersAndSeasonIds\n  ) external view returns (UserState[] memory) {\n    uint256 count = usersAndSeasonIds.length;\n    UserState[] memory states = new UserState[](count);\n    for (uint256 i; i < count; ++i) {\n      states[i] = s_userStates[usersAndSeasonIds[i].user][usersAndSeasonIds[i].seasonId];\n    }\n    return states;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getCurrentClaimValues(\n    address user,\n    uint256 seasonId,\n    uint256 maxTokenAmount\n  ) external view returns (ClaimableState memory) {\n    (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n      i_factory.getProjectSeasonConfig(address(i_token), seasonId);\n    UnlockState memory unlockState =\n      _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n    return _getClaimableState(\n      config, s_globalStates[seasonId], s_userStates[user][seasonId], unlockState, maxTokenAmount\n    );\n  }\n\n  /// @notice Validates if the user is eligible to claim the amount of tokens for a season\n  /// A merkle tree's leaf consists of a user address, their max token amount for the season and a\n  /// salt\n  /// @param root The merkle root of a season\n  /// @param user The user's address\n  /// @param proof The merkle proof of the user's address, max token amount and salt\n  /// @param maxTokenAmount The user's total claimable token amount for the season\n  /// @param isEarlyClaim Whether the user is claiming early\n  /// @param salt A randomly generated salt to prevent brute-force guessing of merkle proofs\n  /// @return bool Returns true if the user's proof, maxTokenAmount and salt are valid\n  function _verifyMerkleProof(\n    bytes32 root,\n    address user,\n    bytes32[] memory proof,\n    uint256 maxTokenAmount,\n    bool isEarlyClaim,\n    uint256 salt\n  ) private pure returns (bool) {\n    bytes32 leaf =\n      keccak256(bytes.concat(keccak256(abi.encode(user, maxTokenAmount, isEarlyClaim, salt))));\n    return MerkleProof.verify(proof, root, leaf);\n  }\n\n  /// @notice Calculates the amount of tokens that can be claimed by a user for a season\n  /// without requiring an early claim at a particular timestamp.\n  /// This amount is the sum of the base tokens amount that is released all at once after the\n  /// unlock delay and the unlocked amount that is released linearly over the unlock duration.\n  /// This does not factor in any claimed amounts\n  /// @param config The project season config\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param unlockState The unlock state for the season\n  /// @param maxTokenAmount The maximum token amount for the user\n  /// @return ClaimableState The amount of tokens that can be claimed\n  function _getClaimableState(\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    IBUILDClaim.GlobalState memory globalState,\n    UserState memory userState,\n    UnlockState memory unlockState,\n    uint256 maxTokenAmount\n  ) internal pure returns (ClaimableState memory) {\n    ClaimableState memory claimableState;\n    claimableState.base =\n      (maxTokenAmount * config.baseTokenClaimBps) / PERCENTAGE_BASIS_POINTS_DENOMINATOR;\n    claimableState.bonus = maxTokenAmount - claimableState.base;\n\n    if (config.tokenAmount == 0 || (config.isRefunding && userState.claimed == 0)) {\n      return claimableState;\n    }\n\n    claimableState.claimed = userState.claimed;\n\n    if (userState.hasEarlyClaimed || unlockState.isBeforeUnlock) return claimableState;\n    // calculate share of loyalty pool to receive\n    // The loyalty bonus is informative only in the unlock period, as it is not\n    // claimable until the vesting is completed.\n    claimableState.loyaltyBonus = maxTokenAmount * globalState.totalLoyalty\n      / (config.tokenAmount - globalState.totalLoyaltyIneligible);\n\n    if (unlockState.isUnlocking) {\n      // unlock period is in progress\n      claimableState.vested =\n        (claimableState.bonus * unlockState.unlockElapsedDuration) / config.unlockDuration;\n      claimableState.claimable =\n        claimableState.base + claimableState.vested - claimableState.claimed;\n      claimableState.earlyVestableBonus =\n        _calcEarlyVestableBonus(claimableState, config, unlockState.unlockElapsedDuration);\n    } else {\n      // unlock completed\n      claimableState.claimable =\n        maxTokenAmount + claimableState.loyaltyBonus - claimableState.claimed;\n    }\n\n    return claimableState;\n  }\n\n  /// @notice Calculates the amount of bonus tokens that can be claimed early\n  /// @param claimableState The claimable state for the user\n  /// @param config The project season config\n  /// @param timeElapsed The amount of time that has elapsed since the unlock delay started\n  /// @return uint256 The amount of bonus tokens that can be claimed early\n  function _calcEarlyVestableBonus(\n    ClaimableState memory claimableState,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 timeElapsed\n  ) private pure returns (uint256) {\n    return FixedPointMathLib.mulWadDown(\n      claimableState.bonus - claimableState.vested,\n      FixedPointMathLib.divWadDown(config.earlyVestRatioMinBps, PERCENTAGE_BASIS_POINTS_DENOMINATOR)\n        + (\n          FixedPointMathLib.divWadDown(\n            config.earlyVestRatioMaxBps - config.earlyVestRatioMinBps,\n            PERCENTAGE_BASIS_POINTS_DENOMINATOR\n          ) * timeElapsed\n        ) / config.unlockDuration\n    );\n  }\n\n  /// @notice Returns the unlock progress for a season\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockDelay The delay before the unlock period starts\n  /// @param unlockDuration The duration of the unlock period\n  /// @param targetTime The timestamp to evaluate the unlock progress at\n  /// @return UnlockState The unlock state for the target time\n  function _getUnlockState(\n    uint256 unlockStartsAt,\n    uint256 unlockDelay,\n    uint256 unlockDuration,\n    uint256 targetTime\n  ) internal pure returns (UnlockState memory) {\n    uint256 unlockDelayEndsAt = unlockStartsAt + unlockDelay;\n    if (targetTime < unlockDelayEndsAt) {\n      return UnlockState({isBeforeUnlock: true, isUnlocking: false, unlockElapsedDuration: 0});\n    }\n    return UnlockState({\n      isBeforeUnlock: false,\n      isUnlocking: targetTime < unlockDelayEndsAt + unlockDuration,\n      unlockElapsedDuration: targetTime - unlockDelayEndsAt\n    });\n  }\n\n  /// @notice Validates the claim parameters for a user\n  /// @param user The user address\n  /// @param userState The user state for the season\n  /// @param param The claim parameters for a user\n  /// @param config The project season config\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockState The unlock state for the season\n  /// @dev Reverts if the claim parameters are invalid\n  /// @dev Reverts if the unlock period has not started yet, including the configured unlock delay\n  /// @dev Reverts if the project season does not exist for the given token address\n  /// @dev Reverts if the user's proof is invalid\n  /// @dev Reverts if user attempts to earlyClaim after previously early claiming during the unlock\n  /// period\n  function _validateClaimParams(\n    address user,\n    UserState memory userState,\n    ClaimParams memory param,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 unlockStartsAt,\n    UnlockState memory unlockState\n  ) private view {\n    if (user == address(0)) {\n      revert InvalidUser(user);\n    }\n    if (unlockStartsAt == 0) {\n      revert IBUILDFactory.SeasonDoesNotExist(param.seasonId);\n    }\n    if (unlockState.isBeforeUnlock) {\n      revert UnlockNotStarted(param.seasonId);\n    }\n    if (config.tokenAmount == 0) {\n      revert IBUILDFactory.ProjectSeasonDoesNotExist(param.seasonId, address(i_token));\n    }\n    if (\n      !_verifyMerkleProof(\n        config.merkleRoot, user, param.proof, param.maxTokenAmount, param.isEarlyClaim, param.salt\n      )\n    ) {\n      revert InvalidMerkleProof();\n    }\n    if (unlockState.isUnlocking && param.isEarlyClaim && userState.hasEarlyClaimed) {\n      revert InvalidEarlyClaim(user, param.seasonId);\n    }\n    if (userState.claimed == 0 && config.isRefunding) {\n      // If the user hasn't claimed for this season before the refunding starts, the user will\n      // be refunded their allocated credits but can no longer claim tokens\n      revert IBUILDFactory.ProjectSeasonIsRefunding(address(i_token), param.seasonId);\n    }\n  }\n\n  /// @notice Util function that claims tokens for a user for multiple seasons\n  /// @param user The user address\n  /// @param params An array of claim params including the season ID, proof, and max token amount\n  /// for each season\n  function _claim(address user, ClaimParams[] memory params) private {\n    uint256 totalClaimableAmount;\n    bool isEarlyClaim = false;\n\n    // Cache array length outside loop\n    uint256 paramsLength = params.length;\n    for (uint256 i = 0; i < paramsLength; ++i) {\n      ClaimParams memory param = params[i];\n      if (param.isEarlyClaim) {\n        isEarlyClaim = true;\n      }\n      (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n        i_factory.getProjectSeasonConfig(address(i_token), param.seasonId);\n\n      UserState memory userState = s_userStates[user][param.seasonId];\n      UnlockState memory unlockState =\n        _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n\n      _validateClaimParams(user, userState, param, config, unlockStartsAt, unlockState);\n\n      if (userState.hasEarlyClaimed) {\n        continue;\n      }\n\n      GlobalState storage globalState = s_globalStates[param.seasonId];\n      ClaimableState memory claimableState =\n        _getClaimableState(config, globalState, userState, unlockState, param.maxTokenAmount);\n\n      // short-circuit on potential zero claim value before consuming refundable amount\n      // if regular claim, claimable must be > 0\n      // if early claim, earlyClaimable must be > 0\n      if (\n        (claimableState.claimable == 0 && !param.isEarlyClaim)\n          || (\n            claimableState.claimable == 0 && claimableState.earlyVestableBonus == 0\n              && param.isEarlyClaim\n          )\n      ) {\n        continue;\n      }\n\n      if (claimableState.claimed == 0) {\n        // User is claiming for the first time for this particular season, so the project can no\n        // longer reclaim the refundable amount for this user's credits\n        i_factory.reduceRefundableAmount(address(i_token), param.seasonId, param.maxTokenAmount);\n      }\n      uint256 toBeClaimed = claimableState.claimable;\n      if (unlockState.isUnlocking && param.isEarlyClaim) {\n        globalState.totalLoyalty +=\n          claimableState.bonus - claimableState.vested - claimableState.earlyVestableBonus;\n        globalState.totalLoyaltyIneligible += param.maxTokenAmount;\n        userState.hasEarlyClaimed = true;\n        toBeClaimed += claimableState.earlyVestableBonus;\n      }\n\n      totalClaimableAmount += toBeClaimed;\n      _updateClaimedAmounts(\n        user,\n        globalState,\n        userState,\n        param,\n        toBeClaimed,\n        param.isEarlyClaim ? claimableState.earlyVestableBonus : 0\n      );\n    }\n\n    if (isEarlyClaim && user != msg.sender) {\n      if (\n        !i_factory.getDelegateRegistry().checkDelegateForContract({\n          to: msg.sender,\n          from: user,\n          contract_: address(i_factory),\n          rights: bytes32(0)\n        })\n      ) {\n        revert InvalidSender(msg.sender);\n      }\n    }\n\n    if (totalClaimableAmount == 0) {\n      return;\n    }\n    i_token.safeTransfer(user, totalClaimableAmount);\n  }\n\n  /// @notice Updates the claimed amounts for a user and the season\n  /// @param user The user address\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param param The input parameters for the claim\n  /// @param toBeClaimed The amount of tokens to be claimed by the user\n  /// @param earlyVestableBonus The amount of bonus tokens that can be claimed early\n  /// @dev This function is called when a user claims tokens\n  function _updateClaimedAmounts(\n    address user,\n    GlobalState storage globalState,\n    UserState memory userState,\n    ClaimParams memory param,\n    uint256 toBeClaimed,\n    uint256 earlyVestableBonus\n  ) private {\n    userState.claimed += uint248(toBeClaimed);\n    s_userStates[user][param.seasonId] = userState;\n\n    globalState.totalClaimed += toBeClaimed;\n\n    emit Claimed(\n      user,\n      param.seasonId,\n      toBeClaimed,\n      param.isEarlyClaim,\n      earlyVestableBonus,\n      userState.claimed,\n      globalState.totalClaimed,\n      globalState.totalLoyalty,\n      globalState.totalLoyaltyIneligible\n    );\n  }\n\n  /// @notice Only callable by the factory contract admin\n  modifier onlyProjectAdmin() {\n    if (msg.sender != i_factory.getProjectConfig(address(i_token)).admin) {\n      revert IAccessControl.AccessControlUnauthorizedAccount(msg.sender, keccak256(\"PROJECT_ADMIN\"));\n    }\n    _;\n  }\n\n  /// @notice Only callable when claim contract is not paused\n  modifier whenClaimNotPaused() {\n    if (i_factory.isClaimContractPaused(address(i_token))) {\n      revert Pausable.EnforcedPause();\n    }\n    _;\n  }\n}", "modifiers": [null, null], "stateMutability": null, "returnParameters": [], "visibility": "external", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol"}, {"type": "FunctionDefinition", "name": "BUILDClaim.claim", "start_line": 121, "end_line": 126, "offset_start": 4845, "offset_end": 4997, "content": "function claim(\n    address user,\n    ClaimParams[] calldata params\n  ) external override nonReentrant whenClaimNotPaused {\n    _claim(user, params);\n  }", "contract_name": "BUILDClaim", "contract_code": "{\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint256;\n\n  /// @notice The unlock state for a season at a given time\n  struct UnlockState {\n    uint256 unlockElapsedDuration; // The amount of time that has elapsed since\n      // the unlock delay started\n    bool isBeforeUnlock; // Whether the unlock period has started (including the delay)\n    bool isUnlocking; // Whether the unlock period is in progress\n  }\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDClaim 1.0.0\";\n\n  /// @notice The claimed and early claimed states for a user per season\n  mapping(address user => mapping(uint256 seasonId => UserState)) private s_userStates;\n\n  /// @notice The global states for a season\n  mapping(uint256 seasonId => GlobalState globalState) private s_globalStates;\n\n  /// @notice The project token\n  IERC20 private immutable i_token;\n\n  /// @notice The factory that deployed this contract\n  BUILDFactory private immutable i_factory;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @notice constructor\n  /// @param token The project token\n  constructor(\n    address token\n  ) {\n    i_token = IERC20(token);\n    i_factory = BUILDFactory(msg.sender);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getFactory() external view override returns (BUILDFactory) {\n    return i_factory;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getToken() external view override returns (IERC20) {\n    return i_token;\n  }\n\n  /// @inheritdoc IERC165\n  function supportsInterface(\n    bytes4 interfaceId\n  ) external pure override returns (bool) {\n    return interfaceId == type(IBUILDClaim).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  // ================================================================\n  // |                        Token Deposits                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function deposit(\n    uint256 amount\n  ) external override nonReentrant whenClaimNotPaused onlyProjectAdmin {\n    // only callable when factory contract is open\n    if (!i_factory.isOpen()) {\n      revert Closable.AlreadyClosed();\n    }\n\n    uint256 balanceBefore = i_token.balanceOf(address(this));\n    uint256 totalDeposited = i_factory.addTotalDeposited(address(i_token), amount);\n    i_token.safeTransferFrom(msg.sender, address(this), amount);\n    uint256 balanceAfter = i_token.balanceOf(address(this));\n    if (balanceBefore + amount != balanceAfter) {\n      revert InvalidDeposit(balanceBefore, balanceAfter);\n    }\n\n    emit Deposited(address(i_token), msg.sender, amount, totalDeposited);\n  }\n\n  // ================================================================\n  // |                       Token Withdrawals                      |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function withdraw() external override nonReentrant onlyProjectAdmin {\n    (IBUILDFactory.Withdrawal memory withdrawal, uint256 totalWithdrawn) =\n      i_factory.executeWithdraw(address(i_token));\n    i_token.safeTransfer(withdrawal.recipient, withdrawal.amount);\n    emit Withdrawn(address(i_token), withdrawal.recipient, withdrawal.amount, totalWithdrawn);\n  }\n\n  // ================================================================\n  // |                         Token Claims                         |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function claim(\n    address user,\n    ClaimParams[] calldata params\n  ) external override nonReentrant whenClaimNotPaused {\n    _claim(user, params);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getGlobalState(\n    uint256 seasonId\n  ) external view returns (GlobalState memory) {\n    return s_globalStates[seasonId];\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getUserState(\n    UserSeasonId[] calldata usersAndSeasonIds\n  ) external view returns (UserState[] memory) {\n    uint256 count = usersAndSeasonIds.length;\n    UserState[] memory states = new UserState[](count);\n    for (uint256 i; i < count; ++i) {\n      states[i] = s_userStates[usersAndSeasonIds[i].user][usersAndSeasonIds[i].seasonId];\n    }\n    return states;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getCurrentClaimValues(\n    address user,\n    uint256 seasonId,\n    uint256 maxTokenAmount\n  ) external view returns (ClaimableState memory) {\n    (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n      i_factory.getProjectSeasonConfig(address(i_token), seasonId);\n    UnlockState memory unlockState =\n      _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n    return _getClaimableState(\n      config, s_globalStates[seasonId], s_userStates[user][seasonId], unlockState, maxTokenAmount\n    );\n  }\n\n  /// @notice Validates if the user is eligible to claim the amount of tokens for a season\n  /// A merkle tree's leaf consists of a user address, their max token amount for the season and a\n  /// salt\n  /// @param root The merkle root of a season\n  /// @param user The user's address\n  /// @param proof The merkle proof of the user's address, max token amount and salt\n  /// @param maxTokenAmount The user's total claimable token amount for the season\n  /// @param isEarlyClaim Whether the user is claiming early\n  /// @param salt A randomly generated salt to prevent brute-force guessing of merkle proofs\n  /// @return bool Returns true if the user's proof, maxTokenAmount and salt are valid\n  function _verifyMerkleProof(\n    bytes32 root,\n    address user,\n    bytes32[] memory proof,\n    uint256 maxTokenAmount,\n    bool isEarlyClaim,\n    uint256 salt\n  ) private pure returns (bool) {\n    bytes32 leaf =\n      keccak256(bytes.concat(keccak256(abi.encode(user, maxTokenAmount, isEarlyClaim, salt))));\n    return MerkleProof.verify(proof, root, leaf);\n  }\n\n  /// @notice Calculates the amount of tokens that can be claimed by a user for a season\n  /// without requiring an early claim at a particular timestamp.\n  /// This amount is the sum of the base tokens amount that is released all at once after the\n  /// unlock delay and the unlocked amount that is released linearly over the unlock duration.\n  /// This does not factor in any claimed amounts\n  /// @param config The project season config\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param unlockState The unlock state for the season\n  /// @param maxTokenAmount The maximum token amount for the user\n  /// @return ClaimableState The amount of tokens that can be claimed\n  function _getClaimableState(\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    IBUILDClaim.GlobalState memory globalState,\n    UserState memory userState,\n    UnlockState memory unlockState,\n    uint256 maxTokenAmount\n  ) internal pure returns (ClaimableState memory) {\n    ClaimableState memory claimableState;\n    claimableState.base =\n      (maxTokenAmount * config.baseTokenClaimBps) / PERCENTAGE_BASIS_POINTS_DENOMINATOR;\n    claimableState.bonus = maxTokenAmount - claimableState.base;\n\n    if (config.tokenAmount == 0 || (config.isRefunding && userState.claimed == 0)) {\n      return claimableState;\n    }\n\n    claimableState.claimed = userState.claimed;\n\n    if (userState.hasEarlyClaimed || unlockState.isBeforeUnlock) return claimableState;\n    // calculate share of loyalty pool to receive\n    // The loyalty bonus is informative only in the unlock period, as it is not\n    // claimable until the vesting is completed.\n    claimableState.loyaltyBonus = maxTokenAmount * globalState.totalLoyalty\n      / (config.tokenAmount - globalState.totalLoyaltyIneligible);\n\n    if (unlockState.isUnlocking) {\n      // unlock period is in progress\n      claimableState.vested =\n        (claimableState.bonus * unlockState.unlockElapsedDuration) / config.unlockDuration;\n      claimableState.claimable =\n        claimableState.base + claimableState.vested - claimableState.claimed;\n      claimableState.earlyVestableBonus =\n        _calcEarlyVestableBonus(claimableState, config, unlockState.unlockElapsedDuration);\n    } else {\n      // unlock completed\n      claimableState.claimable =\n        maxTokenAmount + claimableState.loyaltyBonus - claimableState.claimed;\n    }\n\n    return claimableState;\n  }\n\n  /// @notice Calculates the amount of bonus tokens that can be claimed early\n  /// @param claimableState The claimable state for the user\n  /// @param config The project season config\n  /// @param timeElapsed The amount of time that has elapsed since the unlock delay started\n  /// @return uint256 The amount of bonus tokens that can be claimed early\n  function _calcEarlyVestableBonus(\n    ClaimableState memory claimableState,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 timeElapsed\n  ) private pure returns (uint256) {\n    return FixedPointMathLib.mulWadDown(\n      claimableState.bonus - claimableState.vested,\n      FixedPointMathLib.divWadDown(config.earlyVestRatioMinBps, PERCENTAGE_BASIS_POINTS_DENOMINATOR)\n        + (\n          FixedPointMathLib.divWadDown(\n            config.earlyVestRatioMaxBps - config.earlyVestRatioMinBps,\n            PERCENTAGE_BASIS_POINTS_DENOMINATOR\n          ) * timeElapsed\n        ) / config.unlockDuration\n    );\n  }\n\n  /// @notice Returns the unlock progress for a season\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockDelay The delay before the unlock period starts\n  /// @param unlockDuration The duration of the unlock period\n  /// @param targetTime The timestamp to evaluate the unlock progress at\n  /// @return UnlockState The unlock state for the target time\n  function _getUnlockState(\n    uint256 unlockStartsAt,\n    uint256 unlockDelay,\n    uint256 unlockDuration,\n    uint256 targetTime\n  ) internal pure returns (UnlockState memory) {\n    uint256 unlockDelayEndsAt = unlockStartsAt + unlockDelay;\n    if (targetTime < unlockDelayEndsAt) {\n      return UnlockState({isBeforeUnlock: true, isUnlocking: false, unlockElapsedDuration: 0});\n    }\n    return UnlockState({\n      isBeforeUnlock: false,\n      isUnlocking: targetTime < unlockDelayEndsAt + unlockDuration,\n      unlockElapsedDuration: targetTime - unlockDelayEndsAt\n    });\n  }\n\n  /// @notice Validates the claim parameters for a user\n  /// @param user The user address\n  /// @param userState The user state for the season\n  /// @param param The claim parameters for a user\n  /// @param config The project season config\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockState The unlock state for the season\n  /// @dev Reverts if the claim parameters are invalid\n  /// @dev Reverts if the unlock period has not started yet, including the configured unlock delay\n  /// @dev Reverts if the project season does not exist for the given token address\n  /// @dev Reverts if the user's proof is invalid\n  /// @dev Reverts if user attempts to earlyClaim after previously early claiming during the unlock\n  /// period\n  function _validateClaimParams(\n    address user,\n    UserState memory userState,\n    ClaimParams memory param,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 unlockStartsAt,\n    UnlockState memory unlockState\n  ) private view {\n    if (user == address(0)) {\n      revert InvalidUser(user);\n    }\n    if (unlockStartsAt == 0) {\n      revert IBUILDFactory.SeasonDoesNotExist(param.seasonId);\n    }\n    if (unlockState.isBeforeUnlock) {\n      revert UnlockNotStarted(param.seasonId);\n    }\n    if (config.tokenAmount == 0) {\n      revert IBUILDFactory.ProjectSeasonDoesNotExist(param.seasonId, address(i_token));\n    }\n    if (\n      !_verifyMerkleProof(\n        config.merkleRoot, user, param.proof, param.maxTokenAmount, param.isEarlyClaim, param.salt\n      )\n    ) {\n      revert InvalidMerkleProof();\n    }\n    if (unlockState.isUnlocking && param.isEarlyClaim && userState.hasEarlyClaimed) {\n      revert InvalidEarlyClaim(user, param.seasonId);\n    }\n    if (userState.claimed == 0 && config.isRefunding) {\n      // If the user hasn't claimed for this season before the refunding starts, the user will\n      // be refunded their allocated credits but can no longer claim tokens\n      revert IBUILDFactory.ProjectSeasonIsRefunding(address(i_token), param.seasonId);\n    }\n  }\n\n  /// @notice Util function that claims tokens for a user for multiple seasons\n  /// @param user The user address\n  /// @param params An array of claim params including the season ID, proof, and max token amount\n  /// for each season\n  function _claim(address user, ClaimParams[] memory params) private {\n    uint256 totalClaimableAmount;\n    bool isEarlyClaim = false;\n\n    // Cache array length outside loop\n    uint256 paramsLength = params.length;\n    for (uint256 i = 0; i < paramsLength; ++i) {\n      ClaimParams memory param = params[i];\n      if (param.isEarlyClaim) {\n        isEarlyClaim = true;\n      }\n      (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n        i_factory.getProjectSeasonConfig(address(i_token), param.seasonId);\n\n      UserState memory userState = s_userStates[user][param.seasonId];\n      UnlockState memory unlockState =\n        _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n\n      _validateClaimParams(user, userState, param, config, unlockStartsAt, unlockState);\n\n      if (userState.hasEarlyClaimed) {\n        continue;\n      }\n\n      GlobalState storage globalState = s_globalStates[param.seasonId];\n      ClaimableState memory claimableState =\n        _getClaimableState(config, globalState, userState, unlockState, param.maxTokenAmount);\n\n      // short-circuit on potential zero claim value before consuming refundable amount\n      // if regular claim, claimable must be > 0\n      // if early claim, earlyClaimable must be > 0\n      if (\n        (claimableState.claimable == 0 && !param.isEarlyClaim)\n          || (\n            claimableState.claimable == 0 && claimableState.earlyVestableBonus == 0\n              && param.isEarlyClaim\n          )\n      ) {\n        continue;\n      }\n\n      if (claimableState.claimed == 0) {\n        // User is claiming for the first time for this particular season, so the project can no\n        // longer reclaim the refundable amount for this user's credits\n        i_factory.reduceRefundableAmount(address(i_token), param.seasonId, param.maxTokenAmount);\n      }\n      uint256 toBeClaimed = claimableState.claimable;\n      if (unlockState.isUnlocking && param.isEarlyClaim) {\n        globalState.totalLoyalty +=\n          claimableState.bonus - claimableState.vested - claimableState.earlyVestableBonus;\n        globalState.totalLoyaltyIneligible += param.maxTokenAmount;\n        userState.hasEarlyClaimed = true;\n        toBeClaimed += claimableState.earlyVestableBonus;\n      }\n\n      totalClaimableAmount += toBeClaimed;\n      _updateClaimedAmounts(\n        user,\n        globalState,\n        userState,\n        param,\n        toBeClaimed,\n        param.isEarlyClaim ? claimableState.earlyVestableBonus : 0\n      );\n    }\n\n    if (isEarlyClaim && user != msg.sender) {\n      if (\n        !i_factory.getDelegateRegistry().checkDelegateForContract({\n          to: msg.sender,\n          from: user,\n          contract_: address(i_factory),\n          rights: bytes32(0)\n        })\n      ) {\n        revert InvalidSender(msg.sender);\n      }\n    }\n\n    if (totalClaimableAmount == 0) {\n      return;\n    }\n    i_token.safeTransfer(user, totalClaimableAmount);\n  }\n\n  /// @notice Updates the claimed amounts for a user and the season\n  /// @param user The user address\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param param The input parameters for the claim\n  /// @param toBeClaimed The amount of tokens to be claimed by the user\n  /// @param earlyVestableBonus The amount of bonus tokens that can be claimed early\n  /// @dev This function is called when a user claims tokens\n  function _updateClaimedAmounts(\n    address user,\n    GlobalState storage globalState,\n    UserState memory userState,\n    ClaimParams memory param,\n    uint256 toBeClaimed,\n    uint256 earlyVestableBonus\n  ) private {\n    userState.claimed += uint248(toBeClaimed);\n    s_userStates[user][param.seasonId] = userState;\n\n    globalState.totalClaimed += toBeClaimed;\n\n    emit Claimed(\n      user,\n      param.seasonId,\n      toBeClaimed,\n      param.isEarlyClaim,\n      earlyVestableBonus,\n      userState.claimed,\n      globalState.totalClaimed,\n      globalState.totalLoyalty,\n      globalState.totalLoyaltyIneligible\n    );\n  }\n\n  /// @notice Only callable by the factory contract admin\n  modifier onlyProjectAdmin() {\n    if (msg.sender != i_factory.getProjectConfig(address(i_token)).admin) {\n      revert IAccessControl.AccessControlUnauthorizedAccount(msg.sender, keccak256(\"PROJECT_ADMIN\"));\n    }\n    _;\n  }\n\n  /// @notice Only callable when claim contract is not paused\n  modifier whenClaimNotPaused() {\n    if (i_factory.isClaimContractPaused(address(i_token))) {\n      revert Pausable.EnforcedPause();\n    }\n    _;\n  }\n}", "modifiers": [null, null], "stateMutability": null, "returnParameters": [], "visibility": "external", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol"}, {"type": "FunctionDefinition", "name": "BUILDClaim.getGlobalState", "start_line": 129, "end_line": 133, "offset_start": 5032, "offset_end": 5166, "content": "function getGlobalState(\n    uint256 seasonId\n  ) external view returns (GlobalState memory) {\n    return s_globalStates[seasonId];\n  }", "contract_name": "BUILDClaim", "contract_code": "{\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint256;\n\n  /// @notice The unlock state for a season at a given time\n  struct UnlockState {\n    uint256 unlockElapsedDuration; // The amount of time that has elapsed since\n      // the unlock delay started\n    bool isBeforeUnlock; // Whether the unlock period has started (including the delay)\n    bool isUnlocking; // Whether the unlock period is in progress\n  }\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDClaim 1.0.0\";\n\n  /// @notice The claimed and early claimed states for a user per season\n  mapping(address user => mapping(uint256 seasonId => UserState)) private s_userStates;\n\n  /// @notice The global states for a season\n  mapping(uint256 seasonId => GlobalState globalState) private s_globalStates;\n\n  /// @notice The project token\n  IERC20 private immutable i_token;\n\n  /// @notice The factory that deployed this contract\n  BUILDFactory private immutable i_factory;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @notice constructor\n  /// @param token The project token\n  constructor(\n    address token\n  ) {\n    i_token = IERC20(token);\n    i_factory = BUILDFactory(msg.sender);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getFactory() external view override returns (BUILDFactory) {\n    return i_factory;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getToken() external view override returns (IERC20) {\n    return i_token;\n  }\n\n  /// @inheritdoc IERC165\n  function supportsInterface(\n    bytes4 interfaceId\n  ) external pure override returns (bool) {\n    return interfaceId == type(IBUILDClaim).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  // ================================================================\n  // |                        Token Deposits                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function deposit(\n    uint256 amount\n  ) external override nonReentrant whenClaimNotPaused onlyProjectAdmin {\n    // only callable when factory contract is open\n    if (!i_factory.isOpen()) {\n      revert Closable.AlreadyClosed();\n    }\n\n    uint256 balanceBefore = i_token.balanceOf(address(this));\n    uint256 totalDeposited = i_factory.addTotalDeposited(address(i_token), amount);\n    i_token.safeTransferFrom(msg.sender, address(this), amount);\n    uint256 balanceAfter = i_token.balanceOf(address(this));\n    if (balanceBefore + amount != balanceAfter) {\n      revert InvalidDeposit(balanceBefore, balanceAfter);\n    }\n\n    emit Deposited(address(i_token), msg.sender, amount, totalDeposited);\n  }\n\n  // ================================================================\n  // |                       Token Withdrawals                      |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function withdraw() external override nonReentrant onlyProjectAdmin {\n    (IBUILDFactory.Withdrawal memory withdrawal, uint256 totalWithdrawn) =\n      i_factory.executeWithdraw(address(i_token));\n    i_token.safeTransfer(withdrawal.recipient, withdrawal.amount);\n    emit Withdrawn(address(i_token), withdrawal.recipient, withdrawal.amount, totalWithdrawn);\n  }\n\n  // ================================================================\n  // |                         Token Claims                         |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function claim(\n    address user,\n    ClaimParams[] calldata params\n  ) external override nonReentrant whenClaimNotPaused {\n    _claim(user, params);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getGlobalState(\n    uint256 seasonId\n  ) external view returns (GlobalState memory) {\n    return s_globalStates[seasonId];\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getUserState(\n    UserSeasonId[] calldata usersAndSeasonIds\n  ) external view returns (UserState[] memory) {\n    uint256 count = usersAndSeasonIds.length;\n    UserState[] memory states = new UserState[](count);\n    for (uint256 i; i < count; ++i) {\n      states[i] = s_userStates[usersAndSeasonIds[i].user][usersAndSeasonIds[i].seasonId];\n    }\n    return states;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getCurrentClaimValues(\n    address user,\n    uint256 seasonId,\n    uint256 maxTokenAmount\n  ) external view returns (ClaimableState memory) {\n    (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n      i_factory.getProjectSeasonConfig(address(i_token), seasonId);\n    UnlockState memory unlockState =\n      _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n    return _getClaimableState(\n      config, s_globalStates[seasonId], s_userStates[user][seasonId], unlockState, maxTokenAmount\n    );\n  }\n\n  /// @notice Validates if the user is eligible to claim the amount of tokens for a season\n  /// A merkle tree's leaf consists of a user address, their max token amount for the season and a\n  /// salt\n  /// @param root The merkle root of a season\n  /// @param user The user's address\n  /// @param proof The merkle proof of the user's address, max token amount and salt\n  /// @param maxTokenAmount The user's total claimable token amount for the season\n  /// @param isEarlyClaim Whether the user is claiming early\n  /// @param salt A randomly generated salt to prevent brute-force guessing of merkle proofs\n  /// @return bool Returns true if the user's proof, maxTokenAmount and salt are valid\n  function _verifyMerkleProof(\n    bytes32 root,\n    address user,\n    bytes32[] memory proof,\n    uint256 maxTokenAmount,\n    bool isEarlyClaim,\n    uint256 salt\n  ) private pure returns (bool) {\n    bytes32 leaf =\n      keccak256(bytes.concat(keccak256(abi.encode(user, maxTokenAmount, isEarlyClaim, salt))));\n    return MerkleProof.verify(proof, root, leaf);\n  }\n\n  /// @notice Calculates the amount of tokens that can be claimed by a user for a season\n  /// without requiring an early claim at a particular timestamp.\n  /// This amount is the sum of the base tokens amount that is released all at once after the\n  /// unlock delay and the unlocked amount that is released linearly over the unlock duration.\n  /// This does not factor in any claimed amounts\n  /// @param config The project season config\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param unlockState The unlock state for the season\n  /// @param maxTokenAmount The maximum token amount for the user\n  /// @return ClaimableState The amount of tokens that can be claimed\n  function _getClaimableState(\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    IBUILDClaim.GlobalState memory globalState,\n    UserState memory userState,\n    UnlockState memory unlockState,\n    uint256 maxTokenAmount\n  ) internal pure returns (ClaimableState memory) {\n    ClaimableState memory claimableState;\n    claimableState.base =\n      (maxTokenAmount * config.baseTokenClaimBps) / PERCENTAGE_BASIS_POINTS_DENOMINATOR;\n    claimableState.bonus = maxTokenAmount - claimableState.base;\n\n    if (config.tokenAmount == 0 || (config.isRefunding && userState.claimed == 0)) {\n      return claimableState;\n    }\n\n    claimableState.claimed = userState.claimed;\n\n    if (userState.hasEarlyClaimed || unlockState.isBeforeUnlock) return claimableState;\n    // calculate share of loyalty pool to receive\n    // The loyalty bonus is informative only in the unlock period, as it is not\n    // claimable until the vesting is completed.\n    claimableState.loyaltyBonus = maxTokenAmount * globalState.totalLoyalty\n      / (config.tokenAmount - globalState.totalLoyaltyIneligible);\n\n    if (unlockState.isUnlocking) {\n      // unlock period is in progress\n      claimableState.vested =\n        (claimableState.bonus * unlockState.unlockElapsedDuration) / config.unlockDuration;\n      claimableState.claimable =\n        claimableState.base + claimableState.vested - claimableState.claimed;\n      claimableState.earlyVestableBonus =\n        _calcEarlyVestableBonus(claimableState, config, unlockState.unlockElapsedDuration);\n    } else {\n      // unlock completed\n      claimableState.claimable =\n        maxTokenAmount + claimableState.loyaltyBonus - claimableState.claimed;\n    }\n\n    return claimableState;\n  }\n\n  /// @notice Calculates the amount of bonus tokens that can be claimed early\n  /// @param claimableState The claimable state for the user\n  /// @param config The project season config\n  /// @param timeElapsed The amount of time that has elapsed since the unlock delay started\n  /// @return uint256 The amount of bonus tokens that can be claimed early\n  function _calcEarlyVestableBonus(\n    ClaimableState memory claimableState,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 timeElapsed\n  ) private pure returns (uint256) {\n    return FixedPointMathLib.mulWadDown(\n      claimableState.bonus - claimableState.vested,\n      FixedPointMathLib.divWadDown(config.earlyVestRatioMinBps, PERCENTAGE_BASIS_POINTS_DENOMINATOR)\n        + (\n          FixedPointMathLib.divWadDown(\n            config.earlyVestRatioMaxBps - config.earlyVestRatioMinBps,\n            PERCENTAGE_BASIS_POINTS_DENOMINATOR\n          ) * timeElapsed\n        ) / config.unlockDuration\n    );\n  }\n\n  /// @notice Returns the unlock progress for a season\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockDelay The delay before the unlock period starts\n  /// @param unlockDuration The duration of the unlock period\n  /// @param targetTime The timestamp to evaluate the unlock progress at\n  /// @return UnlockState The unlock state for the target time\n  function _getUnlockState(\n    uint256 unlockStartsAt,\n    uint256 unlockDelay,\n    uint256 unlockDuration,\n    uint256 targetTime\n  ) internal pure returns (UnlockState memory) {\n    uint256 unlockDelayEndsAt = unlockStartsAt + unlockDelay;\n    if (targetTime < unlockDelayEndsAt) {\n      return UnlockState({isBeforeUnlock: true, isUnlocking: false, unlockElapsedDuration: 0});\n    }\n    return UnlockState({\n      isBeforeUnlock: false,\n      isUnlocking: targetTime < unlockDelayEndsAt + unlockDuration,\n      unlockElapsedDuration: targetTime - unlockDelayEndsAt\n    });\n  }\n\n  /// @notice Validates the claim parameters for a user\n  /// @param user The user address\n  /// @param userState The user state for the season\n  /// @param param The claim parameters for a user\n  /// @param config The project season config\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockState The unlock state for the season\n  /// @dev Reverts if the claim parameters are invalid\n  /// @dev Reverts if the unlock period has not started yet, including the configured unlock delay\n  /// @dev Reverts if the project season does not exist for the given token address\n  /// @dev Reverts if the user's proof is invalid\n  /// @dev Reverts if user attempts to earlyClaim after previously early claiming during the unlock\n  /// period\n  function _validateClaimParams(\n    address user,\n    UserState memory userState,\n    ClaimParams memory param,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 unlockStartsAt,\n    UnlockState memory unlockState\n  ) private view {\n    if (user == address(0)) {\n      revert InvalidUser(user);\n    }\n    if (unlockStartsAt == 0) {\n      revert IBUILDFactory.SeasonDoesNotExist(param.seasonId);\n    }\n    if (unlockState.isBeforeUnlock) {\n      revert UnlockNotStarted(param.seasonId);\n    }\n    if (config.tokenAmount == 0) {\n      revert IBUILDFactory.ProjectSeasonDoesNotExist(param.seasonId, address(i_token));\n    }\n    if (\n      !_verifyMerkleProof(\n        config.merkleRoot, user, param.proof, param.maxTokenAmount, param.isEarlyClaim, param.salt\n      )\n    ) {\n      revert InvalidMerkleProof();\n    }\n    if (unlockState.isUnlocking && param.isEarlyClaim && userState.hasEarlyClaimed) {\n      revert InvalidEarlyClaim(user, param.seasonId);\n    }\n    if (userState.claimed == 0 && config.isRefunding) {\n      // If the user hasn't claimed for this season before the refunding starts, the user will\n      // be refunded their allocated credits but can no longer claim tokens\n      revert IBUILDFactory.ProjectSeasonIsRefunding(address(i_token), param.seasonId);\n    }\n  }\n\n  /// @notice Util function that claims tokens for a user for multiple seasons\n  /// @param user The user address\n  /// @param params An array of claim params including the season ID, proof, and max token amount\n  /// for each season\n  function _claim(address user, ClaimParams[] memory params) private {\n    uint256 totalClaimableAmount;\n    bool isEarlyClaim = false;\n\n    // Cache array length outside loop\n    uint256 paramsLength = params.length;\n    for (uint256 i = 0; i < paramsLength; ++i) {\n      ClaimParams memory param = params[i];\n      if (param.isEarlyClaim) {\n        isEarlyClaim = true;\n      }\n      (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n        i_factory.getProjectSeasonConfig(address(i_token), param.seasonId);\n\n      UserState memory userState = s_userStates[user][param.seasonId];\n      UnlockState memory unlockState =\n        _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n\n      _validateClaimParams(user, userState, param, config, unlockStartsAt, unlockState);\n\n      if (userState.hasEarlyClaimed) {\n        continue;\n      }\n\n      GlobalState storage globalState = s_globalStates[param.seasonId];\n      ClaimableState memory claimableState =\n        _getClaimableState(config, globalState, userState, unlockState, param.maxTokenAmount);\n\n      // short-circuit on potential zero claim value before consuming refundable amount\n      // if regular claim, claimable must be > 0\n      // if early claim, earlyClaimable must be > 0\n      if (\n        (claimableState.claimable == 0 && !param.isEarlyClaim)\n          || (\n            claimableState.claimable == 0 && claimableState.earlyVestableBonus == 0\n              && param.isEarlyClaim\n          )\n      ) {\n        continue;\n      }\n\n      if (claimableState.claimed == 0) {\n        // User is claiming for the first time for this particular season, so the project can no\n        // longer reclaim the refundable amount for this user's credits\n        i_factory.reduceRefundableAmount(address(i_token), param.seasonId, param.maxTokenAmount);\n      }\n      uint256 toBeClaimed = claimableState.claimable;\n      if (unlockState.isUnlocking && param.isEarlyClaim) {\n        globalState.totalLoyalty +=\n          claimableState.bonus - claimableState.vested - claimableState.earlyVestableBonus;\n        globalState.totalLoyaltyIneligible += param.maxTokenAmount;\n        userState.hasEarlyClaimed = true;\n        toBeClaimed += claimableState.earlyVestableBonus;\n      }\n\n      totalClaimableAmount += toBeClaimed;\n      _updateClaimedAmounts(\n        user,\n        globalState,\n        userState,\n        param,\n        toBeClaimed,\n        param.isEarlyClaim ? claimableState.earlyVestableBonus : 0\n      );\n    }\n\n    if (isEarlyClaim && user != msg.sender) {\n      if (\n        !i_factory.getDelegateRegistry().checkDelegateForContract({\n          to: msg.sender,\n          from: user,\n          contract_: address(i_factory),\n          rights: bytes32(0)\n        })\n      ) {\n        revert InvalidSender(msg.sender);\n      }\n    }\n\n    if (totalClaimableAmount == 0) {\n      return;\n    }\n    i_token.safeTransfer(user, totalClaimableAmount);\n  }\n\n  /// @notice Updates the claimed amounts for a user and the season\n  /// @param user The user address\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param param The input parameters for the claim\n  /// @param toBeClaimed The amount of tokens to be claimed by the user\n  /// @param earlyVestableBonus The amount of bonus tokens that can be claimed early\n  /// @dev This function is called when a user claims tokens\n  function _updateClaimedAmounts(\n    address user,\n    GlobalState storage globalState,\n    UserState memory userState,\n    ClaimParams memory param,\n    uint256 toBeClaimed,\n    uint256 earlyVestableBonus\n  ) private {\n    userState.claimed += uint248(toBeClaimed);\n    s_userStates[user][param.seasonId] = userState;\n\n    globalState.totalClaimed += toBeClaimed;\n\n    emit Claimed(\n      user,\n      param.seasonId,\n      toBeClaimed,\n      param.isEarlyClaim,\n      earlyVestableBonus,\n      userState.claimed,\n      globalState.totalClaimed,\n      globalState.totalLoyalty,\n      globalState.totalLoyaltyIneligible\n    );\n  }\n\n  /// @notice Only callable by the factory contract admin\n  modifier onlyProjectAdmin() {\n    if (msg.sender != i_factory.getProjectConfig(address(i_token)).admin) {\n      revert IAccessControl.AccessControlUnauthorizedAccount(msg.sender, keccak256(\"PROJECT_ADMIN\"));\n    }\n    _;\n  }\n\n  /// @notice Only callable when claim contract is not paused\n  modifier whenClaimNotPaused() {\n    if (i_factory.isClaimContractPaused(address(i_token))) {\n      revert Pausable.EnforcedPause();\n    }\n    _;\n  }\n}", "modifiers": [], "stateMutability": "view", "returnParameters": null, "visibility": "external", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol"}, {"type": "FunctionDefinition", "name": "BUILDClaim.getUserState", "start_line": 136, "end_line": 145, "offset_start": 5201, "offset_end": 5576, "content": "function getUserState(\n    UserSeasonId[] calldata usersAndSeasonIds\n  ) external view returns (UserState[] memory) {\n    uint256 count = usersAndSeasonIds.length;\n    UserState[] memory states = new UserState[](count);\n    for (uint256 i; i < count; ++i) {\n      states[i] = s_userStates[usersAndSeasonIds[i].user][usersAndSeasonIds[i].seasonId];\n    }\n    return states;\n  }", "contract_name": "BUILDClaim", "contract_code": "{\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint256;\n\n  /// @notice The unlock state for a season at a given time\n  struct UnlockState {\n    uint256 unlockElapsedDuration; // The amount of time that has elapsed since\n      // the unlock delay started\n    bool isBeforeUnlock; // Whether the unlock period has started (including the delay)\n    bool isUnlocking; // Whether the unlock period is in progress\n  }\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDClaim 1.0.0\";\n\n  /// @notice The claimed and early claimed states for a user per season\n  mapping(address user => mapping(uint256 seasonId => UserState)) private s_userStates;\n\n  /// @notice The global states for a season\n  mapping(uint256 seasonId => GlobalState globalState) private s_globalStates;\n\n  /// @notice The project token\n  IERC20 private immutable i_token;\n\n  /// @notice The factory that deployed this contract\n  BUILDFactory private immutable i_factory;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @notice constructor\n  /// @param token The project token\n  constructor(\n    address token\n  ) {\n    i_token = IERC20(token);\n    i_factory = BUILDFactory(msg.sender);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getFactory() external view override returns (BUILDFactory) {\n    return i_factory;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getToken() external view override returns (IERC20) {\n    return i_token;\n  }\n\n  /// @inheritdoc IERC165\n  function supportsInterface(\n    bytes4 interfaceId\n  ) external pure override returns (bool) {\n    return interfaceId == type(IBUILDClaim).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  // ================================================================\n  // |                        Token Deposits                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function deposit(\n    uint256 amount\n  ) external override nonReentrant whenClaimNotPaused onlyProjectAdmin {\n    // only callable when factory contract is open\n    if (!i_factory.isOpen()) {\n      revert Closable.AlreadyClosed();\n    }\n\n    uint256 balanceBefore = i_token.balanceOf(address(this));\n    uint256 totalDeposited = i_factory.addTotalDeposited(address(i_token), amount);\n    i_token.safeTransferFrom(msg.sender, address(this), amount);\n    uint256 balanceAfter = i_token.balanceOf(address(this));\n    if (balanceBefore + amount != balanceAfter) {\n      revert InvalidDeposit(balanceBefore, balanceAfter);\n    }\n\n    emit Deposited(address(i_token), msg.sender, amount, totalDeposited);\n  }\n\n  // ================================================================\n  // |                       Token Withdrawals                      |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function withdraw() external override nonReentrant onlyProjectAdmin {\n    (IBUILDFactory.Withdrawal memory withdrawal, uint256 totalWithdrawn) =\n      i_factory.executeWithdraw(address(i_token));\n    i_token.safeTransfer(withdrawal.recipient, withdrawal.amount);\n    emit Withdrawn(address(i_token), withdrawal.recipient, withdrawal.amount, totalWithdrawn);\n  }\n\n  // ================================================================\n  // |                         Token Claims                         |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function claim(\n    address user,\n    ClaimParams[] calldata params\n  ) external override nonReentrant whenClaimNotPaused {\n    _claim(user, params);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getGlobalState(\n    uint256 seasonId\n  ) external view returns (GlobalState memory) {\n    return s_globalStates[seasonId];\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getUserState(\n    UserSeasonId[] calldata usersAndSeasonIds\n  ) external view returns (UserState[] memory) {\n    uint256 count = usersAndSeasonIds.length;\n    UserState[] memory states = new UserState[](count);\n    for (uint256 i; i < count; ++i) {\n      states[i] = s_userStates[usersAndSeasonIds[i].user][usersAndSeasonIds[i].seasonId];\n    }\n    return states;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getCurrentClaimValues(\n    address user,\n    uint256 seasonId,\n    uint256 maxTokenAmount\n  ) external view returns (ClaimableState memory) {\n    (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n      i_factory.getProjectSeasonConfig(address(i_token), seasonId);\n    UnlockState memory unlockState =\n      _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n    return _getClaimableState(\n      config, s_globalStates[seasonId], s_userStates[user][seasonId], unlockState, maxTokenAmount\n    );\n  }\n\n  /// @notice Validates if the user is eligible to claim the amount of tokens for a season\n  /// A merkle tree's leaf consists of a user address, their max token amount for the season and a\n  /// salt\n  /// @param root The merkle root of a season\n  /// @param user The user's address\n  /// @param proof The merkle proof of the user's address, max token amount and salt\n  /// @param maxTokenAmount The user's total claimable token amount for the season\n  /// @param isEarlyClaim Whether the user is claiming early\n  /// @param salt A randomly generated salt to prevent brute-force guessing of merkle proofs\n  /// @return bool Returns true if the user's proof, maxTokenAmount and salt are valid\n  function _verifyMerkleProof(\n    bytes32 root,\n    address user,\n    bytes32[] memory proof,\n    uint256 maxTokenAmount,\n    bool isEarlyClaim,\n    uint256 salt\n  ) private pure returns (bool) {\n    bytes32 leaf =\n      keccak256(bytes.concat(keccak256(abi.encode(user, maxTokenAmount, isEarlyClaim, salt))));\n    return MerkleProof.verify(proof, root, leaf);\n  }\n\n  /// @notice Calculates the amount of tokens that can be claimed by a user for a season\n  /// without requiring an early claim at a particular timestamp.\n  /// This amount is the sum of the base tokens amount that is released all at once after the\n  /// unlock delay and the unlocked amount that is released linearly over the unlock duration.\n  /// This does not factor in any claimed amounts\n  /// @param config The project season config\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param unlockState The unlock state for the season\n  /// @param maxTokenAmount The maximum token amount for the user\n  /// @return ClaimableState The amount of tokens that can be claimed\n  function _getClaimableState(\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    IBUILDClaim.GlobalState memory globalState,\n    UserState memory userState,\n    UnlockState memory unlockState,\n    uint256 maxTokenAmount\n  ) internal pure returns (ClaimableState memory) {\n    ClaimableState memory claimableState;\n    claimableState.base =\n      (maxTokenAmount * config.baseTokenClaimBps) / PERCENTAGE_BASIS_POINTS_DENOMINATOR;\n    claimableState.bonus = maxTokenAmount - claimableState.base;\n\n    if (config.tokenAmount == 0 || (config.isRefunding && userState.claimed == 0)) {\n      return claimableState;\n    }\n\n    claimableState.claimed = userState.claimed;\n\n    if (userState.hasEarlyClaimed || unlockState.isBeforeUnlock) return claimableState;\n    // calculate share of loyalty pool to receive\n    // The loyalty bonus is informative only in the unlock period, as it is not\n    // claimable until the vesting is completed.\n    claimableState.loyaltyBonus = maxTokenAmount * globalState.totalLoyalty\n      / (config.tokenAmount - globalState.totalLoyaltyIneligible);\n\n    if (unlockState.isUnlocking) {\n      // unlock period is in progress\n      claimableState.vested =\n        (claimableState.bonus * unlockState.unlockElapsedDuration) / config.unlockDuration;\n      claimableState.claimable =\n        claimableState.base + claimableState.vested - claimableState.claimed;\n      claimableState.earlyVestableBonus =\n        _calcEarlyVestableBonus(claimableState, config, unlockState.unlockElapsedDuration);\n    } else {\n      // unlock completed\n      claimableState.claimable =\n        maxTokenAmount + claimableState.loyaltyBonus - claimableState.claimed;\n    }\n\n    return claimableState;\n  }\n\n  /// @notice Calculates the amount of bonus tokens that can be claimed early\n  /// @param claimableState The claimable state for the user\n  /// @param config The project season config\n  /// @param timeElapsed The amount of time that has elapsed since the unlock delay started\n  /// @return uint256 The amount of bonus tokens that can be claimed early\n  function _calcEarlyVestableBonus(\n    ClaimableState memory claimableState,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 timeElapsed\n  ) private pure returns (uint256) {\n    return FixedPointMathLib.mulWadDown(\n      claimableState.bonus - claimableState.vested,\n      FixedPointMathLib.divWadDown(config.earlyVestRatioMinBps, PERCENTAGE_BASIS_POINTS_DENOMINATOR)\n        + (\n          FixedPointMathLib.divWadDown(\n            config.earlyVestRatioMaxBps - config.earlyVestRatioMinBps,\n            PERCENTAGE_BASIS_POINTS_DENOMINATOR\n          ) * timeElapsed\n        ) / config.unlockDuration\n    );\n  }\n\n  /// @notice Returns the unlock progress for a season\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockDelay The delay before the unlock period starts\n  /// @param unlockDuration The duration of the unlock period\n  /// @param targetTime The timestamp to evaluate the unlock progress at\n  /// @return UnlockState The unlock state for the target time\n  function _getUnlockState(\n    uint256 unlockStartsAt,\n    uint256 unlockDelay,\n    uint256 unlockDuration,\n    uint256 targetTime\n  ) internal pure returns (UnlockState memory) {\n    uint256 unlockDelayEndsAt = unlockStartsAt + unlockDelay;\n    if (targetTime < unlockDelayEndsAt) {\n      return UnlockState({isBeforeUnlock: true, isUnlocking: false, unlockElapsedDuration: 0});\n    }\n    return UnlockState({\n      isBeforeUnlock: false,\n      isUnlocking: targetTime < unlockDelayEndsAt + unlockDuration,\n      unlockElapsedDuration: targetTime - unlockDelayEndsAt\n    });\n  }\n\n  /// @notice Validates the claim parameters for a user\n  /// @param user The user address\n  /// @param userState The user state for the season\n  /// @param param The claim parameters for a user\n  /// @param config The project season config\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockState The unlock state for the season\n  /// @dev Reverts if the claim parameters are invalid\n  /// @dev Reverts if the unlock period has not started yet, including the configured unlock delay\n  /// @dev Reverts if the project season does not exist for the given token address\n  /// @dev Reverts if the user's proof is invalid\n  /// @dev Reverts if user attempts to earlyClaim after previously early claiming during the unlock\n  /// period\n  function _validateClaimParams(\n    address user,\n    UserState memory userState,\n    ClaimParams memory param,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 unlockStartsAt,\n    UnlockState memory unlockState\n  ) private view {\n    if (user == address(0)) {\n      revert InvalidUser(user);\n    }\n    if (unlockStartsAt == 0) {\n      revert IBUILDFactory.SeasonDoesNotExist(param.seasonId);\n    }\n    if (unlockState.isBeforeUnlock) {\n      revert UnlockNotStarted(param.seasonId);\n    }\n    if (config.tokenAmount == 0) {\n      revert IBUILDFactory.ProjectSeasonDoesNotExist(param.seasonId, address(i_token));\n    }\n    if (\n      !_verifyMerkleProof(\n        config.merkleRoot, user, param.proof, param.maxTokenAmount, param.isEarlyClaim, param.salt\n      )\n    ) {\n      revert InvalidMerkleProof();\n    }\n    if (unlockState.isUnlocking && param.isEarlyClaim && userState.hasEarlyClaimed) {\n      revert InvalidEarlyClaim(user, param.seasonId);\n    }\n    if (userState.claimed == 0 && config.isRefunding) {\n      // If the user hasn't claimed for this season before the refunding starts, the user will\n      // be refunded their allocated credits but can no longer claim tokens\n      revert IBUILDFactory.ProjectSeasonIsRefunding(address(i_token), param.seasonId);\n    }\n  }\n\n  /// @notice Util function that claims tokens for a user for multiple seasons\n  /// @param user The user address\n  /// @param params An array of claim params including the season ID, proof, and max token amount\n  /// for each season\n  function _claim(address user, ClaimParams[] memory params) private {\n    uint256 totalClaimableAmount;\n    bool isEarlyClaim = false;\n\n    // Cache array length outside loop\n    uint256 paramsLength = params.length;\n    for (uint256 i = 0; i < paramsLength; ++i) {\n      ClaimParams memory param = params[i];\n      if (param.isEarlyClaim) {\n        isEarlyClaim = true;\n      }\n      (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n        i_factory.getProjectSeasonConfig(address(i_token), param.seasonId);\n\n      UserState memory userState = s_userStates[user][param.seasonId];\n      UnlockState memory unlockState =\n        _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n\n      _validateClaimParams(user, userState, param, config, unlockStartsAt, unlockState);\n\n      if (userState.hasEarlyClaimed) {\n        continue;\n      }\n\n      GlobalState storage globalState = s_globalStates[param.seasonId];\n      ClaimableState memory claimableState =\n        _getClaimableState(config, globalState, userState, unlockState, param.maxTokenAmount);\n\n      // short-circuit on potential zero claim value before consuming refundable amount\n      // if regular claim, claimable must be > 0\n      // if early claim, earlyClaimable must be > 0\n      if (\n        (claimableState.claimable == 0 && !param.isEarlyClaim)\n          || (\n            claimableState.claimable == 0 && claimableState.earlyVestableBonus == 0\n              && param.isEarlyClaim\n          )\n      ) {\n        continue;\n      }\n\n      if (claimableState.claimed == 0) {\n        // User is claiming for the first time for this particular season, so the project can no\n        // longer reclaim the refundable amount for this user's credits\n        i_factory.reduceRefundableAmount(address(i_token), param.seasonId, param.maxTokenAmount);\n      }\n      uint256 toBeClaimed = claimableState.claimable;\n      if (unlockState.isUnlocking && param.isEarlyClaim) {\n        globalState.totalLoyalty +=\n          claimableState.bonus - claimableState.vested - claimableState.earlyVestableBonus;\n        globalState.totalLoyaltyIneligible += param.maxTokenAmount;\n        userState.hasEarlyClaimed = true;\n        toBeClaimed += claimableState.earlyVestableBonus;\n      }\n\n      totalClaimableAmount += toBeClaimed;\n      _updateClaimedAmounts(\n        user,\n        globalState,\n        userState,\n        param,\n        toBeClaimed,\n        param.isEarlyClaim ? claimableState.earlyVestableBonus : 0\n      );\n    }\n\n    if (isEarlyClaim && user != msg.sender) {\n      if (\n        !i_factory.getDelegateRegistry().checkDelegateForContract({\n          to: msg.sender,\n          from: user,\n          contract_: address(i_factory),\n          rights: bytes32(0)\n        })\n      ) {\n        revert InvalidSender(msg.sender);\n      }\n    }\n\n    if (totalClaimableAmount == 0) {\n      return;\n    }\n    i_token.safeTransfer(user, totalClaimableAmount);\n  }\n\n  /// @notice Updates the claimed amounts for a user and the season\n  /// @param user The user address\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param param The input parameters for the claim\n  /// @param toBeClaimed The amount of tokens to be claimed by the user\n  /// @param earlyVestableBonus The amount of bonus tokens that can be claimed early\n  /// @dev This function is called when a user claims tokens\n  function _updateClaimedAmounts(\n    address user,\n    GlobalState storage globalState,\n    UserState memory userState,\n    ClaimParams memory param,\n    uint256 toBeClaimed,\n    uint256 earlyVestableBonus\n  ) private {\n    userState.claimed += uint248(toBeClaimed);\n    s_userStates[user][param.seasonId] = userState;\n\n    globalState.totalClaimed += toBeClaimed;\n\n    emit Claimed(\n      user,\n      param.seasonId,\n      toBeClaimed,\n      param.isEarlyClaim,\n      earlyVestableBonus,\n      userState.claimed,\n      globalState.totalClaimed,\n      globalState.totalLoyalty,\n      globalState.totalLoyaltyIneligible\n    );\n  }\n\n  /// @notice Only callable by the factory contract admin\n  modifier onlyProjectAdmin() {\n    if (msg.sender != i_factory.getProjectConfig(address(i_token)).admin) {\n      revert IAccessControl.AccessControlUnauthorizedAccount(msg.sender, keccak256(\"PROJECT_ADMIN\"));\n    }\n    _;\n  }\n\n  /// @notice Only callable when claim contract is not paused\n  modifier whenClaimNotPaused() {\n    if (i_factory.isClaimContractPaused(address(i_token))) {\n      revert Pausable.EnforcedPause();\n    }\n    _;\n  }\n}", "modifiers": [], "stateMutability": "view", "returnParameters": null, "visibility": "external", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol"}, {"type": "FunctionDefinition", "name": "BUILDClaim.getCurrentClaimValues", "start_line": 148, "end_line": 160, "offset_start": 5611, "offset_end": 6184, "content": "function getCurrentClaimValues(\n    address user,\n    uint256 seasonId,\n    uint256 maxTokenAmount\n  ) external view returns (ClaimableState memory) {\n    (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n      i_factory.getProjectSeasonConfig(address(i_token), seasonId);\n    UnlockState memory unlockState =\n      _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n    return _getClaimableState(\n      config, s_globalStates[seasonId], s_userStates[user][seasonId], unlockState, maxTokenAmount\n    );\n  }", "contract_name": "BUILDClaim", "contract_code": "{\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint256;\n\n  /// @notice The unlock state for a season at a given time\n  struct UnlockState {\n    uint256 unlockElapsedDuration; // The amount of time that has elapsed since\n      // the unlock delay started\n    bool isBeforeUnlock; // Whether the unlock period has started (including the delay)\n    bool isUnlocking; // Whether the unlock period is in progress\n  }\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDClaim 1.0.0\";\n\n  /// @notice The claimed and early claimed states for a user per season\n  mapping(address user => mapping(uint256 seasonId => UserState)) private s_userStates;\n\n  /// @notice The global states for a season\n  mapping(uint256 seasonId => GlobalState globalState) private s_globalStates;\n\n  /// @notice The project token\n  IERC20 private immutable i_token;\n\n  /// @notice The factory that deployed this contract\n  BUILDFactory private immutable i_factory;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @notice constructor\n  /// @param token The project token\n  constructor(\n    address token\n  ) {\n    i_token = IERC20(token);\n    i_factory = BUILDFactory(msg.sender);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getFactory() external view override returns (BUILDFactory) {\n    return i_factory;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getToken() external view override returns (IERC20) {\n    return i_token;\n  }\n\n  /// @inheritdoc IERC165\n  function supportsInterface(\n    bytes4 interfaceId\n  ) external pure override returns (bool) {\n    return interfaceId == type(IBUILDClaim).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  // ================================================================\n  // |                        Token Deposits                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function deposit(\n    uint256 amount\n  ) external override nonReentrant whenClaimNotPaused onlyProjectAdmin {\n    // only callable when factory contract is open\n    if (!i_factory.isOpen()) {\n      revert Closable.AlreadyClosed();\n    }\n\n    uint256 balanceBefore = i_token.balanceOf(address(this));\n    uint256 totalDeposited = i_factory.addTotalDeposited(address(i_token), amount);\n    i_token.safeTransferFrom(msg.sender, address(this), amount);\n    uint256 balanceAfter = i_token.balanceOf(address(this));\n    if (balanceBefore + amount != balanceAfter) {\n      revert InvalidDeposit(balanceBefore, balanceAfter);\n    }\n\n    emit Deposited(address(i_token), msg.sender, amount, totalDeposited);\n  }\n\n  // ================================================================\n  // |                       Token Withdrawals                      |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function withdraw() external override nonReentrant onlyProjectAdmin {\n    (IBUILDFactory.Withdrawal memory withdrawal, uint256 totalWithdrawn) =\n      i_factory.executeWithdraw(address(i_token));\n    i_token.safeTransfer(withdrawal.recipient, withdrawal.amount);\n    emit Withdrawn(address(i_token), withdrawal.recipient, withdrawal.amount, totalWithdrawn);\n  }\n\n  // ================================================================\n  // |                         Token Claims                         |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function claim(\n    address user,\n    ClaimParams[] calldata params\n  ) external override nonReentrant whenClaimNotPaused {\n    _claim(user, params);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getGlobalState(\n    uint256 seasonId\n  ) external view returns (GlobalState memory) {\n    return s_globalStates[seasonId];\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getUserState(\n    UserSeasonId[] calldata usersAndSeasonIds\n  ) external view returns (UserState[] memory) {\n    uint256 count = usersAndSeasonIds.length;\n    UserState[] memory states = new UserState[](count);\n    for (uint256 i; i < count; ++i) {\n      states[i] = s_userStates[usersAndSeasonIds[i].user][usersAndSeasonIds[i].seasonId];\n    }\n    return states;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getCurrentClaimValues(\n    address user,\n    uint256 seasonId,\n    uint256 maxTokenAmount\n  ) external view returns (ClaimableState memory) {\n    (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n      i_factory.getProjectSeasonConfig(address(i_token), seasonId);\n    UnlockState memory unlockState =\n      _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n    return _getClaimableState(\n      config, s_globalStates[seasonId], s_userStates[user][seasonId], unlockState, maxTokenAmount\n    );\n  }\n\n  /// @notice Validates if the user is eligible to claim the amount of tokens for a season\n  /// A merkle tree's leaf consists of a user address, their max token amount for the season and a\n  /// salt\n  /// @param root The merkle root of a season\n  /// @param user The user's address\n  /// @param proof The merkle proof of the user's address, max token amount and salt\n  /// @param maxTokenAmount The user's total claimable token amount for the season\n  /// @param isEarlyClaim Whether the user is claiming early\n  /// @param salt A randomly generated salt to prevent brute-force guessing of merkle proofs\n  /// @return bool Returns true if the user's proof, maxTokenAmount and salt are valid\n  function _verifyMerkleProof(\n    bytes32 root,\n    address user,\n    bytes32[] memory proof,\n    uint256 maxTokenAmount,\n    bool isEarlyClaim,\n    uint256 salt\n  ) private pure returns (bool) {\n    bytes32 leaf =\n      keccak256(bytes.concat(keccak256(abi.encode(user, maxTokenAmount, isEarlyClaim, salt))));\n    return MerkleProof.verify(proof, root, leaf);\n  }\n\n  /// @notice Calculates the amount of tokens that can be claimed by a user for a season\n  /// without requiring an early claim at a particular timestamp.\n  /// This amount is the sum of the base tokens amount that is released all at once after the\n  /// unlock delay and the unlocked amount that is released linearly over the unlock duration.\n  /// This does not factor in any claimed amounts\n  /// @param config The project season config\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param unlockState The unlock state for the season\n  /// @param maxTokenAmount The maximum token amount for the user\n  /// @return ClaimableState The amount of tokens that can be claimed\n  function _getClaimableState(\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    IBUILDClaim.GlobalState memory globalState,\n    UserState memory userState,\n    UnlockState memory unlockState,\n    uint256 maxTokenAmount\n  ) internal pure returns (ClaimableState memory) {\n    ClaimableState memory claimableState;\n    claimableState.base =\n      (maxTokenAmount * config.baseTokenClaimBps) / PERCENTAGE_BASIS_POINTS_DENOMINATOR;\n    claimableState.bonus = maxTokenAmount - claimableState.base;\n\n    if (config.tokenAmount == 0 || (config.isRefunding && userState.claimed == 0)) {\n      return claimableState;\n    }\n\n    claimableState.claimed = userState.claimed;\n\n    if (userState.hasEarlyClaimed || unlockState.isBeforeUnlock) return claimableState;\n    // calculate share of loyalty pool to receive\n    // The loyalty bonus is informative only in the unlock period, as it is not\n    // claimable until the vesting is completed.\n    claimableState.loyaltyBonus = maxTokenAmount * globalState.totalLoyalty\n      / (config.tokenAmount - globalState.totalLoyaltyIneligible);\n\n    if (unlockState.isUnlocking) {\n      // unlock period is in progress\n      claimableState.vested =\n        (claimableState.bonus * unlockState.unlockElapsedDuration) / config.unlockDuration;\n      claimableState.claimable =\n        claimableState.base + claimableState.vested - claimableState.claimed;\n      claimableState.earlyVestableBonus =\n        _calcEarlyVestableBonus(claimableState, config, unlockState.unlockElapsedDuration);\n    } else {\n      // unlock completed\n      claimableState.claimable =\n        maxTokenAmount + claimableState.loyaltyBonus - claimableState.claimed;\n    }\n\n    return claimableState;\n  }\n\n  /// @notice Calculates the amount of bonus tokens that can be claimed early\n  /// @param claimableState The claimable state for the user\n  /// @param config The project season config\n  /// @param timeElapsed The amount of time that has elapsed since the unlock delay started\n  /// @return uint256 The amount of bonus tokens that can be claimed early\n  function _calcEarlyVestableBonus(\n    ClaimableState memory claimableState,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 timeElapsed\n  ) private pure returns (uint256) {\n    return FixedPointMathLib.mulWadDown(\n      claimableState.bonus - claimableState.vested,\n      FixedPointMathLib.divWadDown(config.earlyVestRatioMinBps, PERCENTAGE_BASIS_POINTS_DENOMINATOR)\n        + (\n          FixedPointMathLib.divWadDown(\n            config.earlyVestRatioMaxBps - config.earlyVestRatioMinBps,\n            PERCENTAGE_BASIS_POINTS_DENOMINATOR\n          ) * timeElapsed\n        ) / config.unlockDuration\n    );\n  }\n\n  /// @notice Returns the unlock progress for a season\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockDelay The delay before the unlock period starts\n  /// @param unlockDuration The duration of the unlock period\n  /// @param targetTime The timestamp to evaluate the unlock progress at\n  /// @return UnlockState The unlock state for the target time\n  function _getUnlockState(\n    uint256 unlockStartsAt,\n    uint256 unlockDelay,\n    uint256 unlockDuration,\n    uint256 targetTime\n  ) internal pure returns (UnlockState memory) {\n    uint256 unlockDelayEndsAt = unlockStartsAt + unlockDelay;\n    if (targetTime < unlockDelayEndsAt) {\n      return UnlockState({isBeforeUnlock: true, isUnlocking: false, unlockElapsedDuration: 0});\n    }\n    return UnlockState({\n      isBeforeUnlock: false,\n      isUnlocking: targetTime < unlockDelayEndsAt + unlockDuration,\n      unlockElapsedDuration: targetTime - unlockDelayEndsAt\n    });\n  }\n\n  /// @notice Validates the claim parameters for a user\n  /// @param user The user address\n  /// @param userState The user state for the season\n  /// @param param The claim parameters for a user\n  /// @param config The project season config\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockState The unlock state for the season\n  /// @dev Reverts if the claim parameters are invalid\n  /// @dev Reverts if the unlock period has not started yet, including the configured unlock delay\n  /// @dev Reverts if the project season does not exist for the given token address\n  /// @dev Reverts if the user's proof is invalid\n  /// @dev Reverts if user attempts to earlyClaim after previously early claiming during the unlock\n  /// period\n  function _validateClaimParams(\n    address user,\n    UserState memory userState,\n    ClaimParams memory param,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 unlockStartsAt,\n    UnlockState memory unlockState\n  ) private view {\n    if (user == address(0)) {\n      revert InvalidUser(user);\n    }\n    if (unlockStartsAt == 0) {\n      revert IBUILDFactory.SeasonDoesNotExist(param.seasonId);\n    }\n    if (unlockState.isBeforeUnlock) {\n      revert UnlockNotStarted(param.seasonId);\n    }\n    if (config.tokenAmount == 0) {\n      revert IBUILDFactory.ProjectSeasonDoesNotExist(param.seasonId, address(i_token));\n    }\n    if (\n      !_verifyMerkleProof(\n        config.merkleRoot, user, param.proof, param.maxTokenAmount, param.isEarlyClaim, param.salt\n      )\n    ) {\n      revert InvalidMerkleProof();\n    }\n    if (unlockState.isUnlocking && param.isEarlyClaim && userState.hasEarlyClaimed) {\n      revert InvalidEarlyClaim(user, param.seasonId);\n    }\n    if (userState.claimed == 0 && config.isRefunding) {\n      // If the user hasn't claimed for this season before the refunding starts, the user will\n      // be refunded their allocated credits but can no longer claim tokens\n      revert IBUILDFactory.ProjectSeasonIsRefunding(address(i_token), param.seasonId);\n    }\n  }\n\n  /// @notice Util function that claims tokens for a user for multiple seasons\n  /// @param user The user address\n  /// @param params An array of claim params including the season ID, proof, and max token amount\n  /// for each season\n  function _claim(address user, ClaimParams[] memory params) private {\n    uint256 totalClaimableAmount;\n    bool isEarlyClaim = false;\n\n    // Cache array length outside loop\n    uint256 paramsLength = params.length;\n    for (uint256 i = 0; i < paramsLength; ++i) {\n      ClaimParams memory param = params[i];\n      if (param.isEarlyClaim) {\n        isEarlyClaim = true;\n      }\n      (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n        i_factory.getProjectSeasonConfig(address(i_token), param.seasonId);\n\n      UserState memory userState = s_userStates[user][param.seasonId];\n      UnlockState memory unlockState =\n        _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n\n      _validateClaimParams(user, userState, param, config, unlockStartsAt, unlockState);\n\n      if (userState.hasEarlyClaimed) {\n        continue;\n      }\n\n      GlobalState storage globalState = s_globalStates[param.seasonId];\n      ClaimableState memory claimableState =\n        _getClaimableState(config, globalState, userState, unlockState, param.maxTokenAmount);\n\n      // short-circuit on potential zero claim value before consuming refundable amount\n      // if regular claim, claimable must be > 0\n      // if early claim, earlyClaimable must be > 0\n      if (\n        (claimableState.claimable == 0 && !param.isEarlyClaim)\n          || (\n            claimableState.claimable == 0 && claimableState.earlyVestableBonus == 0\n              && param.isEarlyClaim\n          )\n      ) {\n        continue;\n      }\n\n      if (claimableState.claimed == 0) {\n        // User is claiming for the first time for this particular season, so the project can no\n        // longer reclaim the refundable amount for this user's credits\n        i_factory.reduceRefundableAmount(address(i_token), param.seasonId, param.maxTokenAmount);\n      }\n      uint256 toBeClaimed = claimableState.claimable;\n      if (unlockState.isUnlocking && param.isEarlyClaim) {\n        globalState.totalLoyalty +=\n          claimableState.bonus - claimableState.vested - claimableState.earlyVestableBonus;\n        globalState.totalLoyaltyIneligible += param.maxTokenAmount;\n        userState.hasEarlyClaimed = true;\n        toBeClaimed += claimableState.earlyVestableBonus;\n      }\n\n      totalClaimableAmount += toBeClaimed;\n      _updateClaimedAmounts(\n        user,\n        globalState,\n        userState,\n        param,\n        toBeClaimed,\n        param.isEarlyClaim ? claimableState.earlyVestableBonus : 0\n      );\n    }\n\n    if (isEarlyClaim && user != msg.sender) {\n      if (\n        !i_factory.getDelegateRegistry().checkDelegateForContract({\n          to: msg.sender,\n          from: user,\n          contract_: address(i_factory),\n          rights: bytes32(0)\n        })\n      ) {\n        revert InvalidSender(msg.sender);\n      }\n    }\n\n    if (totalClaimableAmount == 0) {\n      return;\n    }\n    i_token.safeTransfer(user, totalClaimableAmount);\n  }\n\n  /// @notice Updates the claimed amounts for a user and the season\n  /// @param user The user address\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param param The input parameters for the claim\n  /// @param toBeClaimed The amount of tokens to be claimed by the user\n  /// @param earlyVestableBonus The amount of bonus tokens that can be claimed early\n  /// @dev This function is called when a user claims tokens\n  function _updateClaimedAmounts(\n    address user,\n    GlobalState storage globalState,\n    UserState memory userState,\n    ClaimParams memory param,\n    uint256 toBeClaimed,\n    uint256 earlyVestableBonus\n  ) private {\n    userState.claimed += uint248(toBeClaimed);\n    s_userStates[user][param.seasonId] = userState;\n\n    globalState.totalClaimed += toBeClaimed;\n\n    emit Claimed(\n      user,\n      param.seasonId,\n      toBeClaimed,\n      param.isEarlyClaim,\n      earlyVestableBonus,\n      userState.claimed,\n      globalState.totalClaimed,\n      globalState.totalLoyalty,\n      globalState.totalLoyaltyIneligible\n    );\n  }\n\n  /// @notice Only callable by the factory contract admin\n  modifier onlyProjectAdmin() {\n    if (msg.sender != i_factory.getProjectConfig(address(i_token)).admin) {\n      revert IAccessControl.AccessControlUnauthorizedAccount(msg.sender, keccak256(\"PROJECT_ADMIN\"));\n    }\n    _;\n  }\n\n  /// @notice Only callable when claim contract is not paused\n  modifier whenClaimNotPaused() {\n    if (i_factory.isClaimContractPaused(address(i_token))) {\n      revert Pausable.EnforcedPause();\n    }\n    _;\n  }\n}", "modifiers": [], "stateMutability": "view", "returnParameters": null, "visibility": "external", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol"}, {"type": "FunctionDefinition", "name": "BUILDClaim._verifyMerkleProof", "start_line": 172, "end_line": 183, "offset_start": 6882, "offset_end": 7244, "content": "function _verifyMerkleProof(\n    bytes32 root,\n    address user,\n    bytes32[] memory proof,\n    uint256 maxTokenAmount,\n    bool isEarlyClaim,\n    uint256 salt\n  ) private pure returns (bool) {\n    bytes32 leaf =\n      keccak256(bytes.concat(keccak256(abi.encode(user, maxTokenAmount, isEarlyClaim, salt))));\n    return MerkleProof.verify(proof, root, leaf);\n  }", "contract_name": "BUILDClaim", "contract_code": "{\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint256;\n\n  /// @notice The unlock state for a season at a given time\n  struct UnlockState {\n    uint256 unlockElapsedDuration; // The amount of time that has elapsed since\n      // the unlock delay started\n    bool isBeforeUnlock; // Whether the unlock period has started (including the delay)\n    bool isUnlocking; // Whether the unlock period is in progress\n  }\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDClaim 1.0.0\";\n\n  /// @notice The claimed and early claimed states for a user per season\n  mapping(address user => mapping(uint256 seasonId => UserState)) private s_userStates;\n\n  /// @notice The global states for a season\n  mapping(uint256 seasonId => GlobalState globalState) private s_globalStates;\n\n  /// @notice The project token\n  IERC20 private immutable i_token;\n\n  /// @notice The factory that deployed this contract\n  BUILDFactory private immutable i_factory;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @notice constructor\n  /// @param token The project token\n  constructor(\n    address token\n  ) {\n    i_token = IERC20(token);\n    i_factory = BUILDFactory(msg.sender);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getFactory() external view override returns (BUILDFactory) {\n    return i_factory;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getToken() external view override returns (IERC20) {\n    return i_token;\n  }\n\n  /// @inheritdoc IERC165\n  function supportsInterface(\n    bytes4 interfaceId\n  ) external pure override returns (bool) {\n    return interfaceId == type(IBUILDClaim).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  // ================================================================\n  // |                        Token Deposits                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function deposit(\n    uint256 amount\n  ) external override nonReentrant whenClaimNotPaused onlyProjectAdmin {\n    // only callable when factory contract is open\n    if (!i_factory.isOpen()) {\n      revert Closable.AlreadyClosed();\n    }\n\n    uint256 balanceBefore = i_token.balanceOf(address(this));\n    uint256 totalDeposited = i_factory.addTotalDeposited(address(i_token), amount);\n    i_token.safeTransferFrom(msg.sender, address(this), amount);\n    uint256 balanceAfter = i_token.balanceOf(address(this));\n    if (balanceBefore + amount != balanceAfter) {\n      revert InvalidDeposit(balanceBefore, balanceAfter);\n    }\n\n    emit Deposited(address(i_token), msg.sender, amount, totalDeposited);\n  }\n\n  // ================================================================\n  // |                       Token Withdrawals                      |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function withdraw() external override nonReentrant onlyProjectAdmin {\n    (IBUILDFactory.Withdrawal memory withdrawal, uint256 totalWithdrawn) =\n      i_factory.executeWithdraw(address(i_token));\n    i_token.safeTransfer(withdrawal.recipient, withdrawal.amount);\n    emit Withdrawn(address(i_token), withdrawal.recipient, withdrawal.amount, totalWithdrawn);\n  }\n\n  // ================================================================\n  // |                         Token Claims                         |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function claim(\n    address user,\n    ClaimParams[] calldata params\n  ) external override nonReentrant whenClaimNotPaused {\n    _claim(user, params);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getGlobalState(\n    uint256 seasonId\n  ) external view returns (GlobalState memory) {\n    return s_globalStates[seasonId];\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getUserState(\n    UserSeasonId[] calldata usersAndSeasonIds\n  ) external view returns (UserState[] memory) {\n    uint256 count = usersAndSeasonIds.length;\n    UserState[] memory states = new UserState[](count);\n    for (uint256 i; i < count; ++i) {\n      states[i] = s_userStates[usersAndSeasonIds[i].user][usersAndSeasonIds[i].seasonId];\n    }\n    return states;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getCurrentClaimValues(\n    address user,\n    uint256 seasonId,\n    uint256 maxTokenAmount\n  ) external view returns (ClaimableState memory) {\n    (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n      i_factory.getProjectSeasonConfig(address(i_token), seasonId);\n    UnlockState memory unlockState =\n      _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n    return _getClaimableState(\n      config, s_globalStates[seasonId], s_userStates[user][seasonId], unlockState, maxTokenAmount\n    );\n  }\n\n  /// @notice Validates if the user is eligible to claim the amount of tokens for a season\n  /// A merkle tree's leaf consists of a user address, their max token amount for the season and a\n  /// salt\n  /// @param root The merkle root of a season\n  /// @param user The user's address\n  /// @param proof The merkle proof of the user's address, max token amount and salt\n  /// @param maxTokenAmount The user's total claimable token amount for the season\n  /// @param isEarlyClaim Whether the user is claiming early\n  /// @param salt A randomly generated salt to prevent brute-force guessing of merkle proofs\n  /// @return bool Returns true if the user's proof, maxTokenAmount and salt are valid\n  function _verifyMerkleProof(\n    bytes32 root,\n    address user,\n    bytes32[] memory proof,\n    uint256 maxTokenAmount,\n    bool isEarlyClaim,\n    uint256 salt\n  ) private pure returns (bool) {\n    bytes32 leaf =\n      keccak256(bytes.concat(keccak256(abi.encode(user, maxTokenAmount, isEarlyClaim, salt))));\n    return MerkleProof.verify(proof, root, leaf);\n  }\n\n  /// @notice Calculates the amount of tokens that can be claimed by a user for a season\n  /// without requiring an early claim at a particular timestamp.\n  /// This amount is the sum of the base tokens amount that is released all at once after the\n  /// unlock delay and the unlocked amount that is released linearly over the unlock duration.\n  /// This does not factor in any claimed amounts\n  /// @param config The project season config\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param unlockState The unlock state for the season\n  /// @param maxTokenAmount The maximum token amount for the user\n  /// @return ClaimableState The amount of tokens that can be claimed\n  function _getClaimableState(\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    IBUILDClaim.GlobalState memory globalState,\n    UserState memory userState,\n    UnlockState memory unlockState,\n    uint256 maxTokenAmount\n  ) internal pure returns (ClaimableState memory) {\n    ClaimableState memory claimableState;\n    claimableState.base =\n      (maxTokenAmount * config.baseTokenClaimBps) / PERCENTAGE_BASIS_POINTS_DENOMINATOR;\n    claimableState.bonus = maxTokenAmount - claimableState.base;\n\n    if (config.tokenAmount == 0 || (config.isRefunding && userState.claimed == 0)) {\n      return claimableState;\n    }\n\n    claimableState.claimed = userState.claimed;\n\n    if (userState.hasEarlyClaimed || unlockState.isBeforeUnlock) return claimableState;\n    // calculate share of loyalty pool to receive\n    // The loyalty bonus is informative only in the unlock period, as it is not\n    // claimable until the vesting is completed.\n    claimableState.loyaltyBonus = maxTokenAmount * globalState.totalLoyalty\n      / (config.tokenAmount - globalState.totalLoyaltyIneligible);\n\n    if (unlockState.isUnlocking) {\n      // unlock period is in progress\n      claimableState.vested =\n        (claimableState.bonus * unlockState.unlockElapsedDuration) / config.unlockDuration;\n      claimableState.claimable =\n        claimableState.base + claimableState.vested - claimableState.claimed;\n      claimableState.earlyVestableBonus =\n        _calcEarlyVestableBonus(claimableState, config, unlockState.unlockElapsedDuration);\n    } else {\n      // unlock completed\n      claimableState.claimable =\n        maxTokenAmount + claimableState.loyaltyBonus - claimableState.claimed;\n    }\n\n    return claimableState;\n  }\n\n  /// @notice Calculates the amount of bonus tokens that can be claimed early\n  /// @param claimableState The claimable state for the user\n  /// @param config The project season config\n  /// @param timeElapsed The amount of time that has elapsed since the unlock delay started\n  /// @return uint256 The amount of bonus tokens that can be claimed early\n  function _calcEarlyVestableBonus(\n    ClaimableState memory claimableState,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 timeElapsed\n  ) private pure returns (uint256) {\n    return FixedPointMathLib.mulWadDown(\n      claimableState.bonus - claimableState.vested,\n      FixedPointMathLib.divWadDown(config.earlyVestRatioMinBps, PERCENTAGE_BASIS_POINTS_DENOMINATOR)\n        + (\n          FixedPointMathLib.divWadDown(\n            config.earlyVestRatioMaxBps - config.earlyVestRatioMinBps,\n            PERCENTAGE_BASIS_POINTS_DENOMINATOR\n          ) * timeElapsed\n        ) / config.unlockDuration\n    );\n  }\n\n  /// @notice Returns the unlock progress for a season\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockDelay The delay before the unlock period starts\n  /// @param unlockDuration The duration of the unlock period\n  /// @param targetTime The timestamp to evaluate the unlock progress at\n  /// @return UnlockState The unlock state for the target time\n  function _getUnlockState(\n    uint256 unlockStartsAt,\n    uint256 unlockDelay,\n    uint256 unlockDuration,\n    uint256 targetTime\n  ) internal pure returns (UnlockState memory) {\n    uint256 unlockDelayEndsAt = unlockStartsAt + unlockDelay;\n    if (targetTime < unlockDelayEndsAt) {\n      return UnlockState({isBeforeUnlock: true, isUnlocking: false, unlockElapsedDuration: 0});\n    }\n    return UnlockState({\n      isBeforeUnlock: false,\n      isUnlocking: targetTime < unlockDelayEndsAt + unlockDuration,\n      unlockElapsedDuration: targetTime - unlockDelayEndsAt\n    });\n  }\n\n  /// @notice Validates the claim parameters for a user\n  /// @param user The user address\n  /// @param userState The user state for the season\n  /// @param param The claim parameters for a user\n  /// @param config The project season config\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockState The unlock state for the season\n  /// @dev Reverts if the claim parameters are invalid\n  /// @dev Reverts if the unlock period has not started yet, including the configured unlock delay\n  /// @dev Reverts if the project season does not exist for the given token address\n  /// @dev Reverts if the user's proof is invalid\n  /// @dev Reverts if user attempts to earlyClaim after previously early claiming during the unlock\n  /// period\n  function _validateClaimParams(\n    address user,\n    UserState memory userState,\n    ClaimParams memory param,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 unlockStartsAt,\n    UnlockState memory unlockState\n  ) private view {\n    if (user == address(0)) {\n      revert InvalidUser(user);\n    }\n    if (unlockStartsAt == 0) {\n      revert IBUILDFactory.SeasonDoesNotExist(param.seasonId);\n    }\n    if (unlockState.isBeforeUnlock) {\n      revert UnlockNotStarted(param.seasonId);\n    }\n    if (config.tokenAmount == 0) {\n      revert IBUILDFactory.ProjectSeasonDoesNotExist(param.seasonId, address(i_token));\n    }\n    if (\n      !_verifyMerkleProof(\n        config.merkleRoot, user, param.proof, param.maxTokenAmount, param.isEarlyClaim, param.salt\n      )\n    ) {\n      revert InvalidMerkleProof();\n    }\n    if (unlockState.isUnlocking && param.isEarlyClaim && userState.hasEarlyClaimed) {\n      revert InvalidEarlyClaim(user, param.seasonId);\n    }\n    if (userState.claimed == 0 && config.isRefunding) {\n      // If the user hasn't claimed for this season before the refunding starts, the user will\n      // be refunded their allocated credits but can no longer claim tokens\n      revert IBUILDFactory.ProjectSeasonIsRefunding(address(i_token), param.seasonId);\n    }\n  }\n\n  /// @notice Util function that claims tokens for a user for multiple seasons\n  /// @param user The user address\n  /// @param params An array of claim params including the season ID, proof, and max token amount\n  /// for each season\n  function _claim(address user, ClaimParams[] memory params) private {\n    uint256 totalClaimableAmount;\n    bool isEarlyClaim = false;\n\n    // Cache array length outside loop\n    uint256 paramsLength = params.length;\n    for (uint256 i = 0; i < paramsLength; ++i) {\n      ClaimParams memory param = params[i];\n      if (param.isEarlyClaim) {\n        isEarlyClaim = true;\n      }\n      (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n        i_factory.getProjectSeasonConfig(address(i_token), param.seasonId);\n\n      UserState memory userState = s_userStates[user][param.seasonId];\n      UnlockState memory unlockState =\n        _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n\n      _validateClaimParams(user, userState, param, config, unlockStartsAt, unlockState);\n\n      if (userState.hasEarlyClaimed) {\n        continue;\n      }\n\n      GlobalState storage globalState = s_globalStates[param.seasonId];\n      ClaimableState memory claimableState =\n        _getClaimableState(config, globalState, userState, unlockState, param.maxTokenAmount);\n\n      // short-circuit on potential zero claim value before consuming refundable amount\n      // if regular claim, claimable must be > 0\n      // if early claim, earlyClaimable must be > 0\n      if (\n        (claimableState.claimable == 0 && !param.isEarlyClaim)\n          || (\n            claimableState.claimable == 0 && claimableState.earlyVestableBonus == 0\n              && param.isEarlyClaim\n          )\n      ) {\n        continue;\n      }\n\n      if (claimableState.claimed == 0) {\n        // User is claiming for the first time for this particular season, so the project can no\n        // longer reclaim the refundable amount for this user's credits\n        i_factory.reduceRefundableAmount(address(i_token), param.seasonId, param.maxTokenAmount);\n      }\n      uint256 toBeClaimed = claimableState.claimable;\n      if (unlockState.isUnlocking && param.isEarlyClaim) {\n        globalState.totalLoyalty +=\n          claimableState.bonus - claimableState.vested - claimableState.earlyVestableBonus;\n        globalState.totalLoyaltyIneligible += param.maxTokenAmount;\n        userState.hasEarlyClaimed = true;\n        toBeClaimed += claimableState.earlyVestableBonus;\n      }\n\n      totalClaimableAmount += toBeClaimed;\n      _updateClaimedAmounts(\n        user,\n        globalState,\n        userState,\n        param,\n        toBeClaimed,\n        param.isEarlyClaim ? claimableState.earlyVestableBonus : 0\n      );\n    }\n\n    if (isEarlyClaim && user != msg.sender) {\n      if (\n        !i_factory.getDelegateRegistry().checkDelegateForContract({\n          to: msg.sender,\n          from: user,\n          contract_: address(i_factory),\n          rights: bytes32(0)\n        })\n      ) {\n        revert InvalidSender(msg.sender);\n      }\n    }\n\n    if (totalClaimableAmount == 0) {\n      return;\n    }\n    i_token.safeTransfer(user, totalClaimableAmount);\n  }\n\n  /// @notice Updates the claimed amounts for a user and the season\n  /// @param user The user address\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param param The input parameters for the claim\n  /// @param toBeClaimed The amount of tokens to be claimed by the user\n  /// @param earlyVestableBonus The amount of bonus tokens that can be claimed early\n  /// @dev This function is called when a user claims tokens\n  function _updateClaimedAmounts(\n    address user,\n    GlobalState storage globalState,\n    UserState memory userState,\n    ClaimParams memory param,\n    uint256 toBeClaimed,\n    uint256 earlyVestableBonus\n  ) private {\n    userState.claimed += uint248(toBeClaimed);\n    s_userStates[user][param.seasonId] = userState;\n\n    globalState.totalClaimed += toBeClaimed;\n\n    emit Claimed(\n      user,\n      param.seasonId,\n      toBeClaimed,\n      param.isEarlyClaim,\n      earlyVestableBonus,\n      userState.claimed,\n      globalState.totalClaimed,\n      globalState.totalLoyalty,\n      globalState.totalLoyaltyIneligible\n    );\n  }\n\n  /// @notice Only callable by the factory contract admin\n  modifier onlyProjectAdmin() {\n    if (msg.sender != i_factory.getProjectConfig(address(i_token)).admin) {\n      revert IAccessControl.AccessControlUnauthorizedAccount(msg.sender, keccak256(\"PROJECT_ADMIN\"));\n    }\n    _;\n  }\n\n  /// @notice Only callable when claim contract is not paused\n  modifier whenClaimNotPaused() {\n    if (i_factory.isClaimContractPaused(address(i_token))) {\n      revert Pausable.EnforcedPause();\n    }\n    _;\n  }\n}", "modifiers": [], "stateMutability": "pure", "returnParameters": null, "visibility": "private", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol"}, {"type": "FunctionDefinition", "name": "BUILDClaim._getClaimableState", "start_line": 196, "end_line": 236, "offset_start": 7992, "offset_end": 9700, "content": "function _getClaimableState(\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    IBUILDClaim.GlobalState memory globalState,\n    UserState memory userState,\n    UnlockState memory unlockState,\n    uint256 maxTokenAmount\n  ) internal pure returns (ClaimableState memory) {\n    ClaimableState memory claimableState;\n    claimableState.base =\n      (maxTokenAmount * config.baseTokenClaimBps) / PERCENTAGE_BASIS_POINTS_DENOMINATOR;\n    claimableState.bonus = maxTokenAmount - claimableState.base;\n\n    if (config.tokenAmount == 0 || (config.isRefunding && userState.claimed == 0)) {\n      return claimableState;\n    }\n\n    claimableState.claimed = userState.claimed;\n\n    if (userState.hasEarlyClaimed || unlockState.isBeforeUnlock) return claimableState;\n    // calculate share of loyalty pool to receive\n    // The loyalty bonus is informative only in the unlock period, as it is not\n    // claimable until the vesting is completed.\n    claimableState.loyaltyBonus = maxTokenAmount * globalState.totalLoyalty\n      / (config.tokenAmount - globalState.totalLoyaltyIneligible);\n\n    if (unlockState.isUnlocking) {\n      // unlock period is in progress\n      claimableState.vested =\n        (claimableState.bonus * unlockState.unlockElapsedDuration) / config.unlockDuration;\n      claimableState.claimable =\n        claimableState.base + claimableState.vested - claimableState.claimed;\n      claimableState.earlyVestableBonus =\n        _calcEarlyVestableBonus(claimableState, config, unlockState.unlockElapsedDuration);\n    } else {\n      // unlock completed\n      claimableState.claimable =\n        maxTokenAmount + claimableState.loyaltyBonus - claimableState.claimed;\n    }\n\n    return claimableState;\n  }", "contract_name": "BUILDClaim", "contract_code": "{\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint256;\n\n  /// @notice The unlock state for a season at a given time\n  struct UnlockState {\n    uint256 unlockElapsedDuration; // The amount of time that has elapsed since\n      // the unlock delay started\n    bool isBeforeUnlock; // Whether the unlock period has started (including the delay)\n    bool isUnlocking; // Whether the unlock period is in progress\n  }\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDClaim 1.0.0\";\n\n  /// @notice The claimed and early claimed states for a user per season\n  mapping(address user => mapping(uint256 seasonId => UserState)) private s_userStates;\n\n  /// @notice The global states for a season\n  mapping(uint256 seasonId => GlobalState globalState) private s_globalStates;\n\n  /// @notice The project token\n  IERC20 private immutable i_token;\n\n  /// @notice The factory that deployed this contract\n  BUILDFactory private immutable i_factory;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @notice constructor\n  /// @param token The project token\n  constructor(\n    address token\n  ) {\n    i_token = IERC20(token);\n    i_factory = BUILDFactory(msg.sender);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getFactory() external view override returns (BUILDFactory) {\n    return i_factory;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getToken() external view override returns (IERC20) {\n    return i_token;\n  }\n\n  /// @inheritdoc IERC165\n  function supportsInterface(\n    bytes4 interfaceId\n  ) external pure override returns (bool) {\n    return interfaceId == type(IBUILDClaim).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  // ================================================================\n  // |                        Token Deposits                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function deposit(\n    uint256 amount\n  ) external override nonReentrant whenClaimNotPaused onlyProjectAdmin {\n    // only callable when factory contract is open\n    if (!i_factory.isOpen()) {\n      revert Closable.AlreadyClosed();\n    }\n\n    uint256 balanceBefore = i_token.balanceOf(address(this));\n    uint256 totalDeposited = i_factory.addTotalDeposited(address(i_token), amount);\n    i_token.safeTransferFrom(msg.sender, address(this), amount);\n    uint256 balanceAfter = i_token.balanceOf(address(this));\n    if (balanceBefore + amount != balanceAfter) {\n      revert InvalidDeposit(balanceBefore, balanceAfter);\n    }\n\n    emit Deposited(address(i_token), msg.sender, amount, totalDeposited);\n  }\n\n  // ================================================================\n  // |                       Token Withdrawals                      |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function withdraw() external override nonReentrant onlyProjectAdmin {\n    (IBUILDFactory.Withdrawal memory withdrawal, uint256 totalWithdrawn) =\n      i_factory.executeWithdraw(address(i_token));\n    i_token.safeTransfer(withdrawal.recipient, withdrawal.amount);\n    emit Withdrawn(address(i_token), withdrawal.recipient, withdrawal.amount, totalWithdrawn);\n  }\n\n  // ================================================================\n  // |                         Token Claims                         |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function claim(\n    address user,\n    ClaimParams[] calldata params\n  ) external override nonReentrant whenClaimNotPaused {\n    _claim(user, params);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getGlobalState(\n    uint256 seasonId\n  ) external view returns (GlobalState memory) {\n    return s_globalStates[seasonId];\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getUserState(\n    UserSeasonId[] calldata usersAndSeasonIds\n  ) external view returns (UserState[] memory) {\n    uint256 count = usersAndSeasonIds.length;\n    UserState[] memory states = new UserState[](count);\n    for (uint256 i; i < count; ++i) {\n      states[i] = s_userStates[usersAndSeasonIds[i].user][usersAndSeasonIds[i].seasonId];\n    }\n    return states;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getCurrentClaimValues(\n    address user,\n    uint256 seasonId,\n    uint256 maxTokenAmount\n  ) external view returns (ClaimableState memory) {\n    (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n      i_factory.getProjectSeasonConfig(address(i_token), seasonId);\n    UnlockState memory unlockState =\n      _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n    return _getClaimableState(\n      config, s_globalStates[seasonId], s_userStates[user][seasonId], unlockState, maxTokenAmount\n    );\n  }\n\n  /// @notice Validates if the user is eligible to claim the amount of tokens for a season\n  /// A merkle tree's leaf consists of a user address, their max token amount for the season and a\n  /// salt\n  /// @param root The merkle root of a season\n  /// @param user The user's address\n  /// @param proof The merkle proof of the user's address, max token amount and salt\n  /// @param maxTokenAmount The user's total claimable token amount for the season\n  /// @param isEarlyClaim Whether the user is claiming early\n  /// @param salt A randomly generated salt to prevent brute-force guessing of merkle proofs\n  /// @return bool Returns true if the user's proof, maxTokenAmount and salt are valid\n  function _verifyMerkleProof(\n    bytes32 root,\n    address user,\n    bytes32[] memory proof,\n    uint256 maxTokenAmount,\n    bool isEarlyClaim,\n    uint256 salt\n  ) private pure returns (bool) {\n    bytes32 leaf =\n      keccak256(bytes.concat(keccak256(abi.encode(user, maxTokenAmount, isEarlyClaim, salt))));\n    return MerkleProof.verify(proof, root, leaf);\n  }\n\n  /// @notice Calculates the amount of tokens that can be claimed by a user for a season\n  /// without requiring an early claim at a particular timestamp.\n  /// This amount is the sum of the base tokens amount that is released all at once after the\n  /// unlock delay and the unlocked amount that is released linearly over the unlock duration.\n  /// This does not factor in any claimed amounts\n  /// @param config The project season config\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param unlockState The unlock state for the season\n  /// @param maxTokenAmount The maximum token amount for the user\n  /// @return ClaimableState The amount of tokens that can be claimed\n  function _getClaimableState(\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    IBUILDClaim.GlobalState memory globalState,\n    UserState memory userState,\n    UnlockState memory unlockState,\n    uint256 maxTokenAmount\n  ) internal pure returns (ClaimableState memory) {\n    ClaimableState memory claimableState;\n    claimableState.base =\n      (maxTokenAmount * config.baseTokenClaimBps) / PERCENTAGE_BASIS_POINTS_DENOMINATOR;\n    claimableState.bonus = maxTokenAmount - claimableState.base;\n\n    if (config.tokenAmount == 0 || (config.isRefunding && userState.claimed == 0)) {\n      return claimableState;\n    }\n\n    claimableState.claimed = userState.claimed;\n\n    if (userState.hasEarlyClaimed || unlockState.isBeforeUnlock) return claimableState;\n    // calculate share of loyalty pool to receive\n    // The loyalty bonus is informative only in the unlock period, as it is not\n    // claimable until the vesting is completed.\n    claimableState.loyaltyBonus = maxTokenAmount * globalState.totalLoyalty\n      / (config.tokenAmount - globalState.totalLoyaltyIneligible);\n\n    if (unlockState.isUnlocking) {\n      // unlock period is in progress\n      claimableState.vested =\n        (claimableState.bonus * unlockState.unlockElapsedDuration) / config.unlockDuration;\n      claimableState.claimable =\n        claimableState.base + claimableState.vested - claimableState.claimed;\n      claimableState.earlyVestableBonus =\n        _calcEarlyVestableBonus(claimableState, config, unlockState.unlockElapsedDuration);\n    } else {\n      // unlock completed\n      claimableState.claimable =\n        maxTokenAmount + claimableState.loyaltyBonus - claimableState.claimed;\n    }\n\n    return claimableState;\n  }\n\n  /// @notice Calculates the amount of bonus tokens that can be claimed early\n  /// @param claimableState The claimable state for the user\n  /// @param config The project season config\n  /// @param timeElapsed The amount of time that has elapsed since the unlock delay started\n  /// @return uint256 The amount of bonus tokens that can be claimed early\n  function _calcEarlyVestableBonus(\n    ClaimableState memory claimableState,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 timeElapsed\n  ) private pure returns (uint256) {\n    return FixedPointMathLib.mulWadDown(\n      claimableState.bonus - claimableState.vested,\n      FixedPointMathLib.divWadDown(config.earlyVestRatioMinBps, PERCENTAGE_BASIS_POINTS_DENOMINATOR)\n        + (\n          FixedPointMathLib.divWadDown(\n            config.earlyVestRatioMaxBps - config.earlyVestRatioMinBps,\n            PERCENTAGE_BASIS_POINTS_DENOMINATOR\n          ) * timeElapsed\n        ) / config.unlockDuration\n    );\n  }\n\n  /// @notice Returns the unlock progress for a season\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockDelay The delay before the unlock period starts\n  /// @param unlockDuration The duration of the unlock period\n  /// @param targetTime The timestamp to evaluate the unlock progress at\n  /// @return UnlockState The unlock state for the target time\n  function _getUnlockState(\n    uint256 unlockStartsAt,\n    uint256 unlockDelay,\n    uint256 unlockDuration,\n    uint256 targetTime\n  ) internal pure returns (UnlockState memory) {\n    uint256 unlockDelayEndsAt = unlockStartsAt + unlockDelay;\n    if (targetTime < unlockDelayEndsAt) {\n      return UnlockState({isBeforeUnlock: true, isUnlocking: false, unlockElapsedDuration: 0});\n    }\n    return UnlockState({\n      isBeforeUnlock: false,\n      isUnlocking: targetTime < unlockDelayEndsAt + unlockDuration,\n      unlockElapsedDuration: targetTime - unlockDelayEndsAt\n    });\n  }\n\n  /// @notice Validates the claim parameters for a user\n  /// @param user The user address\n  /// @param userState The user state for the season\n  /// @param param The claim parameters for a user\n  /// @param config The project season config\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockState The unlock state for the season\n  /// @dev Reverts if the claim parameters are invalid\n  /// @dev Reverts if the unlock period has not started yet, including the configured unlock delay\n  /// @dev Reverts if the project season does not exist for the given token address\n  /// @dev Reverts if the user's proof is invalid\n  /// @dev Reverts if user attempts to earlyClaim after previously early claiming during the unlock\n  /// period\n  function _validateClaimParams(\n    address user,\n    UserState memory userState,\n    ClaimParams memory param,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 unlockStartsAt,\n    UnlockState memory unlockState\n  ) private view {\n    if (user == address(0)) {\n      revert InvalidUser(user);\n    }\n    if (unlockStartsAt == 0) {\n      revert IBUILDFactory.SeasonDoesNotExist(param.seasonId);\n    }\n    if (unlockState.isBeforeUnlock) {\n      revert UnlockNotStarted(param.seasonId);\n    }\n    if (config.tokenAmount == 0) {\n      revert IBUILDFactory.ProjectSeasonDoesNotExist(param.seasonId, address(i_token));\n    }\n    if (\n      !_verifyMerkleProof(\n        config.merkleRoot, user, param.proof, param.maxTokenAmount, param.isEarlyClaim, param.salt\n      )\n    ) {\n      revert InvalidMerkleProof();\n    }\n    if (unlockState.isUnlocking && param.isEarlyClaim && userState.hasEarlyClaimed) {\n      revert InvalidEarlyClaim(user, param.seasonId);\n    }\n    if (userState.claimed == 0 && config.isRefunding) {\n      // If the user hasn't claimed for this season before the refunding starts, the user will\n      // be refunded their allocated credits but can no longer claim tokens\n      revert IBUILDFactory.ProjectSeasonIsRefunding(address(i_token), param.seasonId);\n    }\n  }\n\n  /// @notice Util function that claims tokens for a user for multiple seasons\n  /// @param user The user address\n  /// @param params An array of claim params including the season ID, proof, and max token amount\n  /// for each season\n  function _claim(address user, ClaimParams[] memory params) private {\n    uint256 totalClaimableAmount;\n    bool isEarlyClaim = false;\n\n    // Cache array length outside loop\n    uint256 paramsLength = params.length;\n    for (uint256 i = 0; i < paramsLength; ++i) {\n      ClaimParams memory param = params[i];\n      if (param.isEarlyClaim) {\n        isEarlyClaim = true;\n      }\n      (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n        i_factory.getProjectSeasonConfig(address(i_token), param.seasonId);\n\n      UserState memory userState = s_userStates[user][param.seasonId];\n      UnlockState memory unlockState =\n        _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n\n      _validateClaimParams(user, userState, param, config, unlockStartsAt, unlockState);\n\n      if (userState.hasEarlyClaimed) {\n        continue;\n      }\n\n      GlobalState storage globalState = s_globalStates[param.seasonId];\n      ClaimableState memory claimableState =\n        _getClaimableState(config, globalState, userState, unlockState, param.maxTokenAmount);\n\n      // short-circuit on potential zero claim value before consuming refundable amount\n      // if regular claim, claimable must be > 0\n      // if early claim, earlyClaimable must be > 0\n      if (\n        (claimableState.claimable == 0 && !param.isEarlyClaim)\n          || (\n            claimableState.claimable == 0 && claimableState.earlyVestableBonus == 0\n              && param.isEarlyClaim\n          )\n      ) {\n        continue;\n      }\n\n      if (claimableState.claimed == 0) {\n        // User is claiming for the first time for this particular season, so the project can no\n        // longer reclaim the refundable amount for this user's credits\n        i_factory.reduceRefundableAmount(address(i_token), param.seasonId, param.maxTokenAmount);\n      }\n      uint256 toBeClaimed = claimableState.claimable;\n      if (unlockState.isUnlocking && param.isEarlyClaim) {\n        globalState.totalLoyalty +=\n          claimableState.bonus - claimableState.vested - claimableState.earlyVestableBonus;\n        globalState.totalLoyaltyIneligible += param.maxTokenAmount;\n        userState.hasEarlyClaimed = true;\n        toBeClaimed += claimableState.earlyVestableBonus;\n      }\n\n      totalClaimableAmount += toBeClaimed;\n      _updateClaimedAmounts(\n        user,\n        globalState,\n        userState,\n        param,\n        toBeClaimed,\n        param.isEarlyClaim ? claimableState.earlyVestableBonus : 0\n      );\n    }\n\n    if (isEarlyClaim && user != msg.sender) {\n      if (\n        !i_factory.getDelegateRegistry().checkDelegateForContract({\n          to: msg.sender,\n          from: user,\n          contract_: address(i_factory),\n          rights: bytes32(0)\n        })\n      ) {\n        revert InvalidSender(msg.sender);\n      }\n    }\n\n    if (totalClaimableAmount == 0) {\n      return;\n    }\n    i_token.safeTransfer(user, totalClaimableAmount);\n  }\n\n  /// @notice Updates the claimed amounts for a user and the season\n  /// @param user The user address\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param param The input parameters for the claim\n  /// @param toBeClaimed The amount of tokens to be claimed by the user\n  /// @param earlyVestableBonus The amount of bonus tokens that can be claimed early\n  /// @dev This function is called when a user claims tokens\n  function _updateClaimedAmounts(\n    address user,\n    GlobalState storage globalState,\n    UserState memory userState,\n    ClaimParams memory param,\n    uint256 toBeClaimed,\n    uint256 earlyVestableBonus\n  ) private {\n    userState.claimed += uint248(toBeClaimed);\n    s_userStates[user][param.seasonId] = userState;\n\n    globalState.totalClaimed += toBeClaimed;\n\n    emit Claimed(\n      user,\n      param.seasonId,\n      toBeClaimed,\n      param.isEarlyClaim,\n      earlyVestableBonus,\n      userState.claimed,\n      globalState.totalClaimed,\n      globalState.totalLoyalty,\n      globalState.totalLoyaltyIneligible\n    );\n  }\n\n  /// @notice Only callable by the factory contract admin\n  modifier onlyProjectAdmin() {\n    if (msg.sender != i_factory.getProjectConfig(address(i_token)).admin) {\n      revert IAccessControl.AccessControlUnauthorizedAccount(msg.sender, keccak256(\"PROJECT_ADMIN\"));\n    }\n    _;\n  }\n\n  /// @notice Only callable when claim contract is not paused\n  modifier whenClaimNotPaused() {\n    if (i_factory.isClaimContractPaused(address(i_token))) {\n      revert Pausable.EnforcedPause();\n    }\n    _;\n  }\n}", "modifiers": [], "stateMutability": "pure", "returnParameters": null, "visibility": "internal", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol"}, {"type": "FunctionDefinition", "name": "BUILDClaim._calcEarlyVestableBonus", "start_line": 243, "end_line": 258, "offset_start": 10057, "offset_end": 10681, "content": "function _calcEarlyVestableBonus(\n    ClaimableState memory claimableState,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 timeElapsed\n  ) private pure returns (uint256) {\n    return FixedPointMathLib.mulWadDown(\n      claimableState.bonus - claimableState.vested,\n      FixedPointMathLib.divWadDown(config.earlyVestRatioMinBps, PERCENTAGE_BASIS_POINTS_DENOMINATOR)\n        + (\n          FixedPointMathLib.divWadDown(\n            config.earlyVestRatioMaxBps - config.earlyVestRatioMinBps,\n            PERCENTAGE_BASIS_POINTS_DENOMINATOR\n          ) * timeElapsed\n        ) / config.unlockDuration\n    );\n  }", "contract_name": "BUILDClaim", "contract_code": "{\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint256;\n\n  /// @notice The unlock state for a season at a given time\n  struct UnlockState {\n    uint256 unlockElapsedDuration; // The amount of time that has elapsed since\n      // the unlock delay started\n    bool isBeforeUnlock; // Whether the unlock period has started (including the delay)\n    bool isUnlocking; // Whether the unlock period is in progress\n  }\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDClaim 1.0.0\";\n\n  /// @notice The claimed and early claimed states for a user per season\n  mapping(address user => mapping(uint256 seasonId => UserState)) private s_userStates;\n\n  /// @notice The global states for a season\n  mapping(uint256 seasonId => GlobalState globalState) private s_globalStates;\n\n  /// @notice The project token\n  IERC20 private immutable i_token;\n\n  /// @notice The factory that deployed this contract\n  BUILDFactory private immutable i_factory;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @notice constructor\n  /// @param token The project token\n  constructor(\n    address token\n  ) {\n    i_token = IERC20(token);\n    i_factory = BUILDFactory(msg.sender);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getFactory() external view override returns (BUILDFactory) {\n    return i_factory;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getToken() external view override returns (IERC20) {\n    return i_token;\n  }\n\n  /// @inheritdoc IERC165\n  function supportsInterface(\n    bytes4 interfaceId\n  ) external pure override returns (bool) {\n    return interfaceId == type(IBUILDClaim).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  // ================================================================\n  // |                        Token Deposits                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function deposit(\n    uint256 amount\n  ) external override nonReentrant whenClaimNotPaused onlyProjectAdmin {\n    // only callable when factory contract is open\n    if (!i_factory.isOpen()) {\n      revert Closable.AlreadyClosed();\n    }\n\n    uint256 balanceBefore = i_token.balanceOf(address(this));\n    uint256 totalDeposited = i_factory.addTotalDeposited(address(i_token), amount);\n    i_token.safeTransferFrom(msg.sender, address(this), amount);\n    uint256 balanceAfter = i_token.balanceOf(address(this));\n    if (balanceBefore + amount != balanceAfter) {\n      revert InvalidDeposit(balanceBefore, balanceAfter);\n    }\n\n    emit Deposited(address(i_token), msg.sender, amount, totalDeposited);\n  }\n\n  // ================================================================\n  // |                       Token Withdrawals                      |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function withdraw() external override nonReentrant onlyProjectAdmin {\n    (IBUILDFactory.Withdrawal memory withdrawal, uint256 totalWithdrawn) =\n      i_factory.executeWithdraw(address(i_token));\n    i_token.safeTransfer(withdrawal.recipient, withdrawal.amount);\n    emit Withdrawn(address(i_token), withdrawal.recipient, withdrawal.amount, totalWithdrawn);\n  }\n\n  // ================================================================\n  // |                         Token Claims                         |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function claim(\n    address user,\n    ClaimParams[] calldata params\n  ) external override nonReentrant whenClaimNotPaused {\n    _claim(user, params);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getGlobalState(\n    uint256 seasonId\n  ) external view returns (GlobalState memory) {\n    return s_globalStates[seasonId];\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getUserState(\n    UserSeasonId[] calldata usersAndSeasonIds\n  ) external view returns (UserState[] memory) {\n    uint256 count = usersAndSeasonIds.length;\n    UserState[] memory states = new UserState[](count);\n    for (uint256 i; i < count; ++i) {\n      states[i] = s_userStates[usersAndSeasonIds[i].user][usersAndSeasonIds[i].seasonId];\n    }\n    return states;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getCurrentClaimValues(\n    address user,\n    uint256 seasonId,\n    uint256 maxTokenAmount\n  ) external view returns (ClaimableState memory) {\n    (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n      i_factory.getProjectSeasonConfig(address(i_token), seasonId);\n    UnlockState memory unlockState =\n      _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n    return _getClaimableState(\n      config, s_globalStates[seasonId], s_userStates[user][seasonId], unlockState, maxTokenAmount\n    );\n  }\n\n  /// @notice Validates if the user is eligible to claim the amount of tokens for a season\n  /// A merkle tree's leaf consists of a user address, their max token amount for the season and a\n  /// salt\n  /// @param root The merkle root of a season\n  /// @param user The user's address\n  /// @param proof The merkle proof of the user's address, max token amount and salt\n  /// @param maxTokenAmount The user's total claimable token amount for the season\n  /// @param isEarlyClaim Whether the user is claiming early\n  /// @param salt A randomly generated salt to prevent brute-force guessing of merkle proofs\n  /// @return bool Returns true if the user's proof, maxTokenAmount and salt are valid\n  function _verifyMerkleProof(\n    bytes32 root,\n    address user,\n    bytes32[] memory proof,\n    uint256 maxTokenAmount,\n    bool isEarlyClaim,\n    uint256 salt\n  ) private pure returns (bool) {\n    bytes32 leaf =\n      keccak256(bytes.concat(keccak256(abi.encode(user, maxTokenAmount, isEarlyClaim, salt))));\n    return MerkleProof.verify(proof, root, leaf);\n  }\n\n  /// @notice Calculates the amount of tokens that can be claimed by a user for a season\n  /// without requiring an early claim at a particular timestamp.\n  /// This amount is the sum of the base tokens amount that is released all at once after the\n  /// unlock delay and the unlocked amount that is released linearly over the unlock duration.\n  /// This does not factor in any claimed amounts\n  /// @param config The project season config\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param unlockState The unlock state for the season\n  /// @param maxTokenAmount The maximum token amount for the user\n  /// @return ClaimableState The amount of tokens that can be claimed\n  function _getClaimableState(\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    IBUILDClaim.GlobalState memory globalState,\n    UserState memory userState,\n    UnlockState memory unlockState,\n    uint256 maxTokenAmount\n  ) internal pure returns (ClaimableState memory) {\n    ClaimableState memory claimableState;\n    claimableState.base =\n      (maxTokenAmount * config.baseTokenClaimBps) / PERCENTAGE_BASIS_POINTS_DENOMINATOR;\n    claimableState.bonus = maxTokenAmount - claimableState.base;\n\n    if (config.tokenAmount == 0 || (config.isRefunding && userState.claimed == 0)) {\n      return claimableState;\n    }\n\n    claimableState.claimed = userState.claimed;\n\n    if (userState.hasEarlyClaimed || unlockState.isBeforeUnlock) return claimableState;\n    // calculate share of loyalty pool to receive\n    // The loyalty bonus is informative only in the unlock period, as it is not\n    // claimable until the vesting is completed.\n    claimableState.loyaltyBonus = maxTokenAmount * globalState.totalLoyalty\n      / (config.tokenAmount - globalState.totalLoyaltyIneligible);\n\n    if (unlockState.isUnlocking) {\n      // unlock period is in progress\n      claimableState.vested =\n        (claimableState.bonus * unlockState.unlockElapsedDuration) / config.unlockDuration;\n      claimableState.claimable =\n        claimableState.base + claimableState.vested - claimableState.claimed;\n      claimableState.earlyVestableBonus =\n        _calcEarlyVestableBonus(claimableState, config, unlockState.unlockElapsedDuration);\n    } else {\n      // unlock completed\n      claimableState.claimable =\n        maxTokenAmount + claimableState.loyaltyBonus - claimableState.claimed;\n    }\n\n    return claimableState;\n  }\n\n  /// @notice Calculates the amount of bonus tokens that can be claimed early\n  /// @param claimableState The claimable state for the user\n  /// @param config The project season config\n  /// @param timeElapsed The amount of time that has elapsed since the unlock delay started\n  /// @return uint256 The amount of bonus tokens that can be claimed early\n  function _calcEarlyVestableBonus(\n    ClaimableState memory claimableState,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 timeElapsed\n  ) private pure returns (uint256) {\n    return FixedPointMathLib.mulWadDown(\n      claimableState.bonus - claimableState.vested,\n      FixedPointMathLib.divWadDown(config.earlyVestRatioMinBps, PERCENTAGE_BASIS_POINTS_DENOMINATOR)\n        + (\n          FixedPointMathLib.divWadDown(\n            config.earlyVestRatioMaxBps - config.earlyVestRatioMinBps,\n            PERCENTAGE_BASIS_POINTS_DENOMINATOR\n          ) * timeElapsed\n        ) / config.unlockDuration\n    );\n  }\n\n  /// @notice Returns the unlock progress for a season\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockDelay The delay before the unlock period starts\n  /// @param unlockDuration The duration of the unlock period\n  /// @param targetTime The timestamp to evaluate the unlock progress at\n  /// @return UnlockState The unlock state for the target time\n  function _getUnlockState(\n    uint256 unlockStartsAt,\n    uint256 unlockDelay,\n    uint256 unlockDuration,\n    uint256 targetTime\n  ) internal pure returns (UnlockState memory) {\n    uint256 unlockDelayEndsAt = unlockStartsAt + unlockDelay;\n    if (targetTime < unlockDelayEndsAt) {\n      return UnlockState({isBeforeUnlock: true, isUnlocking: false, unlockElapsedDuration: 0});\n    }\n    return UnlockState({\n      isBeforeUnlock: false,\n      isUnlocking: targetTime < unlockDelayEndsAt + unlockDuration,\n      unlockElapsedDuration: targetTime - unlockDelayEndsAt\n    });\n  }\n\n  /// @notice Validates the claim parameters for a user\n  /// @param user The user address\n  /// @param userState The user state for the season\n  /// @param param The claim parameters for a user\n  /// @param config The project season config\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockState The unlock state for the season\n  /// @dev Reverts if the claim parameters are invalid\n  /// @dev Reverts if the unlock period has not started yet, including the configured unlock delay\n  /// @dev Reverts if the project season does not exist for the given token address\n  /// @dev Reverts if the user's proof is invalid\n  /// @dev Reverts if user attempts to earlyClaim after previously early claiming during the unlock\n  /// period\n  function _validateClaimParams(\n    address user,\n    UserState memory userState,\n    ClaimParams memory param,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 unlockStartsAt,\n    UnlockState memory unlockState\n  ) private view {\n    if (user == address(0)) {\n      revert InvalidUser(user);\n    }\n    if (unlockStartsAt == 0) {\n      revert IBUILDFactory.SeasonDoesNotExist(param.seasonId);\n    }\n    if (unlockState.isBeforeUnlock) {\n      revert UnlockNotStarted(param.seasonId);\n    }\n    if (config.tokenAmount == 0) {\n      revert IBUILDFactory.ProjectSeasonDoesNotExist(param.seasonId, address(i_token));\n    }\n    if (\n      !_verifyMerkleProof(\n        config.merkleRoot, user, param.proof, param.maxTokenAmount, param.isEarlyClaim, param.salt\n      )\n    ) {\n      revert InvalidMerkleProof();\n    }\n    if (unlockState.isUnlocking && param.isEarlyClaim && userState.hasEarlyClaimed) {\n      revert InvalidEarlyClaim(user, param.seasonId);\n    }\n    if (userState.claimed == 0 && config.isRefunding) {\n      // If the user hasn't claimed for this season before the refunding starts, the user will\n      // be refunded their allocated credits but can no longer claim tokens\n      revert IBUILDFactory.ProjectSeasonIsRefunding(address(i_token), param.seasonId);\n    }\n  }\n\n  /// @notice Util function that claims tokens for a user for multiple seasons\n  /// @param user The user address\n  /// @param params An array of claim params including the season ID, proof, and max token amount\n  /// for each season\n  function _claim(address user, ClaimParams[] memory params) private {\n    uint256 totalClaimableAmount;\n    bool isEarlyClaim = false;\n\n    // Cache array length outside loop\n    uint256 paramsLength = params.length;\n    for (uint256 i = 0; i < paramsLength; ++i) {\n      ClaimParams memory param = params[i];\n      if (param.isEarlyClaim) {\n        isEarlyClaim = true;\n      }\n      (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n        i_factory.getProjectSeasonConfig(address(i_token), param.seasonId);\n\n      UserState memory userState = s_userStates[user][param.seasonId];\n      UnlockState memory unlockState =\n        _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n\n      _validateClaimParams(user, userState, param, config, unlockStartsAt, unlockState);\n\n      if (userState.hasEarlyClaimed) {\n        continue;\n      }\n\n      GlobalState storage globalState = s_globalStates[param.seasonId];\n      ClaimableState memory claimableState =\n        _getClaimableState(config, globalState, userState, unlockState, param.maxTokenAmount);\n\n      // short-circuit on potential zero claim value before consuming refundable amount\n      // if regular claim, claimable must be > 0\n      // if early claim, earlyClaimable must be > 0\n      if (\n        (claimableState.claimable == 0 && !param.isEarlyClaim)\n          || (\n            claimableState.claimable == 0 && claimableState.earlyVestableBonus == 0\n              && param.isEarlyClaim\n          )\n      ) {\n        continue;\n      }\n\n      if (claimableState.claimed == 0) {\n        // User is claiming for the first time for this particular season, so the project can no\n        // longer reclaim the refundable amount for this user's credits\n        i_factory.reduceRefundableAmount(address(i_token), param.seasonId, param.maxTokenAmount);\n      }\n      uint256 toBeClaimed = claimableState.claimable;\n      if (unlockState.isUnlocking && param.isEarlyClaim) {\n        globalState.totalLoyalty +=\n          claimableState.bonus - claimableState.vested - claimableState.earlyVestableBonus;\n        globalState.totalLoyaltyIneligible += param.maxTokenAmount;\n        userState.hasEarlyClaimed = true;\n        toBeClaimed += claimableState.earlyVestableBonus;\n      }\n\n      totalClaimableAmount += toBeClaimed;\n      _updateClaimedAmounts(\n        user,\n        globalState,\n        userState,\n        param,\n        toBeClaimed,\n        param.isEarlyClaim ? claimableState.earlyVestableBonus : 0\n      );\n    }\n\n    if (isEarlyClaim && user != msg.sender) {\n      if (\n        !i_factory.getDelegateRegistry().checkDelegateForContract({\n          to: msg.sender,\n          from: user,\n          contract_: address(i_factory),\n          rights: bytes32(0)\n        })\n      ) {\n        revert InvalidSender(msg.sender);\n      }\n    }\n\n    if (totalClaimableAmount == 0) {\n      return;\n    }\n    i_token.safeTransfer(user, totalClaimableAmount);\n  }\n\n  /// @notice Updates the claimed amounts for a user and the season\n  /// @param user The user address\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param param The input parameters for the claim\n  /// @param toBeClaimed The amount of tokens to be claimed by the user\n  /// @param earlyVestableBonus The amount of bonus tokens that can be claimed early\n  /// @dev This function is called when a user claims tokens\n  function _updateClaimedAmounts(\n    address user,\n    GlobalState storage globalState,\n    UserState memory userState,\n    ClaimParams memory param,\n    uint256 toBeClaimed,\n    uint256 earlyVestableBonus\n  ) private {\n    userState.claimed += uint248(toBeClaimed);\n    s_userStates[user][param.seasonId] = userState;\n\n    globalState.totalClaimed += toBeClaimed;\n\n    emit Claimed(\n      user,\n      param.seasonId,\n      toBeClaimed,\n      param.isEarlyClaim,\n      earlyVestableBonus,\n      userState.claimed,\n      globalState.totalClaimed,\n      globalState.totalLoyalty,\n      globalState.totalLoyaltyIneligible\n    );\n  }\n\n  /// @notice Only callable by the factory contract admin\n  modifier onlyProjectAdmin() {\n    if (msg.sender != i_factory.getProjectConfig(address(i_token)).admin) {\n      revert IAccessControl.AccessControlUnauthorizedAccount(msg.sender, keccak256(\"PROJECT_ADMIN\"));\n    }\n    _;\n  }\n\n  /// @notice Only callable when claim contract is not paused\n  modifier whenClaimNotPaused() {\n    if (i_factory.isClaimContractPaused(address(i_token))) {\n      revert Pausable.EnforcedPause();\n    }\n    _;\n  }\n}", "modifiers": [], "stateMutability": "pure", "returnParameters": null, "visibility": "private", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol"}, {"type": "FunctionDefinition", "name": "BUILDClaim._getUnlockState", "start_line": 266, "end_line": 281, "offset_start": 11078, "offset_end": 11655, "content": "function _getUnlockState(\n    uint256 unlockStartsAt,\n    uint256 unlockDelay,\n    uint256 unlockDuration,\n    uint256 targetTime\n  ) internal pure returns (UnlockState memory) {\n    uint256 unlockDelayEndsAt = unlockStartsAt + unlockDelay;\n    if (targetTime < unlockDelayEndsAt) {\n      return UnlockState({isBeforeUnlock: true, isUnlocking: false, unlockElapsedDuration: 0});\n    }\n    return UnlockState({\n      isBeforeUnlock: false,\n      isUnlocking: targetTime < unlockDelayEndsAt + unlockDuration,\n      unlockElapsedDuration: targetTime - unlockDelayEndsAt\n    });\n  }", "contract_name": "BUILDClaim", "contract_code": "{\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint256;\n\n  /// @notice The unlock state for a season at a given time\n  struct UnlockState {\n    uint256 unlockElapsedDuration; // The amount of time that has elapsed since\n      // the unlock delay started\n    bool isBeforeUnlock; // Whether the unlock period has started (including the delay)\n    bool isUnlocking; // Whether the unlock period is in progress\n  }\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDClaim 1.0.0\";\n\n  /// @notice The claimed and early claimed states for a user per season\n  mapping(address user => mapping(uint256 seasonId => UserState)) private s_userStates;\n\n  /// @notice The global states for a season\n  mapping(uint256 seasonId => GlobalState globalState) private s_globalStates;\n\n  /// @notice The project token\n  IERC20 private immutable i_token;\n\n  /// @notice The factory that deployed this contract\n  BUILDFactory private immutable i_factory;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @notice constructor\n  /// @param token The project token\n  constructor(\n    address token\n  ) {\n    i_token = IERC20(token);\n    i_factory = BUILDFactory(msg.sender);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getFactory() external view override returns (BUILDFactory) {\n    return i_factory;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getToken() external view override returns (IERC20) {\n    return i_token;\n  }\n\n  /// @inheritdoc IERC165\n  function supportsInterface(\n    bytes4 interfaceId\n  ) external pure override returns (bool) {\n    return interfaceId == type(IBUILDClaim).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  // ================================================================\n  // |                        Token Deposits                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function deposit(\n    uint256 amount\n  ) external override nonReentrant whenClaimNotPaused onlyProjectAdmin {\n    // only callable when factory contract is open\n    if (!i_factory.isOpen()) {\n      revert Closable.AlreadyClosed();\n    }\n\n    uint256 balanceBefore = i_token.balanceOf(address(this));\n    uint256 totalDeposited = i_factory.addTotalDeposited(address(i_token), amount);\n    i_token.safeTransferFrom(msg.sender, address(this), amount);\n    uint256 balanceAfter = i_token.balanceOf(address(this));\n    if (balanceBefore + amount != balanceAfter) {\n      revert InvalidDeposit(balanceBefore, balanceAfter);\n    }\n\n    emit Deposited(address(i_token), msg.sender, amount, totalDeposited);\n  }\n\n  // ================================================================\n  // |                       Token Withdrawals                      |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function withdraw() external override nonReentrant onlyProjectAdmin {\n    (IBUILDFactory.Withdrawal memory withdrawal, uint256 totalWithdrawn) =\n      i_factory.executeWithdraw(address(i_token));\n    i_token.safeTransfer(withdrawal.recipient, withdrawal.amount);\n    emit Withdrawn(address(i_token), withdrawal.recipient, withdrawal.amount, totalWithdrawn);\n  }\n\n  // ================================================================\n  // |                         Token Claims                         |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function claim(\n    address user,\n    ClaimParams[] calldata params\n  ) external override nonReentrant whenClaimNotPaused {\n    _claim(user, params);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getGlobalState(\n    uint256 seasonId\n  ) external view returns (GlobalState memory) {\n    return s_globalStates[seasonId];\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getUserState(\n    UserSeasonId[] calldata usersAndSeasonIds\n  ) external view returns (UserState[] memory) {\n    uint256 count = usersAndSeasonIds.length;\n    UserState[] memory states = new UserState[](count);\n    for (uint256 i; i < count; ++i) {\n      states[i] = s_userStates[usersAndSeasonIds[i].user][usersAndSeasonIds[i].seasonId];\n    }\n    return states;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getCurrentClaimValues(\n    address user,\n    uint256 seasonId,\n    uint256 maxTokenAmount\n  ) external view returns (ClaimableState memory) {\n    (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n      i_factory.getProjectSeasonConfig(address(i_token), seasonId);\n    UnlockState memory unlockState =\n      _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n    return _getClaimableState(\n      config, s_globalStates[seasonId], s_userStates[user][seasonId], unlockState, maxTokenAmount\n    );\n  }\n\n  /// @notice Validates if the user is eligible to claim the amount of tokens for a season\n  /// A merkle tree's leaf consists of a user address, their max token amount for the season and a\n  /// salt\n  /// @param root The merkle root of a season\n  /// @param user The user's address\n  /// @param proof The merkle proof of the user's address, max token amount and salt\n  /// @param maxTokenAmount The user's total claimable token amount for the season\n  /// @param isEarlyClaim Whether the user is claiming early\n  /// @param salt A randomly generated salt to prevent brute-force guessing of merkle proofs\n  /// @return bool Returns true if the user's proof, maxTokenAmount and salt are valid\n  function _verifyMerkleProof(\n    bytes32 root,\n    address user,\n    bytes32[] memory proof,\n    uint256 maxTokenAmount,\n    bool isEarlyClaim,\n    uint256 salt\n  ) private pure returns (bool) {\n    bytes32 leaf =\n      keccak256(bytes.concat(keccak256(abi.encode(user, maxTokenAmount, isEarlyClaim, salt))));\n    return MerkleProof.verify(proof, root, leaf);\n  }\n\n  /// @notice Calculates the amount of tokens that can be claimed by a user for a season\n  /// without requiring an early claim at a particular timestamp.\n  /// This amount is the sum of the base tokens amount that is released all at once after the\n  /// unlock delay and the unlocked amount that is released linearly over the unlock duration.\n  /// This does not factor in any claimed amounts\n  /// @param config The project season config\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param unlockState The unlock state for the season\n  /// @param maxTokenAmount The maximum token amount for the user\n  /// @return ClaimableState The amount of tokens that can be claimed\n  function _getClaimableState(\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    IBUILDClaim.GlobalState memory globalState,\n    UserState memory userState,\n    UnlockState memory unlockState,\n    uint256 maxTokenAmount\n  ) internal pure returns (ClaimableState memory) {\n    ClaimableState memory claimableState;\n    claimableState.base =\n      (maxTokenAmount * config.baseTokenClaimBps) / PERCENTAGE_BASIS_POINTS_DENOMINATOR;\n    claimableState.bonus = maxTokenAmount - claimableState.base;\n\n    if (config.tokenAmount == 0 || (config.isRefunding && userState.claimed == 0)) {\n      return claimableState;\n    }\n\n    claimableState.claimed = userState.claimed;\n\n    if (userState.hasEarlyClaimed || unlockState.isBeforeUnlock) return claimableState;\n    // calculate share of loyalty pool to receive\n    // The loyalty bonus is informative only in the unlock period, as it is not\n    // claimable until the vesting is completed.\n    claimableState.loyaltyBonus = maxTokenAmount * globalState.totalLoyalty\n      / (config.tokenAmount - globalState.totalLoyaltyIneligible);\n\n    if (unlockState.isUnlocking) {\n      // unlock period is in progress\n      claimableState.vested =\n        (claimableState.bonus * unlockState.unlockElapsedDuration) / config.unlockDuration;\n      claimableState.claimable =\n        claimableState.base + claimableState.vested - claimableState.claimed;\n      claimableState.earlyVestableBonus =\n        _calcEarlyVestableBonus(claimableState, config, unlockState.unlockElapsedDuration);\n    } else {\n      // unlock completed\n      claimableState.claimable =\n        maxTokenAmount + claimableState.loyaltyBonus - claimableState.claimed;\n    }\n\n    return claimableState;\n  }\n\n  /// @notice Calculates the amount of bonus tokens that can be claimed early\n  /// @param claimableState The claimable state for the user\n  /// @param config The project season config\n  /// @param timeElapsed The amount of time that has elapsed since the unlock delay started\n  /// @return uint256 The amount of bonus tokens that can be claimed early\n  function _calcEarlyVestableBonus(\n    ClaimableState memory claimableState,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 timeElapsed\n  ) private pure returns (uint256) {\n    return FixedPointMathLib.mulWadDown(\n      claimableState.bonus - claimableState.vested,\n      FixedPointMathLib.divWadDown(config.earlyVestRatioMinBps, PERCENTAGE_BASIS_POINTS_DENOMINATOR)\n        + (\n          FixedPointMathLib.divWadDown(\n            config.earlyVestRatioMaxBps - config.earlyVestRatioMinBps,\n            PERCENTAGE_BASIS_POINTS_DENOMINATOR\n          ) * timeElapsed\n        ) / config.unlockDuration\n    );\n  }\n\n  /// @notice Returns the unlock progress for a season\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockDelay The delay before the unlock period starts\n  /// @param unlockDuration The duration of the unlock period\n  /// @param targetTime The timestamp to evaluate the unlock progress at\n  /// @return UnlockState The unlock state for the target time\n  function _getUnlockState(\n    uint256 unlockStartsAt,\n    uint256 unlockDelay,\n    uint256 unlockDuration,\n    uint256 targetTime\n  ) internal pure returns (UnlockState memory) {\n    uint256 unlockDelayEndsAt = unlockStartsAt + unlockDelay;\n    if (targetTime < unlockDelayEndsAt) {\n      return UnlockState({isBeforeUnlock: true, isUnlocking: false, unlockElapsedDuration: 0});\n    }\n    return UnlockState({\n      isBeforeUnlock: false,\n      isUnlocking: targetTime < unlockDelayEndsAt + unlockDuration,\n      unlockElapsedDuration: targetTime - unlockDelayEndsAt\n    });\n  }\n\n  /// @notice Validates the claim parameters for a user\n  /// @param user The user address\n  /// @param userState The user state for the season\n  /// @param param The claim parameters for a user\n  /// @param config The project season config\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockState The unlock state for the season\n  /// @dev Reverts if the claim parameters are invalid\n  /// @dev Reverts if the unlock period has not started yet, including the configured unlock delay\n  /// @dev Reverts if the project season does not exist for the given token address\n  /// @dev Reverts if the user's proof is invalid\n  /// @dev Reverts if user attempts to earlyClaim after previously early claiming during the unlock\n  /// period\n  function _validateClaimParams(\n    address user,\n    UserState memory userState,\n    ClaimParams memory param,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 unlockStartsAt,\n    UnlockState memory unlockState\n  ) private view {\n    if (user == address(0)) {\n      revert InvalidUser(user);\n    }\n    if (unlockStartsAt == 0) {\n      revert IBUILDFactory.SeasonDoesNotExist(param.seasonId);\n    }\n    if (unlockState.isBeforeUnlock) {\n      revert UnlockNotStarted(param.seasonId);\n    }\n    if (config.tokenAmount == 0) {\n      revert IBUILDFactory.ProjectSeasonDoesNotExist(param.seasonId, address(i_token));\n    }\n    if (\n      !_verifyMerkleProof(\n        config.merkleRoot, user, param.proof, param.maxTokenAmount, param.isEarlyClaim, param.salt\n      )\n    ) {\n      revert InvalidMerkleProof();\n    }\n    if (unlockState.isUnlocking && param.isEarlyClaim && userState.hasEarlyClaimed) {\n      revert InvalidEarlyClaim(user, param.seasonId);\n    }\n    if (userState.claimed == 0 && config.isRefunding) {\n      // If the user hasn't claimed for this season before the refunding starts, the user will\n      // be refunded their allocated credits but can no longer claim tokens\n      revert IBUILDFactory.ProjectSeasonIsRefunding(address(i_token), param.seasonId);\n    }\n  }\n\n  /// @notice Util function that claims tokens for a user for multiple seasons\n  /// @param user The user address\n  /// @param params An array of claim params including the season ID, proof, and max token amount\n  /// for each season\n  function _claim(address user, ClaimParams[] memory params) private {\n    uint256 totalClaimableAmount;\n    bool isEarlyClaim = false;\n\n    // Cache array length outside loop\n    uint256 paramsLength = params.length;\n    for (uint256 i = 0; i < paramsLength; ++i) {\n      ClaimParams memory param = params[i];\n      if (param.isEarlyClaim) {\n        isEarlyClaim = true;\n      }\n      (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n        i_factory.getProjectSeasonConfig(address(i_token), param.seasonId);\n\n      UserState memory userState = s_userStates[user][param.seasonId];\n      UnlockState memory unlockState =\n        _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n\n      _validateClaimParams(user, userState, param, config, unlockStartsAt, unlockState);\n\n      if (userState.hasEarlyClaimed) {\n        continue;\n      }\n\n      GlobalState storage globalState = s_globalStates[param.seasonId];\n      ClaimableState memory claimableState =\n        _getClaimableState(config, globalState, userState, unlockState, param.maxTokenAmount);\n\n      // short-circuit on potential zero claim value before consuming refundable amount\n      // if regular claim, claimable must be > 0\n      // if early claim, earlyClaimable must be > 0\n      if (\n        (claimableState.claimable == 0 && !param.isEarlyClaim)\n          || (\n            claimableState.claimable == 0 && claimableState.earlyVestableBonus == 0\n              && param.isEarlyClaim\n          )\n      ) {\n        continue;\n      }\n\n      if (claimableState.claimed == 0) {\n        // User is claiming for the first time for this particular season, so the project can no\n        // longer reclaim the refundable amount for this user's credits\n        i_factory.reduceRefundableAmount(address(i_token), param.seasonId, param.maxTokenAmount);\n      }\n      uint256 toBeClaimed = claimableState.claimable;\n      if (unlockState.isUnlocking && param.isEarlyClaim) {\n        globalState.totalLoyalty +=\n          claimableState.bonus - claimableState.vested - claimableState.earlyVestableBonus;\n        globalState.totalLoyaltyIneligible += param.maxTokenAmount;\n        userState.hasEarlyClaimed = true;\n        toBeClaimed += claimableState.earlyVestableBonus;\n      }\n\n      totalClaimableAmount += toBeClaimed;\n      _updateClaimedAmounts(\n        user,\n        globalState,\n        userState,\n        param,\n        toBeClaimed,\n        param.isEarlyClaim ? claimableState.earlyVestableBonus : 0\n      );\n    }\n\n    if (isEarlyClaim && user != msg.sender) {\n      if (\n        !i_factory.getDelegateRegistry().checkDelegateForContract({\n          to: msg.sender,\n          from: user,\n          contract_: address(i_factory),\n          rights: bytes32(0)\n        })\n      ) {\n        revert InvalidSender(msg.sender);\n      }\n    }\n\n    if (totalClaimableAmount == 0) {\n      return;\n    }\n    i_token.safeTransfer(user, totalClaimableAmount);\n  }\n\n  /// @notice Updates the claimed amounts for a user and the season\n  /// @param user The user address\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param param The input parameters for the claim\n  /// @param toBeClaimed The amount of tokens to be claimed by the user\n  /// @param earlyVestableBonus The amount of bonus tokens that can be claimed early\n  /// @dev This function is called when a user claims tokens\n  function _updateClaimedAmounts(\n    address user,\n    GlobalState storage globalState,\n    UserState memory userState,\n    ClaimParams memory param,\n    uint256 toBeClaimed,\n    uint256 earlyVestableBonus\n  ) private {\n    userState.claimed += uint248(toBeClaimed);\n    s_userStates[user][param.seasonId] = userState;\n\n    globalState.totalClaimed += toBeClaimed;\n\n    emit Claimed(\n      user,\n      param.seasonId,\n      toBeClaimed,\n      param.isEarlyClaim,\n      earlyVestableBonus,\n      userState.claimed,\n      globalState.totalClaimed,\n      globalState.totalLoyalty,\n      globalState.totalLoyaltyIneligible\n    );\n  }\n\n  /// @notice Only callable by the factory contract admin\n  modifier onlyProjectAdmin() {\n    if (msg.sender != i_factory.getProjectConfig(address(i_token)).admin) {\n      revert IAccessControl.AccessControlUnauthorizedAccount(msg.sender, keccak256(\"PROJECT_ADMIN\"));\n    }\n    _;\n  }\n\n  /// @notice Only callable when claim contract is not paused\n  modifier whenClaimNotPaused() {\n    if (i_factory.isClaimContractPaused(address(i_token))) {\n      revert Pausable.EnforcedPause();\n    }\n    _;\n  }\n}", "modifiers": [], "stateMutability": "pure", "returnParameters": null, "visibility": "internal", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol"}, {"type": "FunctionDefinition", "name": "BUILDClaim._validateClaimParams", "start_line": 296, "end_line": 331, "offset_start": 12431, "offset_end": 13725, "content": "function _validateClaimParams(\n    address user,\n    UserState memory userState,\n    ClaimParams memory param,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 unlockStartsAt,\n    UnlockState memory unlockState\n  ) private view {\n    if (user == address(0)) {\n      revert InvalidUser(user);\n    }\n    if (unlockStartsAt == 0) {\n      revert IBUILDFactory.SeasonDoesNotExist(param.seasonId);\n    }\n    if (unlockState.isBeforeUnlock) {\n      revert UnlockNotStarted(param.seasonId);\n    }\n    if (config.tokenAmount == 0) {\n      revert IBUILDFactory.ProjectSeasonDoesNotExist(param.seasonId, address(i_token));\n    }\n    if (\n      !_verifyMerkleProof(\n        config.merkleRoot, user, param.proof, param.maxTokenAmount, param.isEarlyClaim, param.salt\n      )\n    ) {\n      revert InvalidMerkleProof();\n    }\n    if (unlockState.isUnlocking && param.isEarlyClaim && userState.hasEarlyClaimed) {\n      revert InvalidEarlyClaim(user, param.seasonId);\n    }\n    if (userState.claimed == 0 && config.isRefunding) {\n      // If the user hasn't claimed for this season before the refunding starts, the user will\n      // be refunded their allocated credits but can no longer claim tokens\n      revert IBUILDFactory.ProjectSeasonIsRefunding(address(i_token), param.seasonId);\n    }\n  }", "contract_name": "BUILDClaim", "contract_code": "{\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint256;\n\n  /// @notice The unlock state for a season at a given time\n  struct UnlockState {\n    uint256 unlockElapsedDuration; // The amount of time that has elapsed since\n      // the unlock delay started\n    bool isBeforeUnlock; // Whether the unlock period has started (including the delay)\n    bool isUnlocking; // Whether the unlock period is in progress\n  }\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDClaim 1.0.0\";\n\n  /// @notice The claimed and early claimed states for a user per season\n  mapping(address user => mapping(uint256 seasonId => UserState)) private s_userStates;\n\n  /// @notice The global states for a season\n  mapping(uint256 seasonId => GlobalState globalState) private s_globalStates;\n\n  /// @notice The project token\n  IERC20 private immutable i_token;\n\n  /// @notice The factory that deployed this contract\n  BUILDFactory private immutable i_factory;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @notice constructor\n  /// @param token The project token\n  constructor(\n    address token\n  ) {\n    i_token = IERC20(token);\n    i_factory = BUILDFactory(msg.sender);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getFactory() external view override returns (BUILDFactory) {\n    return i_factory;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getToken() external view override returns (IERC20) {\n    return i_token;\n  }\n\n  /// @inheritdoc IERC165\n  function supportsInterface(\n    bytes4 interfaceId\n  ) external pure override returns (bool) {\n    return interfaceId == type(IBUILDClaim).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  // ================================================================\n  // |                        Token Deposits                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function deposit(\n    uint256 amount\n  ) external override nonReentrant whenClaimNotPaused onlyProjectAdmin {\n    // only callable when factory contract is open\n    if (!i_factory.isOpen()) {\n      revert Closable.AlreadyClosed();\n    }\n\n    uint256 balanceBefore = i_token.balanceOf(address(this));\n    uint256 totalDeposited = i_factory.addTotalDeposited(address(i_token), amount);\n    i_token.safeTransferFrom(msg.sender, address(this), amount);\n    uint256 balanceAfter = i_token.balanceOf(address(this));\n    if (balanceBefore + amount != balanceAfter) {\n      revert InvalidDeposit(balanceBefore, balanceAfter);\n    }\n\n    emit Deposited(address(i_token), msg.sender, amount, totalDeposited);\n  }\n\n  // ================================================================\n  // |                       Token Withdrawals                      |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function withdraw() external override nonReentrant onlyProjectAdmin {\n    (IBUILDFactory.Withdrawal memory withdrawal, uint256 totalWithdrawn) =\n      i_factory.executeWithdraw(address(i_token));\n    i_token.safeTransfer(withdrawal.recipient, withdrawal.amount);\n    emit Withdrawn(address(i_token), withdrawal.recipient, withdrawal.amount, totalWithdrawn);\n  }\n\n  // ================================================================\n  // |                         Token Claims                         |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function claim(\n    address user,\n    ClaimParams[] calldata params\n  ) external override nonReentrant whenClaimNotPaused {\n    _claim(user, params);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getGlobalState(\n    uint256 seasonId\n  ) external view returns (GlobalState memory) {\n    return s_globalStates[seasonId];\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getUserState(\n    UserSeasonId[] calldata usersAndSeasonIds\n  ) external view returns (UserState[] memory) {\n    uint256 count = usersAndSeasonIds.length;\n    UserState[] memory states = new UserState[](count);\n    for (uint256 i; i < count; ++i) {\n      states[i] = s_userStates[usersAndSeasonIds[i].user][usersAndSeasonIds[i].seasonId];\n    }\n    return states;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getCurrentClaimValues(\n    address user,\n    uint256 seasonId,\n    uint256 maxTokenAmount\n  ) external view returns (ClaimableState memory) {\n    (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n      i_factory.getProjectSeasonConfig(address(i_token), seasonId);\n    UnlockState memory unlockState =\n      _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n    return _getClaimableState(\n      config, s_globalStates[seasonId], s_userStates[user][seasonId], unlockState, maxTokenAmount\n    );\n  }\n\n  /// @notice Validates if the user is eligible to claim the amount of tokens for a season\n  /// A merkle tree's leaf consists of a user address, their max token amount for the season and a\n  /// salt\n  /// @param root The merkle root of a season\n  /// @param user The user's address\n  /// @param proof The merkle proof of the user's address, max token amount and salt\n  /// @param maxTokenAmount The user's total claimable token amount for the season\n  /// @param isEarlyClaim Whether the user is claiming early\n  /// @param salt A randomly generated salt to prevent brute-force guessing of merkle proofs\n  /// @return bool Returns true if the user's proof, maxTokenAmount and salt are valid\n  function _verifyMerkleProof(\n    bytes32 root,\n    address user,\n    bytes32[] memory proof,\n    uint256 maxTokenAmount,\n    bool isEarlyClaim,\n    uint256 salt\n  ) private pure returns (bool) {\n    bytes32 leaf =\n      keccak256(bytes.concat(keccak256(abi.encode(user, maxTokenAmount, isEarlyClaim, salt))));\n    return MerkleProof.verify(proof, root, leaf);\n  }\n\n  /// @notice Calculates the amount of tokens that can be claimed by a user for a season\n  /// without requiring an early claim at a particular timestamp.\n  /// This amount is the sum of the base tokens amount that is released all at once after the\n  /// unlock delay and the unlocked amount that is released linearly over the unlock duration.\n  /// This does not factor in any claimed amounts\n  /// @param config The project season config\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param unlockState The unlock state for the season\n  /// @param maxTokenAmount The maximum token amount for the user\n  /// @return ClaimableState The amount of tokens that can be claimed\n  function _getClaimableState(\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    IBUILDClaim.GlobalState memory globalState,\n    UserState memory userState,\n    UnlockState memory unlockState,\n    uint256 maxTokenAmount\n  ) internal pure returns (ClaimableState memory) {\n    ClaimableState memory claimableState;\n    claimableState.base =\n      (maxTokenAmount * config.baseTokenClaimBps) / PERCENTAGE_BASIS_POINTS_DENOMINATOR;\n    claimableState.bonus = maxTokenAmount - claimableState.base;\n\n    if (config.tokenAmount == 0 || (config.isRefunding && userState.claimed == 0)) {\n      return claimableState;\n    }\n\n    claimableState.claimed = userState.claimed;\n\n    if (userState.hasEarlyClaimed || unlockState.isBeforeUnlock) return claimableState;\n    // calculate share of loyalty pool to receive\n    // The loyalty bonus is informative only in the unlock period, as it is not\n    // claimable until the vesting is completed.\n    claimableState.loyaltyBonus = maxTokenAmount * globalState.totalLoyalty\n      / (config.tokenAmount - globalState.totalLoyaltyIneligible);\n\n    if (unlockState.isUnlocking) {\n      // unlock period is in progress\n      claimableState.vested =\n        (claimableState.bonus * unlockState.unlockElapsedDuration) / config.unlockDuration;\n      claimableState.claimable =\n        claimableState.base + claimableState.vested - claimableState.claimed;\n      claimableState.earlyVestableBonus =\n        _calcEarlyVestableBonus(claimableState, config, unlockState.unlockElapsedDuration);\n    } else {\n      // unlock completed\n      claimableState.claimable =\n        maxTokenAmount + claimableState.loyaltyBonus - claimableState.claimed;\n    }\n\n    return claimableState;\n  }\n\n  /// @notice Calculates the amount of bonus tokens that can be claimed early\n  /// @param claimableState The claimable state for the user\n  /// @param config The project season config\n  /// @param timeElapsed The amount of time that has elapsed since the unlock delay started\n  /// @return uint256 The amount of bonus tokens that can be claimed early\n  function _calcEarlyVestableBonus(\n    ClaimableState memory claimableState,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 timeElapsed\n  ) private pure returns (uint256) {\n    return FixedPointMathLib.mulWadDown(\n      claimableState.bonus - claimableState.vested,\n      FixedPointMathLib.divWadDown(config.earlyVestRatioMinBps, PERCENTAGE_BASIS_POINTS_DENOMINATOR)\n        + (\n          FixedPointMathLib.divWadDown(\n            config.earlyVestRatioMaxBps - config.earlyVestRatioMinBps,\n            PERCENTAGE_BASIS_POINTS_DENOMINATOR\n          ) * timeElapsed\n        ) / config.unlockDuration\n    );\n  }\n\n  /// @notice Returns the unlock progress for a season\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockDelay The delay before the unlock period starts\n  /// @param unlockDuration The duration of the unlock period\n  /// @param targetTime The timestamp to evaluate the unlock progress at\n  /// @return UnlockState The unlock state for the target time\n  function _getUnlockState(\n    uint256 unlockStartsAt,\n    uint256 unlockDelay,\n    uint256 unlockDuration,\n    uint256 targetTime\n  ) internal pure returns (UnlockState memory) {\n    uint256 unlockDelayEndsAt = unlockStartsAt + unlockDelay;\n    if (targetTime < unlockDelayEndsAt) {\n      return UnlockState({isBeforeUnlock: true, isUnlocking: false, unlockElapsedDuration: 0});\n    }\n    return UnlockState({\n      isBeforeUnlock: false,\n      isUnlocking: targetTime < unlockDelayEndsAt + unlockDuration,\n      unlockElapsedDuration: targetTime - unlockDelayEndsAt\n    });\n  }\n\n  /// @notice Validates the claim parameters for a user\n  /// @param user The user address\n  /// @param userState The user state for the season\n  /// @param param The claim parameters for a user\n  /// @param config The project season config\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockState The unlock state for the season\n  /// @dev Reverts if the claim parameters are invalid\n  /// @dev Reverts if the unlock period has not started yet, including the configured unlock delay\n  /// @dev Reverts if the project season does not exist for the given token address\n  /// @dev Reverts if the user's proof is invalid\n  /// @dev Reverts if user attempts to earlyClaim after previously early claiming during the unlock\n  /// period\n  function _validateClaimParams(\n    address user,\n    UserState memory userState,\n    ClaimParams memory param,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 unlockStartsAt,\n    UnlockState memory unlockState\n  ) private view {\n    if (user == address(0)) {\n      revert InvalidUser(user);\n    }\n    if (unlockStartsAt == 0) {\n      revert IBUILDFactory.SeasonDoesNotExist(param.seasonId);\n    }\n    if (unlockState.isBeforeUnlock) {\n      revert UnlockNotStarted(param.seasonId);\n    }\n    if (config.tokenAmount == 0) {\n      revert IBUILDFactory.ProjectSeasonDoesNotExist(param.seasonId, address(i_token));\n    }\n    if (\n      !_verifyMerkleProof(\n        config.merkleRoot, user, param.proof, param.maxTokenAmount, param.isEarlyClaim, param.salt\n      )\n    ) {\n      revert InvalidMerkleProof();\n    }\n    if (unlockState.isUnlocking && param.isEarlyClaim && userState.hasEarlyClaimed) {\n      revert InvalidEarlyClaim(user, param.seasonId);\n    }\n    if (userState.claimed == 0 && config.isRefunding) {\n      // If the user hasn't claimed for this season before the refunding starts, the user will\n      // be refunded their allocated credits but can no longer claim tokens\n      revert IBUILDFactory.ProjectSeasonIsRefunding(address(i_token), param.seasonId);\n    }\n  }\n\n  /// @notice Util function that claims tokens for a user for multiple seasons\n  /// @param user The user address\n  /// @param params An array of claim params including the season ID, proof, and max token amount\n  /// for each season\n  function _claim(address user, ClaimParams[] memory params) private {\n    uint256 totalClaimableAmount;\n    bool isEarlyClaim = false;\n\n    // Cache array length outside loop\n    uint256 paramsLength = params.length;\n    for (uint256 i = 0; i < paramsLength; ++i) {\n      ClaimParams memory param = params[i];\n      if (param.isEarlyClaim) {\n        isEarlyClaim = true;\n      }\n      (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n        i_factory.getProjectSeasonConfig(address(i_token), param.seasonId);\n\n      UserState memory userState = s_userStates[user][param.seasonId];\n      UnlockState memory unlockState =\n        _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n\n      _validateClaimParams(user, userState, param, config, unlockStartsAt, unlockState);\n\n      if (userState.hasEarlyClaimed) {\n        continue;\n      }\n\n      GlobalState storage globalState = s_globalStates[param.seasonId];\n      ClaimableState memory claimableState =\n        _getClaimableState(config, globalState, userState, unlockState, param.maxTokenAmount);\n\n      // short-circuit on potential zero claim value before consuming refundable amount\n      // if regular claim, claimable must be > 0\n      // if early claim, earlyClaimable must be > 0\n      if (\n        (claimableState.claimable == 0 && !param.isEarlyClaim)\n          || (\n            claimableState.claimable == 0 && claimableState.earlyVestableBonus == 0\n              && param.isEarlyClaim\n          )\n      ) {\n        continue;\n      }\n\n      if (claimableState.claimed == 0) {\n        // User is claiming for the first time for this particular season, so the project can no\n        // longer reclaim the refundable amount for this user's credits\n        i_factory.reduceRefundableAmount(address(i_token), param.seasonId, param.maxTokenAmount);\n      }\n      uint256 toBeClaimed = claimableState.claimable;\n      if (unlockState.isUnlocking && param.isEarlyClaim) {\n        globalState.totalLoyalty +=\n          claimableState.bonus - claimableState.vested - claimableState.earlyVestableBonus;\n        globalState.totalLoyaltyIneligible += param.maxTokenAmount;\n        userState.hasEarlyClaimed = true;\n        toBeClaimed += claimableState.earlyVestableBonus;\n      }\n\n      totalClaimableAmount += toBeClaimed;\n      _updateClaimedAmounts(\n        user,\n        globalState,\n        userState,\n        param,\n        toBeClaimed,\n        param.isEarlyClaim ? claimableState.earlyVestableBonus : 0\n      );\n    }\n\n    if (isEarlyClaim && user != msg.sender) {\n      if (\n        !i_factory.getDelegateRegistry().checkDelegateForContract({\n          to: msg.sender,\n          from: user,\n          contract_: address(i_factory),\n          rights: bytes32(0)\n        })\n      ) {\n        revert InvalidSender(msg.sender);\n      }\n    }\n\n    if (totalClaimableAmount == 0) {\n      return;\n    }\n    i_token.safeTransfer(user, totalClaimableAmount);\n  }\n\n  /// @notice Updates the claimed amounts for a user and the season\n  /// @param user The user address\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param param The input parameters for the claim\n  /// @param toBeClaimed The amount of tokens to be claimed by the user\n  /// @param earlyVestableBonus The amount of bonus tokens that can be claimed early\n  /// @dev This function is called when a user claims tokens\n  function _updateClaimedAmounts(\n    address user,\n    GlobalState storage globalState,\n    UserState memory userState,\n    ClaimParams memory param,\n    uint256 toBeClaimed,\n    uint256 earlyVestableBonus\n  ) private {\n    userState.claimed += uint248(toBeClaimed);\n    s_userStates[user][param.seasonId] = userState;\n\n    globalState.totalClaimed += toBeClaimed;\n\n    emit Claimed(\n      user,\n      param.seasonId,\n      toBeClaimed,\n      param.isEarlyClaim,\n      earlyVestableBonus,\n      userState.claimed,\n      globalState.totalClaimed,\n      globalState.totalLoyalty,\n      globalState.totalLoyaltyIneligible\n    );\n  }\n\n  /// @notice Only callable by the factory contract admin\n  modifier onlyProjectAdmin() {\n    if (msg.sender != i_factory.getProjectConfig(address(i_token)).admin) {\n      revert IAccessControl.AccessControlUnauthorizedAccount(msg.sender, keccak256(\"PROJECT_ADMIN\"));\n    }\n    _;\n  }\n\n  /// @notice Only callable when claim contract is not paused\n  modifier whenClaimNotPaused() {\n    if (i_factory.isClaimContractPaused(address(i_token))) {\n      revert Pausable.EnforcedPause();\n    }\n    _;\n  }\n}", "modifiers": [], "stateMutability": "view", "returnParameters": [], "visibility": "private", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol"}, {"type": "FunctionDefinition", "name": "BUILDClaim._claim", "start_line": 337, "end_line": 420, "offset_start": 13964, "offset_end": 16942, "content": "function _claim(address user, ClaimParams[] memory params) private {\n    uint256 totalClaimableAmount;\n    bool isEarlyClaim = false;\n\n    // Cache array length outside loop\n    uint256 paramsLength = params.length;\n    for (uint256 i = 0; i < paramsLength; ++i) {\n      ClaimParams memory param = params[i];\n      if (param.isEarlyClaim) {\n        isEarlyClaim = true;\n      }\n      (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n        i_factory.getProjectSeasonConfig(address(i_token), param.seasonId);\n\n      UserState memory userState = s_userStates[user][param.seasonId];\n      UnlockState memory unlockState =\n        _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n\n      _validateClaimParams(user, userState, param, config, unlockStartsAt, unlockState);\n\n      if (userState.hasEarlyClaimed) {\n        continue;\n      }\n\n      GlobalState storage globalState = s_globalStates[param.seasonId];\n      ClaimableState memory claimableState =\n        _getClaimableState(config, globalState, userState, unlockState, param.maxTokenAmount);\n\n      // short-circuit on potential zero claim value before consuming refundable amount\n      // if regular claim, claimable must be > 0\n      // if early claim, earlyClaimable must be > 0\n      if (\n        (claimableState.claimable == 0 && !param.isEarlyClaim)\n          || (\n            claimableState.claimable == 0 && claimableState.earlyVestableBonus == 0\n              && param.isEarlyClaim\n          )\n      ) {\n        continue;\n      }\n\n      if (claimableState.claimed == 0) {\n        // User is claiming for the first time for this particular season, so the project can no\n        // longer reclaim the refundable amount for this user's credits\n        i_factory.reduceRefundableAmount(address(i_token), param.seasonId, param.maxTokenAmount);\n      }\n      uint256 toBeClaimed = claimableState.claimable;\n      if (unlockState.isUnlocking && param.isEarlyClaim) {\n        globalState.totalLoyalty +=\n          claimableState.bonus - claimableState.vested - claimableState.earlyVestableBonus;\n        globalState.totalLoyaltyIneligible += param.maxTokenAmount;\n        userState.hasEarlyClaimed = true;\n        toBeClaimed += claimableState.earlyVestableBonus;\n      }\n\n      totalClaimableAmount += toBeClaimed;\n      _updateClaimedAmounts(\n        user,\n        globalState,\n        userState,\n        param,\n        toBeClaimed,\n        param.isEarlyClaim ? claimableState.earlyVestableBonus : 0\n      );\n    }\n\n    if (isEarlyClaim && user != msg.sender) {\n      if (\n        !i_factory.getDelegateRegistry().checkDelegateForContract({\n          to: msg.sender,\n          from: user,\n          contract_: address(i_factory),\n          rights: bytes32(0)\n        })\n      ) {\n        revert InvalidSender(msg.sender);\n      }\n    }\n\n    if (totalClaimableAmount == 0) {\n      return;\n    }\n    i_token.safeTransfer(user, totalClaimableAmount);\n  }", "contract_name": "BUILDClaim", "contract_code": "{\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint256;\n\n  /// @notice The unlock state for a season at a given time\n  struct UnlockState {\n    uint256 unlockElapsedDuration; // The amount of time that has elapsed since\n      // the unlock delay started\n    bool isBeforeUnlock; // Whether the unlock period has started (including the delay)\n    bool isUnlocking; // Whether the unlock period is in progress\n  }\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDClaim 1.0.0\";\n\n  /// @notice The claimed and early claimed states for a user per season\n  mapping(address user => mapping(uint256 seasonId => UserState)) private s_userStates;\n\n  /// @notice The global states for a season\n  mapping(uint256 seasonId => GlobalState globalState) private s_globalStates;\n\n  /// @notice The project token\n  IERC20 private immutable i_token;\n\n  /// @notice The factory that deployed this contract\n  BUILDFactory private immutable i_factory;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @notice constructor\n  /// @param token The project token\n  constructor(\n    address token\n  ) {\n    i_token = IERC20(token);\n    i_factory = BUILDFactory(msg.sender);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getFactory() external view override returns (BUILDFactory) {\n    return i_factory;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getToken() external view override returns (IERC20) {\n    return i_token;\n  }\n\n  /// @inheritdoc IERC165\n  function supportsInterface(\n    bytes4 interfaceId\n  ) external pure override returns (bool) {\n    return interfaceId == type(IBUILDClaim).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  // ================================================================\n  // |                        Token Deposits                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function deposit(\n    uint256 amount\n  ) external override nonReentrant whenClaimNotPaused onlyProjectAdmin {\n    // only callable when factory contract is open\n    if (!i_factory.isOpen()) {\n      revert Closable.AlreadyClosed();\n    }\n\n    uint256 balanceBefore = i_token.balanceOf(address(this));\n    uint256 totalDeposited = i_factory.addTotalDeposited(address(i_token), amount);\n    i_token.safeTransferFrom(msg.sender, address(this), amount);\n    uint256 balanceAfter = i_token.balanceOf(address(this));\n    if (balanceBefore + amount != balanceAfter) {\n      revert InvalidDeposit(balanceBefore, balanceAfter);\n    }\n\n    emit Deposited(address(i_token), msg.sender, amount, totalDeposited);\n  }\n\n  // ================================================================\n  // |                       Token Withdrawals                      |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function withdraw() external override nonReentrant onlyProjectAdmin {\n    (IBUILDFactory.Withdrawal memory withdrawal, uint256 totalWithdrawn) =\n      i_factory.executeWithdraw(address(i_token));\n    i_token.safeTransfer(withdrawal.recipient, withdrawal.amount);\n    emit Withdrawn(address(i_token), withdrawal.recipient, withdrawal.amount, totalWithdrawn);\n  }\n\n  // ================================================================\n  // |                         Token Claims                         |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function claim(\n    address user,\n    ClaimParams[] calldata params\n  ) external override nonReentrant whenClaimNotPaused {\n    _claim(user, params);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getGlobalState(\n    uint256 seasonId\n  ) external view returns (GlobalState memory) {\n    return s_globalStates[seasonId];\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getUserState(\n    UserSeasonId[] calldata usersAndSeasonIds\n  ) external view returns (UserState[] memory) {\n    uint256 count = usersAndSeasonIds.length;\n    UserState[] memory states = new UserState[](count);\n    for (uint256 i; i < count; ++i) {\n      states[i] = s_userStates[usersAndSeasonIds[i].user][usersAndSeasonIds[i].seasonId];\n    }\n    return states;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getCurrentClaimValues(\n    address user,\n    uint256 seasonId,\n    uint256 maxTokenAmount\n  ) external view returns (ClaimableState memory) {\n    (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n      i_factory.getProjectSeasonConfig(address(i_token), seasonId);\n    UnlockState memory unlockState =\n      _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n    return _getClaimableState(\n      config, s_globalStates[seasonId], s_userStates[user][seasonId], unlockState, maxTokenAmount\n    );\n  }\n\n  /// @notice Validates if the user is eligible to claim the amount of tokens for a season\n  /// A merkle tree's leaf consists of a user address, their max token amount for the season and a\n  /// salt\n  /// @param root The merkle root of a season\n  /// @param user The user's address\n  /// @param proof The merkle proof of the user's address, max token amount and salt\n  /// @param maxTokenAmount The user's total claimable token amount for the season\n  /// @param isEarlyClaim Whether the user is claiming early\n  /// @param salt A randomly generated salt to prevent brute-force guessing of merkle proofs\n  /// @return bool Returns true if the user's proof, maxTokenAmount and salt are valid\n  function _verifyMerkleProof(\n    bytes32 root,\n    address user,\n    bytes32[] memory proof,\n    uint256 maxTokenAmount,\n    bool isEarlyClaim,\n    uint256 salt\n  ) private pure returns (bool) {\n    bytes32 leaf =\n      keccak256(bytes.concat(keccak256(abi.encode(user, maxTokenAmount, isEarlyClaim, salt))));\n    return MerkleProof.verify(proof, root, leaf);\n  }\n\n  /// @notice Calculates the amount of tokens that can be claimed by a user for a season\n  /// without requiring an early claim at a particular timestamp.\n  /// This amount is the sum of the base tokens amount that is released all at once after the\n  /// unlock delay and the unlocked amount that is released linearly over the unlock duration.\n  /// This does not factor in any claimed amounts\n  /// @param config The project season config\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param unlockState The unlock state for the season\n  /// @param maxTokenAmount The maximum token amount for the user\n  /// @return ClaimableState The amount of tokens that can be claimed\n  function _getClaimableState(\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    IBUILDClaim.GlobalState memory globalState,\n    UserState memory userState,\n    UnlockState memory unlockState,\n    uint256 maxTokenAmount\n  ) internal pure returns (ClaimableState memory) {\n    ClaimableState memory claimableState;\n    claimableState.base =\n      (maxTokenAmount * config.baseTokenClaimBps) / PERCENTAGE_BASIS_POINTS_DENOMINATOR;\n    claimableState.bonus = maxTokenAmount - claimableState.base;\n\n    if (config.tokenAmount == 0 || (config.isRefunding && userState.claimed == 0)) {\n      return claimableState;\n    }\n\n    claimableState.claimed = userState.claimed;\n\n    if (userState.hasEarlyClaimed || unlockState.isBeforeUnlock) return claimableState;\n    // calculate share of loyalty pool to receive\n    // The loyalty bonus is informative only in the unlock period, as it is not\n    // claimable until the vesting is completed.\n    claimableState.loyaltyBonus = maxTokenAmount * globalState.totalLoyalty\n      / (config.tokenAmount - globalState.totalLoyaltyIneligible);\n\n    if (unlockState.isUnlocking) {\n      // unlock period is in progress\n      claimableState.vested =\n        (claimableState.bonus * unlockState.unlockElapsedDuration) / config.unlockDuration;\n      claimableState.claimable =\n        claimableState.base + claimableState.vested - claimableState.claimed;\n      claimableState.earlyVestableBonus =\n        _calcEarlyVestableBonus(claimableState, config, unlockState.unlockElapsedDuration);\n    } else {\n      // unlock completed\n      claimableState.claimable =\n        maxTokenAmount + claimableState.loyaltyBonus - claimableState.claimed;\n    }\n\n    return claimableState;\n  }\n\n  /// @notice Calculates the amount of bonus tokens that can be claimed early\n  /// @param claimableState The claimable state for the user\n  /// @param config The project season config\n  /// @param timeElapsed The amount of time that has elapsed since the unlock delay started\n  /// @return uint256 The amount of bonus tokens that can be claimed early\n  function _calcEarlyVestableBonus(\n    ClaimableState memory claimableState,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 timeElapsed\n  ) private pure returns (uint256) {\n    return FixedPointMathLib.mulWadDown(\n      claimableState.bonus - claimableState.vested,\n      FixedPointMathLib.divWadDown(config.earlyVestRatioMinBps, PERCENTAGE_BASIS_POINTS_DENOMINATOR)\n        + (\n          FixedPointMathLib.divWadDown(\n            config.earlyVestRatioMaxBps - config.earlyVestRatioMinBps,\n            PERCENTAGE_BASIS_POINTS_DENOMINATOR\n          ) * timeElapsed\n        ) / config.unlockDuration\n    );\n  }\n\n  /// @notice Returns the unlock progress for a season\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockDelay The delay before the unlock period starts\n  /// @param unlockDuration The duration of the unlock period\n  /// @param targetTime The timestamp to evaluate the unlock progress at\n  /// @return UnlockState The unlock state for the target time\n  function _getUnlockState(\n    uint256 unlockStartsAt,\n    uint256 unlockDelay,\n    uint256 unlockDuration,\n    uint256 targetTime\n  ) internal pure returns (UnlockState memory) {\n    uint256 unlockDelayEndsAt = unlockStartsAt + unlockDelay;\n    if (targetTime < unlockDelayEndsAt) {\n      return UnlockState({isBeforeUnlock: true, isUnlocking: false, unlockElapsedDuration: 0});\n    }\n    return UnlockState({\n      isBeforeUnlock: false,\n      isUnlocking: targetTime < unlockDelayEndsAt + unlockDuration,\n      unlockElapsedDuration: targetTime - unlockDelayEndsAt\n    });\n  }\n\n  /// @notice Validates the claim parameters for a user\n  /// @param user The user address\n  /// @param userState The user state for the season\n  /// @param param The claim parameters for a user\n  /// @param config The project season config\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockState The unlock state for the season\n  /// @dev Reverts if the claim parameters are invalid\n  /// @dev Reverts if the unlock period has not started yet, including the configured unlock delay\n  /// @dev Reverts if the project season does not exist for the given token address\n  /// @dev Reverts if the user's proof is invalid\n  /// @dev Reverts if user attempts to earlyClaim after previously early claiming during the unlock\n  /// period\n  function _validateClaimParams(\n    address user,\n    UserState memory userState,\n    ClaimParams memory param,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 unlockStartsAt,\n    UnlockState memory unlockState\n  ) private view {\n    if (user == address(0)) {\n      revert InvalidUser(user);\n    }\n    if (unlockStartsAt == 0) {\n      revert IBUILDFactory.SeasonDoesNotExist(param.seasonId);\n    }\n    if (unlockState.isBeforeUnlock) {\n      revert UnlockNotStarted(param.seasonId);\n    }\n    if (config.tokenAmount == 0) {\n      revert IBUILDFactory.ProjectSeasonDoesNotExist(param.seasonId, address(i_token));\n    }\n    if (\n      !_verifyMerkleProof(\n        config.merkleRoot, user, param.proof, param.maxTokenAmount, param.isEarlyClaim, param.salt\n      )\n    ) {\n      revert InvalidMerkleProof();\n    }\n    if (unlockState.isUnlocking && param.isEarlyClaim && userState.hasEarlyClaimed) {\n      revert InvalidEarlyClaim(user, param.seasonId);\n    }\n    if (userState.claimed == 0 && config.isRefunding) {\n      // If the user hasn't claimed for this season before the refunding starts, the user will\n      // be refunded their allocated credits but can no longer claim tokens\n      revert IBUILDFactory.ProjectSeasonIsRefunding(address(i_token), param.seasonId);\n    }\n  }\n\n  /// @notice Util function that claims tokens for a user for multiple seasons\n  /// @param user The user address\n  /// @param params An array of claim params including the season ID, proof, and max token amount\n  /// for each season\n  function _claim(address user, ClaimParams[] memory params) private {\n    uint256 totalClaimableAmount;\n    bool isEarlyClaim = false;\n\n    // Cache array length outside loop\n    uint256 paramsLength = params.length;\n    for (uint256 i = 0; i < paramsLength; ++i) {\n      ClaimParams memory param = params[i];\n      if (param.isEarlyClaim) {\n        isEarlyClaim = true;\n      }\n      (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n        i_factory.getProjectSeasonConfig(address(i_token), param.seasonId);\n\n      UserState memory userState = s_userStates[user][param.seasonId];\n      UnlockState memory unlockState =\n        _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n\n      _validateClaimParams(user, userState, param, config, unlockStartsAt, unlockState);\n\n      if (userState.hasEarlyClaimed) {\n        continue;\n      }\n\n      GlobalState storage globalState = s_globalStates[param.seasonId];\n      ClaimableState memory claimableState =\n        _getClaimableState(config, globalState, userState, unlockState, param.maxTokenAmount);\n\n      // short-circuit on potential zero claim value before consuming refundable amount\n      // if regular claim, claimable must be > 0\n      // if early claim, earlyClaimable must be > 0\n      if (\n        (claimableState.claimable == 0 && !param.isEarlyClaim)\n          || (\n            claimableState.claimable == 0 && claimableState.earlyVestableBonus == 0\n              && param.isEarlyClaim\n          )\n      ) {\n        continue;\n      }\n\n      if (claimableState.claimed == 0) {\n        // User is claiming for the first time for this particular season, so the project can no\n        // longer reclaim the refundable amount for this user's credits\n        i_factory.reduceRefundableAmount(address(i_token), param.seasonId, param.maxTokenAmount);\n      }\n      uint256 toBeClaimed = claimableState.claimable;\n      if (unlockState.isUnlocking && param.isEarlyClaim) {\n        globalState.totalLoyalty +=\n          claimableState.bonus - claimableState.vested - claimableState.earlyVestableBonus;\n        globalState.totalLoyaltyIneligible += param.maxTokenAmount;\n        userState.hasEarlyClaimed = true;\n        toBeClaimed += claimableState.earlyVestableBonus;\n      }\n\n      totalClaimableAmount += toBeClaimed;\n      _updateClaimedAmounts(\n        user,\n        globalState,\n        userState,\n        param,\n        toBeClaimed,\n        param.isEarlyClaim ? claimableState.earlyVestableBonus : 0\n      );\n    }\n\n    if (isEarlyClaim && user != msg.sender) {\n      if (\n        !i_factory.getDelegateRegistry().checkDelegateForContract({\n          to: msg.sender,\n          from: user,\n          contract_: address(i_factory),\n          rights: bytes32(0)\n        })\n      ) {\n        revert InvalidSender(msg.sender);\n      }\n    }\n\n    if (totalClaimableAmount == 0) {\n      return;\n    }\n    i_token.safeTransfer(user, totalClaimableAmount);\n  }\n\n  /// @notice Updates the claimed amounts for a user and the season\n  /// @param user The user address\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param param The input parameters for the claim\n  /// @param toBeClaimed The amount of tokens to be claimed by the user\n  /// @param earlyVestableBonus The amount of bonus tokens that can be claimed early\n  /// @dev This function is called when a user claims tokens\n  function _updateClaimedAmounts(\n    address user,\n    GlobalState storage globalState,\n    UserState memory userState,\n    ClaimParams memory param,\n    uint256 toBeClaimed,\n    uint256 earlyVestableBonus\n  ) private {\n    userState.claimed += uint248(toBeClaimed);\n    s_userStates[user][param.seasonId] = userState;\n\n    globalState.totalClaimed += toBeClaimed;\n\n    emit Claimed(\n      user,\n      param.seasonId,\n      toBeClaimed,\n      param.isEarlyClaim,\n      earlyVestableBonus,\n      userState.claimed,\n      globalState.totalClaimed,\n      globalState.totalLoyalty,\n      globalState.totalLoyaltyIneligible\n    );\n  }\n\n  /// @notice Only callable by the factory contract admin\n  modifier onlyProjectAdmin() {\n    if (msg.sender != i_factory.getProjectConfig(address(i_token)).admin) {\n      revert IAccessControl.AccessControlUnauthorizedAccount(msg.sender, keccak256(\"PROJECT_ADMIN\"));\n    }\n    _;\n  }\n\n  /// @notice Only callable when claim contract is not paused\n  modifier whenClaimNotPaused() {\n    if (i_factory.isClaimContractPaused(address(i_token))) {\n      revert Pausable.EnforcedPause();\n    }\n    _;\n  }\n}", "modifiers": [], "stateMutability": null, "returnParameters": [], "visibility": "private", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol"}, {"type": "FunctionDefinition", "name": "BUILDClaim._updateClaimedAmounts", "start_line": 430, "end_line": 454, "offset_start": 17432, "offset_end": 18059, "content": "function _updateClaimedAmounts(\n    address user,\n    GlobalState storage globalState,\n    UserState memory userState,\n    ClaimParams memory param,\n    uint256 toBeClaimed,\n    uint256 earlyVestableBonus\n  ) private {\n    userState.claimed += uint248(toBeClaimed);\n    s_userStates[user][param.seasonId] = userState;\n\n    globalState.totalClaimed += toBeClaimed;\n\n    emit Claimed(\n      user,\n      param.seasonId,\n      toBeClaimed,\n      param.isEarlyClaim,\n      earlyVestableBonus,\n      userState.claimed,\n      globalState.totalClaimed,\n      globalState.totalLoyalty,\n      globalState.totalLoyaltyIneligible\n    );\n  }", "contract_name": "BUILDClaim", "contract_code": "{\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint256;\n\n  /// @notice The unlock state for a season at a given time\n  struct UnlockState {\n    uint256 unlockElapsedDuration; // The amount of time that has elapsed since\n      // the unlock delay started\n    bool isBeforeUnlock; // Whether the unlock period has started (including the delay)\n    bool isUnlocking; // Whether the unlock period is in progress\n  }\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDClaim 1.0.0\";\n\n  /// @notice The claimed and early claimed states for a user per season\n  mapping(address user => mapping(uint256 seasonId => UserState)) private s_userStates;\n\n  /// @notice The global states for a season\n  mapping(uint256 seasonId => GlobalState globalState) private s_globalStates;\n\n  /// @notice The project token\n  IERC20 private immutable i_token;\n\n  /// @notice The factory that deployed this contract\n  BUILDFactory private immutable i_factory;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @notice constructor\n  /// @param token The project token\n  constructor(\n    address token\n  ) {\n    i_token = IERC20(token);\n    i_factory = BUILDFactory(msg.sender);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getFactory() external view override returns (BUILDFactory) {\n    return i_factory;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getToken() external view override returns (IERC20) {\n    return i_token;\n  }\n\n  /// @inheritdoc IERC165\n  function supportsInterface(\n    bytes4 interfaceId\n  ) external pure override returns (bool) {\n    return interfaceId == type(IBUILDClaim).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  // ================================================================\n  // |                        Token Deposits                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function deposit(\n    uint256 amount\n  ) external override nonReentrant whenClaimNotPaused onlyProjectAdmin {\n    // only callable when factory contract is open\n    if (!i_factory.isOpen()) {\n      revert Closable.AlreadyClosed();\n    }\n\n    uint256 balanceBefore = i_token.balanceOf(address(this));\n    uint256 totalDeposited = i_factory.addTotalDeposited(address(i_token), amount);\n    i_token.safeTransferFrom(msg.sender, address(this), amount);\n    uint256 balanceAfter = i_token.balanceOf(address(this));\n    if (balanceBefore + amount != balanceAfter) {\n      revert InvalidDeposit(balanceBefore, balanceAfter);\n    }\n\n    emit Deposited(address(i_token), msg.sender, amount, totalDeposited);\n  }\n\n  // ================================================================\n  // |                       Token Withdrawals                      |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function withdraw() external override nonReentrant onlyProjectAdmin {\n    (IBUILDFactory.Withdrawal memory withdrawal, uint256 totalWithdrawn) =\n      i_factory.executeWithdraw(address(i_token));\n    i_token.safeTransfer(withdrawal.recipient, withdrawal.amount);\n    emit Withdrawn(address(i_token), withdrawal.recipient, withdrawal.amount, totalWithdrawn);\n  }\n\n  // ================================================================\n  // |                         Token Claims                         |\n  // ================================================================\n\n  /// @inheritdoc IBUILDClaim\n  function claim(\n    address user,\n    ClaimParams[] calldata params\n  ) external override nonReentrant whenClaimNotPaused {\n    _claim(user, params);\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getGlobalState(\n    uint256 seasonId\n  ) external view returns (GlobalState memory) {\n    return s_globalStates[seasonId];\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getUserState(\n    UserSeasonId[] calldata usersAndSeasonIds\n  ) external view returns (UserState[] memory) {\n    uint256 count = usersAndSeasonIds.length;\n    UserState[] memory states = new UserState[](count);\n    for (uint256 i; i < count; ++i) {\n      states[i] = s_userStates[usersAndSeasonIds[i].user][usersAndSeasonIds[i].seasonId];\n    }\n    return states;\n  }\n\n  /// @inheritdoc IBUILDClaim\n  function getCurrentClaimValues(\n    address user,\n    uint256 seasonId,\n    uint256 maxTokenAmount\n  ) external view returns (ClaimableState memory) {\n    (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n      i_factory.getProjectSeasonConfig(address(i_token), seasonId);\n    UnlockState memory unlockState =\n      _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n    return _getClaimableState(\n      config, s_globalStates[seasonId], s_userStates[user][seasonId], unlockState, maxTokenAmount\n    );\n  }\n\n  /// @notice Validates if the user is eligible to claim the amount of tokens for a season\n  /// A merkle tree's leaf consists of a user address, their max token amount for the season and a\n  /// salt\n  /// @param root The merkle root of a season\n  /// @param user The user's address\n  /// @param proof The merkle proof of the user's address, max token amount and salt\n  /// @param maxTokenAmount The user's total claimable token amount for the season\n  /// @param isEarlyClaim Whether the user is claiming early\n  /// @param salt A randomly generated salt to prevent brute-force guessing of merkle proofs\n  /// @return bool Returns true if the user's proof, maxTokenAmount and salt are valid\n  function _verifyMerkleProof(\n    bytes32 root,\n    address user,\n    bytes32[] memory proof,\n    uint256 maxTokenAmount,\n    bool isEarlyClaim,\n    uint256 salt\n  ) private pure returns (bool) {\n    bytes32 leaf =\n      keccak256(bytes.concat(keccak256(abi.encode(user, maxTokenAmount, isEarlyClaim, salt))));\n    return MerkleProof.verify(proof, root, leaf);\n  }\n\n  /// @notice Calculates the amount of tokens that can be claimed by a user for a season\n  /// without requiring an early claim at a particular timestamp.\n  /// This amount is the sum of the base tokens amount that is released all at once after the\n  /// unlock delay and the unlocked amount that is released linearly over the unlock duration.\n  /// This does not factor in any claimed amounts\n  /// @param config The project season config\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param unlockState The unlock state for the season\n  /// @param maxTokenAmount The maximum token amount for the user\n  /// @return ClaimableState The amount of tokens that can be claimed\n  function _getClaimableState(\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    IBUILDClaim.GlobalState memory globalState,\n    UserState memory userState,\n    UnlockState memory unlockState,\n    uint256 maxTokenAmount\n  ) internal pure returns (ClaimableState memory) {\n    ClaimableState memory claimableState;\n    claimableState.base =\n      (maxTokenAmount * config.baseTokenClaimBps) / PERCENTAGE_BASIS_POINTS_DENOMINATOR;\n    claimableState.bonus = maxTokenAmount - claimableState.base;\n\n    if (config.tokenAmount == 0 || (config.isRefunding && userState.claimed == 0)) {\n      return claimableState;\n    }\n\n    claimableState.claimed = userState.claimed;\n\n    if (userState.hasEarlyClaimed || unlockState.isBeforeUnlock) return claimableState;\n    // calculate share of loyalty pool to receive\n    // The loyalty bonus is informative only in the unlock period, as it is not\n    // claimable until the vesting is completed.\n    claimableState.loyaltyBonus = maxTokenAmount * globalState.totalLoyalty\n      / (config.tokenAmount - globalState.totalLoyaltyIneligible);\n\n    if (unlockState.isUnlocking) {\n      // unlock period is in progress\n      claimableState.vested =\n        (claimableState.bonus * unlockState.unlockElapsedDuration) / config.unlockDuration;\n      claimableState.claimable =\n        claimableState.base + claimableState.vested - claimableState.claimed;\n      claimableState.earlyVestableBonus =\n        _calcEarlyVestableBonus(claimableState, config, unlockState.unlockElapsedDuration);\n    } else {\n      // unlock completed\n      claimableState.claimable =\n        maxTokenAmount + claimableState.loyaltyBonus - claimableState.claimed;\n    }\n\n    return claimableState;\n  }\n\n  /// @notice Calculates the amount of bonus tokens that can be claimed early\n  /// @param claimableState The claimable state for the user\n  /// @param config The project season config\n  /// @param timeElapsed The amount of time that has elapsed since the unlock delay started\n  /// @return uint256 The amount of bonus tokens that can be claimed early\n  function _calcEarlyVestableBonus(\n    ClaimableState memory claimableState,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 timeElapsed\n  ) private pure returns (uint256) {\n    return FixedPointMathLib.mulWadDown(\n      claimableState.bonus - claimableState.vested,\n      FixedPointMathLib.divWadDown(config.earlyVestRatioMinBps, PERCENTAGE_BASIS_POINTS_DENOMINATOR)\n        + (\n          FixedPointMathLib.divWadDown(\n            config.earlyVestRatioMaxBps - config.earlyVestRatioMinBps,\n            PERCENTAGE_BASIS_POINTS_DENOMINATOR\n          ) * timeElapsed\n        ) / config.unlockDuration\n    );\n  }\n\n  /// @notice Returns the unlock progress for a season\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockDelay The delay before the unlock period starts\n  /// @param unlockDuration The duration of the unlock period\n  /// @param targetTime The timestamp to evaluate the unlock progress at\n  /// @return UnlockState The unlock state for the target time\n  function _getUnlockState(\n    uint256 unlockStartsAt,\n    uint256 unlockDelay,\n    uint256 unlockDuration,\n    uint256 targetTime\n  ) internal pure returns (UnlockState memory) {\n    uint256 unlockDelayEndsAt = unlockStartsAt + unlockDelay;\n    if (targetTime < unlockDelayEndsAt) {\n      return UnlockState({isBeforeUnlock: true, isUnlocking: false, unlockElapsedDuration: 0});\n    }\n    return UnlockState({\n      isBeforeUnlock: false,\n      isUnlocking: targetTime < unlockDelayEndsAt + unlockDuration,\n      unlockElapsedDuration: targetTime - unlockDelayEndsAt\n    });\n  }\n\n  /// @notice Validates the claim parameters for a user\n  /// @param user The user address\n  /// @param userState The user state for the season\n  /// @param param The claim parameters for a user\n  /// @param config The project season config\n  /// @param unlockStartsAt The timestamp when the unlock period starts\n  /// @param unlockState The unlock state for the season\n  /// @dev Reverts if the claim parameters are invalid\n  /// @dev Reverts if the unlock period has not started yet, including the configured unlock delay\n  /// @dev Reverts if the project season does not exist for the given token address\n  /// @dev Reverts if the user's proof is invalid\n  /// @dev Reverts if user attempts to earlyClaim after previously early claiming during the unlock\n  /// period\n  function _validateClaimParams(\n    address user,\n    UserState memory userState,\n    ClaimParams memory param,\n    IBUILDFactory.ProjectSeasonConfig memory config,\n    uint256 unlockStartsAt,\n    UnlockState memory unlockState\n  ) private view {\n    if (user == address(0)) {\n      revert InvalidUser(user);\n    }\n    if (unlockStartsAt == 0) {\n      revert IBUILDFactory.SeasonDoesNotExist(param.seasonId);\n    }\n    if (unlockState.isBeforeUnlock) {\n      revert UnlockNotStarted(param.seasonId);\n    }\n    if (config.tokenAmount == 0) {\n      revert IBUILDFactory.ProjectSeasonDoesNotExist(param.seasonId, address(i_token));\n    }\n    if (\n      !_verifyMerkleProof(\n        config.merkleRoot, user, param.proof, param.maxTokenAmount, param.isEarlyClaim, param.salt\n      )\n    ) {\n      revert InvalidMerkleProof();\n    }\n    if (unlockState.isUnlocking && param.isEarlyClaim && userState.hasEarlyClaimed) {\n      revert InvalidEarlyClaim(user, param.seasonId);\n    }\n    if (userState.claimed == 0 && config.isRefunding) {\n      // If the user hasn't claimed for this season before the refunding starts, the user will\n      // be refunded their allocated credits but can no longer claim tokens\n      revert IBUILDFactory.ProjectSeasonIsRefunding(address(i_token), param.seasonId);\n    }\n  }\n\n  /// @notice Util function that claims tokens for a user for multiple seasons\n  /// @param user The user address\n  /// @param params An array of claim params including the season ID, proof, and max token amount\n  /// for each season\n  function _claim(address user, ClaimParams[] memory params) private {\n    uint256 totalClaimableAmount;\n    bool isEarlyClaim = false;\n\n    // Cache array length outside loop\n    uint256 paramsLength = params.length;\n    for (uint256 i = 0; i < paramsLength; ++i) {\n      ClaimParams memory param = params[i];\n      if (param.isEarlyClaim) {\n        isEarlyClaim = true;\n      }\n      (IBUILDFactory.ProjectSeasonConfig memory config, uint256 unlockStartsAt) =\n        i_factory.getProjectSeasonConfig(address(i_token), param.seasonId);\n\n      UserState memory userState = s_userStates[user][param.seasonId];\n      UnlockState memory unlockState =\n        _getUnlockState(unlockStartsAt, config.unlockDelay, config.unlockDuration, block.timestamp);\n\n      _validateClaimParams(user, userState, param, config, unlockStartsAt, unlockState);\n\n      if (userState.hasEarlyClaimed) {\n        continue;\n      }\n\n      GlobalState storage globalState = s_globalStates[param.seasonId];\n      ClaimableState memory claimableState =\n        _getClaimableState(config, globalState, userState, unlockState, param.maxTokenAmount);\n\n      // short-circuit on potential zero claim value before consuming refundable amount\n      // if regular claim, claimable must be > 0\n      // if early claim, earlyClaimable must be > 0\n      if (\n        (claimableState.claimable == 0 && !param.isEarlyClaim)\n          || (\n            claimableState.claimable == 0 && claimableState.earlyVestableBonus == 0\n              && param.isEarlyClaim\n          )\n      ) {\n        continue;\n      }\n\n      if (claimableState.claimed == 0) {\n        // User is claiming for the first time for this particular season, so the project can no\n        // longer reclaim the refundable amount for this user's credits\n        i_factory.reduceRefundableAmount(address(i_token), param.seasonId, param.maxTokenAmount);\n      }\n      uint256 toBeClaimed = claimableState.claimable;\n      if (unlockState.isUnlocking && param.isEarlyClaim) {\n        globalState.totalLoyalty +=\n          claimableState.bonus - claimableState.vested - claimableState.earlyVestableBonus;\n        globalState.totalLoyaltyIneligible += param.maxTokenAmount;\n        userState.hasEarlyClaimed = true;\n        toBeClaimed += claimableState.earlyVestableBonus;\n      }\n\n      totalClaimableAmount += toBeClaimed;\n      _updateClaimedAmounts(\n        user,\n        globalState,\n        userState,\n        param,\n        toBeClaimed,\n        param.isEarlyClaim ? claimableState.earlyVestableBonus : 0\n      );\n    }\n\n    if (isEarlyClaim && user != msg.sender) {\n      if (\n        !i_factory.getDelegateRegistry().checkDelegateForContract({\n          to: msg.sender,\n          from: user,\n          contract_: address(i_factory),\n          rights: bytes32(0)\n        })\n      ) {\n        revert InvalidSender(msg.sender);\n      }\n    }\n\n    if (totalClaimableAmount == 0) {\n      return;\n    }\n    i_token.safeTransfer(user, totalClaimableAmount);\n  }\n\n  /// @notice Updates the claimed amounts for a user and the season\n  /// @param user The user address\n  /// @param globalState The global state for the season\n  /// @param userState The user state for the season\n  /// @param param The input parameters for the claim\n  /// @param toBeClaimed The amount of tokens to be claimed by the user\n  /// @param earlyVestableBonus The amount of bonus tokens that can be claimed early\n  /// @dev This function is called when a user claims tokens\n  function _updateClaimedAmounts(\n    address user,\n    GlobalState storage globalState,\n    UserState memory userState,\n    ClaimParams memory param,\n    uint256 toBeClaimed,\n    uint256 earlyVestableBonus\n  ) private {\n    userState.claimed += uint248(toBeClaimed);\n    s_userStates[user][param.seasonId] = userState;\n\n    globalState.totalClaimed += toBeClaimed;\n\n    emit Claimed(\n      user,\n      param.seasonId,\n      toBeClaimed,\n      param.isEarlyClaim,\n      earlyVestableBonus,\n      userState.claimed,\n      globalState.totalClaimed,\n      globalState.totalLoyalty,\n      globalState.totalLoyaltyIneligible\n    );\n  }\n\n  /// @notice Only callable by the factory contract admin\n  modifier onlyProjectAdmin() {\n    if (msg.sender != i_factory.getProjectConfig(address(i_token)).admin) {\n      revert IAccessControl.AccessControlUnauthorizedAccount(msg.sender, keccak256(\"PROJECT_ADMIN\"));\n    }\n    _;\n  }\n\n  /// @notice Only callable when claim contract is not paused\n  modifier whenClaimNotPaused() {\n    if (i_factory.isClaimContractPaused(address(i_token))) {\n      revert Pausable.EnforcedPause();\n    }\n    _;\n  }\n}", "modifiers": [], "stateMutability": null, "returnParameters": [], "visibility": "private", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDClaim.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.addProjects", "start_line": 93, "end_line": 112, "offset_start": 4171, "offset_end": 4895, "content": "function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [null, null], "stateMutability": null, "returnParameters": [], "visibility": "external", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.removeProjects", "start_line": 115, "end_line": 130, "offset_start": 4932, "offset_end": 5447, "content": "function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [null, null], "stateMutability": null, "returnParameters": [], "visibility": "external", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.getProjects", "start_line": 133, "end_line": 135, "offset_start": 5484, "offset_end": 5597, "content": "function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [], "stateMutability": "view", "returnParameters": null, "visibility": "external", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.getProjectConfig", "start_line": 138, "end_line": 142, "offset_start": 5634, "offset_end": 5771, "content": "function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [], "stateMutability": "view", "returnParameters": null, "visibility": "external", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.deployClaim", "start_line": 145, "end_line": 159, "offset_start": 5808, "offset_end": 6337, "content": "function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [null, null], "stateMutability": null, "returnParameters": null, "visibility": "external", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory._requireRegisteredClaim", "start_line": 163, "end_line": 169, "offset_start": 6461, "offset_end": 6628, "content": "function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [], "stateMutability": "view", "returnParameters": [], "visibility": "internal", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.setUnlockConfigMaxValues", "start_line": 176, "end_line": 180, "offset_start": 6876, "offset_end": 7051, "content": "function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [null, null], "stateMutability": null, "returnParameters": [], "visibility": "external", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory._setUnlockConfigMaxValues", "start_line": 184, "end_line": 204, "offset_start": 7198, "offset_end": 7909, "content": "function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [], "stateMutability": null, "returnParameters": [], "visibility": "private", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.getUnlockConfigMaxValues", "start_line": 207, "end_line": 209, "offset_start": 7946, "offset_end": 8074, "content": "function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [], "stateMutability": "view", "returnParameters": null, "visibility": "external", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.setSeasonUnlockStartTime", "start_line": 212, "end_line": 224, "offset_start": 8111, "offset_end": 8744, "content": "function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [null, null], "stateMutability": null, "returnParameters": [], "visibility": "external", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.setProjectSeasonConfig", "start_line": 227, "end_line": 233, "offset_start": 8781, "offset_end": 9021, "content": "function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [null, null], "stateMutability": null, "returnParameters": [], "visibility": "external", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory._setProjectSeasonConfig", "start_line": 238, "end_line": 301, "offset_start": 9230, "offset_end": 11905, "content": "function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [], "stateMutability": null, "returnParameters": [], "visibility": "internal", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory._setSeasonTokenAmount", "start_line": 310, "end_line": 338, "offset_start": 12342, "offset_end": 13636, "content": "function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [], "stateMutability": null, "returnParameters": [], "visibility": "internal", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.getSeasonUnlockStartTime", "start_line": 341, "end_line": 345, "offset_start": 13673, "offset_end": 13825, "content": "function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [], "stateMutability": "view", "returnParameters": null, "visibility": "external", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.getProjectSeasonConfig", "start_line": 348, "end_line": 353, "offset_start": 13862, "offset_end": 14124, "content": "function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [], "stateMutability": "view", "returnParameters": null, "visibility": "external", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.addTotalDeposited", "start_line": 360, "end_line": 370, "offset_start": 14372, "offset_end": 14868, "content": "function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [], "stateMutability": null, "returnParameters": null, "visibility": "external", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.reduceRefundableAmount", "start_line": 373, "end_line": 388, "offset_start": 14905, "offset_end": 15461, "content": "function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [], "stateMutability": null, "returnParameters": [], "visibility": "external", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.getTokenAmounts", "start_line": 391, "end_line": 395, "offset_start": 15498, "offset_end": 15637, "content": "function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [], "stateMutability": "view", "returnParameters": null, "visibility": "external", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.startRefund", "start_line": 398, "end_line": 416, "offset_start": 15674, "offset_end": 16450, "content": "function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [null, null], "stateMutability": null, "returnParameters": [], "visibility": "external", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory._getTotalLoyaltyRefundEligible", "start_line": 424, "end_line": 442, "offset_start": 16893, "offset_end": 17647, "content": "function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [], "stateMutability": "view", "returnParameters": null, "visibility": "internal", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.isRefunding", "start_line": 445, "end_line": 447, "offset_start": 17684, "offset_end": 17844, "content": "function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [], "stateMutability": "view", "returnParameters": null, "visibility": "external", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.getRefundableAmount", "start_line": 450, "end_line": 459, "offset_start": 17881, "offset_end": 18358, "content": "function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [], "stateMutability": "view", "returnParameters": null, "visibility": "external", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.calcMaxAvailableAmount", "start_line": 462, "end_line": 466, "offset_start": 18395, "offset_end": 18572, "content": "function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [], "stateMutability": "view", "returnParameters": null, "visibility": "external", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory._calcMaxAvailableForWithdrawalOrNewSeason", "start_line": 471, "end_line": 476, "offset_start": 18752, "offset_end": 19027, "content": "function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [], "stateMutability": "pure", "returnParameters": null, "visibility": "private", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.scheduleWithdraw", "start_line": 483, "end_line": 494, "offset_start": 19275, "offset_end": 19689, "content": "function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [null], "stateMutability": null, "returnParameters": [], "visibility": "external", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.cancelWithdraw", "start_line": 497, "end_line": 506, "offset_start": 19726, "offset_end": 20114, "content": "function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [null], "stateMutability": null, "returnParameters": [], "visibility": "external", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.executeWithdraw", "start_line": 509, "end_line": 525, "offset_start": 20151, "offset_end": 20841, "content": "function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [], "stateMutability": null, "returnParameters": null, "visibility": "external", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.getScheduledWithdrawal", "start_line": 528, "end_line": 532, "offset_start": 20878, "offset_end": 21021, "content": "function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [], "stateMutability": "view", "returnParameters": null, "visibility": "external", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory._validateNewWithdrawal", "start_line": 539, "end_line": 550, "offset_start": 21280, "offset_end": 21864, "content": "function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [], "stateMutability": "view", "returnParameters": [], "visibility": "private", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.pauseClaimContract", "start_line": 557, "end_line": 564, "offset_start": 22112, "offset_end": 22337, "content": "function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [null], "stateMutability": null, "returnParameters": [], "visibility": "external", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.unpauseClaimContract", "start_line": 567, "end_line": 576, "offset_start": 22374, "offset_end": 22646, "content": "function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [null], "stateMutability": null, "returnParameters": [], "visibility": "external", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.isClaimContractPaused", "start_line": 579, "end_line": 583, "offset_start": 22683, "offset_end": 22822, "content": "function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [], "stateMutability": "view", "returnParameters": null, "visibility": "public", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory._requireClaimNotPaused", "start_line": 587, "end_line": 593, "offset_start": 22930, "offset_end": 23087, "content": "function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [], "stateMutability": "view", "returnParameters": [], "visibility": "internal", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory._ensureProjectExists", "start_line": 597, "end_line": 601, "offset_start": 23192, "offset_end": 23339, "content": "function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [], "stateMutability": "view", "returnParameters": [], "visibility": "internal", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.getDelegateRegistry", "start_line": 607, "end_line": 609, "offset_start": 23558, "offset_end": 23666, "content": "function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [], "stateMutability": "view", "returnParameters": null, "visibility": "external", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory.setDelegateRegistry", "start_line": 611, "end_line": 615, "offset_start": 23671, "offset_end": 23830, "content": "function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [null], "stateMutability": null, "returnParameters": [], "visibility": "external", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "BUILDFactory._setDelegateRegistry", "start_line": 617, "end_line": 628, "offset_start": 23835, "offset_end": 24206, "content": "function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }", "contract_name": "BUILDFactory", "contract_code": "{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint256;\n\n  /// @inheritdoc ITypeAndVersion\n  string public constant override typeAndVersion = \"BUILDFactory 1.0.0\";\n\n  /// @notice Parameters required to instantiate the BUILDFactory contract\n  struct ConstructorParams {\n    address admin; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e The initial factory admin address\n    uint40 maxUnlockDuration; //         \u2502 The initial max unlock duration\n    uint40 maxUnlockDelay; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f The initial max unlock delay\n    IDelegateRegistry delegateRegistry; // The initial delegate registry contract\n  }\n\n  /// @notice The maximum unlock duration and delay values allowed\n  UnlockMaxConfigs private s_unlockMaxConfigs;\n\n  /// @notice The set of project addresses\n  EnumerableSet.AddressSet private s_projectsList;\n\n  /// @notice The delegate registry contract\n  IDelegateRegistry private s_delegateRegistry;\n\n  /// @notice The project configs\n  mapping(address token => ProjectConfig config) private s_projects;\n\n  /// @notice The season unlock start times for all projects\n  mapping(uint256 seasonId => uint256 unlockStartsAt) private s_seasonUnlockStartTimes;\n\n  /// @notice The project season configs\n  mapping(address token => mapping(uint256 seasonId => ProjectSeasonConfig config)) private\n    s_projectSeasonConfigs;\n\n  /// @notice The amount of tokens that can be refunded to a project for each season\n  /// @dev This is the amount of tokens that corresponds to the credits of the users who have not\n  /// claimed anything yet from the season, and may be refunded for their credits in the future.\n  /// The project can reclaim these tokens if the users don't claim them until the refund phase\n  /// starts.\n  mapping(address token => mapping(uint256 seasonId => uint256 amount)) private s_refundableAmounts;\n\n  /// @notice Mapping of token amounts per project\n  mapping(address token => TokenAmounts) private s_tokenAmounts;\n\n  /// @notice The parameters for a scheduled withdrawal, if any\n  mapping(address token => Withdrawal) private s_withdrawals;\n\n  /// @notice Pause state for claim contracts by project\n  mapping(address token => bool paused) private s_claimPaused;\n\n  /// @notice The basis points denominator for percentages\n  uint256 private constant PERCENTAGE_BASIS_POINTS_DENOMINATOR = 10_000;\n\n  // ================================================================\n  // |                       Initialization                         |\n  // ================================================================\n\n  /// @dev We set the adminRoleTransferDelay to 0 (no delay)\n  /// @dev In AccessControlDefaultAdminRules, we check that params.admin is not a zero address and\n  /// set it as the initial defaultAdmin, with the DEFAULT_ADMIN_ROLE role.\n  constructor(\n    ConstructorParams memory params\n  ) ManagedAccessControl(0, params.admin) {\n    _setUnlockConfigMaxValues(\n      IBUILDFactory.UnlockMaxConfigs({\n        maxUnlockDelay: params.maxUnlockDelay,\n        maxUnlockDuration: params.maxUnlockDuration\n      })\n    );\n    _setDelegateRegistry(params.delegateRegistry);\n  }\n\n  // ================================================================\n  // |                     Project Allowlisting                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addProjects(\n    AddProjectParams[] calldata projects\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Cache array length outside loop\n    uint256 projectsLength = projects.length;\n    for (uint256 i = 0; i < projectsLength; ++i) {\n      AddProjectParams memory params = projects[i];\n      if (\n        params.admin == address(0) || params.token == address(0)\n          || IERC20Metadata(params.token).decimals() == 0\n      ) {\n        revert InvalidAddProjectParams();\n      }\n      ProjectConfig storage project = s_projects[params.token];\n      project.admin = params.admin;\n      s_projectsList.add(params.token);\n\n      emit ProjectAddedOrAdminChanged(params.token, project.admin);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function removeProjects(\n    address[] calldata tokens\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    EnumerableSet.AddressSet storage projectsList = s_projectsList;\n    // Cache array length outside loop\n    uint256 tokensLength = tokens.length;\n    for (uint256 i = 0; i < tokensLength; ++i) {\n      address token = tokens[i];\n      if (!projectsList.remove(token)) {\n        revert ProjectDoesNotExist(token);\n      }\n      delete s_projects[token];\n\n      emit ProjectRemoved(token);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjects() external view override returns (address[] memory) {\n    return s_projectsList.values();\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectConfig(\n    address token\n  ) external view override returns (ProjectConfig memory) {\n    return s_projects[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function deployClaim(\n    address token\n  ) external override whenOpen whenNotPaused returns (IBUILDClaim) {\n    _ensureProjectExists(token);\n    ProjectConfig storage project = s_projects[token];\n    if (msg.sender != project.admin) revert Unauthorized();\n    if (address(project.claim) != address(0)) {\n      revert ClaimAlreadyExists(token, address(project.claim));\n    }\n\n    BUILDClaim claim = new BUILDClaim(token);\n    project.claim = claim;\n    emit ClaimDeployed(token, address(claim));\n    return IBUILDClaim(claim);\n  }\n\n  /// @notice Util to ensure only the claims contract can call a function\n  /// @param token The project token address\n  function _requireRegisteredClaim(\n    address token\n  ) internal view {\n    if (address(s_projects[token].claim) != msg.sender) {\n      revert Unauthorized();\n    }\n  }\n\n  // ================================================================\n  // |                     Season Configuration                     |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function setUnlockConfigMaxValues(\n    UnlockMaxConfigs calldata config\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\n    _setUnlockConfigMaxValues(config);\n  }\n\n  /// @notice Util function to set the maximum unlock duration and delay\n  /// @param config The new maximum unlock duration and unlock delay\n  function _setUnlockConfigMaxValues(\n    UnlockMaxConfigs memory config\n  ) private {\n    if (config.maxUnlockDuration == 0) {\n      revert InvalidZeroMaxUnlockDuration();\n    }\n\n    if (config.maxUnlockDelay == 0) {\n      revert InvalidZeroMaxUnlockDelay();\n    }\n\n    UnlockMaxConfigs storage currentMax = s_unlockMaxConfigs;\n    if (currentMax.maxUnlockDuration != config.maxUnlockDuration) {\n      currentMax.maxUnlockDuration = config.maxUnlockDuration;\n      emit MaxUnlockDurationUpdated(config.maxUnlockDuration);\n    }\n    if (currentMax.maxUnlockDelay != config.maxUnlockDelay) {\n      currentMax.maxUnlockDelay = config.maxUnlockDelay;\n      emit MaxUnlockDelayUpdated(config.maxUnlockDelay);\n    }\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getUnlockConfigMaxValues() external view override returns (UnlockMaxConfigs memory) {\n    return s_unlockMaxConfigs;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setSeasonUnlockStartTime(\n    uint256 seasonId,\n    uint256 unlockStartsAt\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 currentUnlockStartTime = s_seasonUnlockStartTimes[seasonId];\n    // A start time of 0 means it has not been set yet\n    bool hasUnlockStarted = currentUnlockStartTime != 0 && currentUnlockStartTime <= block.timestamp;\n    if (hasUnlockStarted || unlockStartsAt <= block.timestamp) {\n      revert InvalidUnlockStartsAt(seasonId, unlockStartsAt);\n    }\n    s_seasonUnlockStartTimes[seasonId] = unlockStartsAt;\n    emit SeasonUnlockStartTimeUpdated(seasonId, unlockStartsAt);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function setProjectSeasonConfig(\n    SetProjectSeasonParams[] calldata params\n  ) external override whenOpen onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < params.length; ++i) {\n      _setProjectSeasonConfig(params[i]);\n    }\n  }\n\n  /// @notice Internal function to set the project season config\n  /// @dev This function is called by the setProjectSeasonConfig function\n  /// @param params The parameters for the project season config\n  function _setProjectSeasonConfig(\n    SetProjectSeasonParams calldata params\n  ) internal {\n    _requireClaimNotPaused(params.token);\n    _ensureProjectExists(params.token);\n    uint256 unlockStartsAt = s_seasonUnlockStartTimes[params.seasonId];\n    if (unlockStartsAt == 0) {\n      revert SeasonDoesNotExist(params.seasonId);\n    }\n    if (unlockStartsAt <= block.timestamp) {\n      revert SeasonAlreadyStarted(params.seasonId);\n    }\n    ProjectSeasonConfig storage currentConfig =\n      s_projectSeasonConfigs[params.token][params.seasonId];\n    if (currentConfig.isRefunding) {\n      revert ProjectSeasonIsRefunding(params.token, params.seasonId);\n    }\n    ProjectSeasonConfig memory config = params.config;\n    UnlockMaxConfigs memory unlockMaxConfigs = s_unlockMaxConfigs;\n    if (config.isRefunding) {\n      // Ignore the isRefunding flag, starting refund should be done with the startRefund function\n      config.isRefunding = false;\n    }\n    if (config.unlockDuration == 0 || config.unlockDuration > unlockMaxConfigs.maxUnlockDuration) {\n      revert InvalidUnlockDuration(params.seasonId, config.unlockDuration);\n    }\n    if (config.unlockDelay > unlockMaxConfigs.maxUnlockDelay) {\n      revert InvalidUnlockDelay(params.seasonId, config.unlockDelay);\n    }\n    // prevent overflow for UserState.claimed value\n    if (config.tokenAmount == 0 || config.tokenAmount > type(uint248).max) {\n      revert InvalidTokenAmount(params.seasonId);\n    }\n    if (\n      config.baseTokenClaimBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || (\n          config.baseTokenClaimBps == PERCENTAGE_BASIS_POINTS_DENOMINATOR && config.unlockDuration > 1\n        )\n    ) {\n      revert InvalidBaseTokenClaimBps(\n        params.seasonId, config.baseTokenClaimBps, config.unlockDuration\n      );\n    }\n\n    if (\n      config.earlyVestRatioMaxBps > PERCENTAGE_BASIS_POINTS_DENOMINATOR\n        || config.earlyVestRatioMinBps > config.earlyVestRatioMaxBps\n    ) {\n      revert InvalidEarlyVestRatios(config.earlyVestRatioMinBps, config.earlyVestRatioMaxBps);\n    }\n\n    _setSeasonTokenAmount(\n      params.token, params.seasonId, config.tokenAmount, currentConfig.tokenAmount\n    );\n    currentConfig.tokenAmount = config.tokenAmount;\n    currentConfig.baseTokenClaimBps = config.baseTokenClaimBps;\n    currentConfig.unlockDelay = config.unlockDelay;\n    currentConfig.unlockDuration = config.unlockDuration;\n    currentConfig.merkleRoot = config.merkleRoot;\n    currentConfig.earlyVestRatioMinBps = config.earlyVestRatioMinBps;\n    currentConfig.earlyVestRatioMaxBps = config.earlyVestRatioMaxBps;\n\n    emit ProjectSeasonConfigUpdated(params.token, params.seasonId, currentConfig);\n  }\n\n  /// @notice Internal function to set the season allocated and refundable token amounts\n  /// @dev The new amount must be less than or equal to the max available amount, based on the total\n  /// deposit, withdrawal, refunded and season-allocated amounts.\n  /// @param token The project's token address\n  /// @param seasonId The season id\n  /// @param amount The new token amount\n  /// @param currentAmount The current token amount\n  function _setSeasonTokenAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount,\n    uint256 currentAmount\n  ) internal {\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 totalAllocatedAmountBefore = tokenAmounts.totalAllocatedToAllSeasons;\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(tokenAmounts);\n    // If the season is being updated, the current amount allocated to the same season should be\n    // added to the max available amount.\n    // If there is a scheduled withdrawal, the amount should be subtracted from the max available\n    // amount.\n    // The validation for amount > 0 is done in the BUILDFactory.setProjectSeasonConfig that\n    // calls this function.\n    maxAvailable = maxAvailable + currentAmount - s_withdrawals[token].amount;\n    if (amount > maxAvailable) {\n      revert InsufficientFunds(token, seasonId, amount, maxAvailable);\n    }\n    bool isUpdating = currentAmount != 0;\n    if (isUpdating) {\n      tokenAmounts.totalAllocatedToAllSeasons -= currentAmount;\n    }\n    tokenAmounts.totalAllocatedToAllSeasons += amount;\n    s_refundableAmounts[token][seasonId] = amount;\n    emit ProjectTotalAllocatedUpdated(\n      token, totalAllocatedAmountBefore, tokenAmounts.totalAllocatedToAllSeasons\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getSeasonUnlockStartTime(\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    return s_seasonUnlockStartTimes[seasonId];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getProjectSeasonConfig(\n    address token,\n    uint256 seasonId\n  ) external view override returns (ProjectSeasonConfig memory, uint256 seasonUnlockStartTime) {\n    return (s_projectSeasonConfigs[token][seasonId], s_seasonUnlockStartTimes[seasonId]);\n  }\n\n  // ================================================================\n  // |                       Token Accounting                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function addTotalDeposited(address token, uint256 amount) external override returns (uint256) {\n    _requireRegisteredClaim(token);\n    if (amount == 0) {\n      revert InvalidAmount();\n    }\n    TokenAmounts storage tokenAmounts = s_tokenAmounts[token];\n    uint256 newTotalDeposited = tokenAmounts.totalDeposited + amount;\n    tokenAmounts.totalDeposited = newTotalDeposited;\n    emit ProjectTotalDepositedIncreased(token, msg.sender, amount, newTotalDeposited);\n    return newTotalDeposited;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function reduceRefundableAmount(\n    address token,\n    uint256 seasonId,\n    uint256 amount\n  ) external override {\n    _requireRegisteredClaim(token);\n    uint256 currentRefundableAmount = s_refundableAmounts[token][seasonId];\n    // amount cannot be greater than the refundable amount for the project\n    if (amount > currentRefundableAmount) {\n      revert InvalidAmount();\n    }\n    s_refundableAmounts[token][seasonId] -= amount;\n    emit ProjectSeasonRefundableAmountReduced(\n      token, seasonId, amount, currentRefundableAmount - amount\n    );\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getTokenAmounts(\n    address token\n  ) external view override returns (TokenAmounts memory) {\n    return s_tokenAmounts[token];\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function startRefund(\n    address token,\n    uint256 seasonId\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {\n    ProjectSeasonConfig storage config = s_projectSeasonConfigs[token][seasonId];\n    if (config.tokenAmount == 0) {\n      revert ProjectSeasonDoesNotExist(seasonId, token);\n    }\n    if (config.isRefunding) {\n      revert ProjectSeasonIsRefunding(token, seasonId);\n    }\n    config.isRefunding = true;\n\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    s_tokenAmounts[token].totalRefunded += refundEligible + totalLoyaltyRefundEligible;\n    emit ProjectSeasonRefundStarted(token, seasonId);\n  }\n\n  /// @notice Returns the loyalty token amount for users who are eligible for refunds\n  /// @param tokenAmount The total token amount allocated for the season\n  /// @param seasonId The season id\n  /// @param tokenAmount The project token amount for the season\n  /// @param refundEligible The amount of tokens that can be refunded to the project for the season\n  /// @return The loyalty token amount for users who are eligible for refunds\n  function _getTotalLoyaltyRefundEligible(\n    address token,\n    uint256 seasonId,\n    uint256 tokenAmount,\n    uint256 refundEligible\n  ) internal view returns (uint256) {\n    IBUILDClaim.GlobalState memory globalState = s_projects[token].claim.getGlobalState(seasonId);\n    if (globalState.totalLoyalty == 0) {\n      return 0;\n    }\n    // By definition tokenAmount is always greater than or equal to totalLoyaltyIneligible\n    uint256 totalLoyaltyEligible = tokenAmount - globalState.totalLoyaltyIneligible;\n\n    // no loyalty eligible, entire loyalty pool is refundable\n    if (totalLoyaltyEligible == 0) {\n      return globalState.totalLoyalty;\n    }\n    return globalState.totalLoyalty.mulWadDown(refundEligible).divWadDown(totalLoyaltyEligible);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isRefunding(address token, uint256 seasonId) external view override returns (bool) {\n    return s_projectSeasonConfigs[token][seasonId].isRefunding;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getRefundableAmount(\n    address token,\n    uint256 seasonId\n  ) external view override returns (uint256) {\n    ProjectSeasonConfig memory config = s_projectSeasonConfigs[token][seasonId];\n    uint256 refundEligible = s_refundableAmounts[token][seasonId];\n    uint256 totalLoyaltyRefundEligible =\n      _getTotalLoyaltyRefundEligible(token, seasonId, config.tokenAmount, refundEligible);\n    return s_refundableAmounts[token][seasonId] + totalLoyaltyRefundEligible;\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function calcMaxAvailableAmount(\n    address token\n  ) external view override returns (uint256) {\n    return _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n  }\n\n  /// @notice Calculates the maximum available amount that can be used for allocation to a new\n  /// season or withdrawn\n  /// @param tokenAmounts The project's token amounts\n  function _calcMaxAvailableForWithdrawalOrNewSeason(\n    TokenAmounts memory tokenAmounts\n  ) private pure returns (uint256) {\n    return tokenAmounts.totalDeposited + tokenAmounts.totalRefunded - tokenAmounts.totalWithdrawn\n      - tokenAmounts.totalAllocatedToAllSeasons;\n  }\n\n  // ================================================================\n  // |                      Token Withdrawals                       |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function scheduleWithdraw(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (recipient == address(0)) {\n      revert InvalidWithdrawalRecipient(recipient);\n    }\n    _validateNewWithdrawal(token, amount);\n    s_withdrawals[token] = Withdrawal({recipient: recipient, amount: amount});\n    emit WithdrawalScheduled(token, recipient, amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function cancelWithdraw(\n    address token\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    delete s_withdrawals[token];\n    emit WithdrawalCancelled(token, withdrawal.recipient, withdrawal.amount);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function executeWithdraw(\n    address token\n  ) external override returns (IBUILDFactory.Withdrawal memory, uint256) {\n    _requireRegisteredClaim(token);\n    BUILDFactory.Withdrawal memory withdrawal = s_withdrawals[token];\n    if (withdrawal.recipient == address(0) || withdrawal.amount == 0) {\n      revert WithdrawalDoesNotExist(token);\n    }\n    _validateNewWithdrawal(token, withdrawal.amount);\n    s_tokenAmounts[token].totalWithdrawn += withdrawal.amount;\n    delete s_withdrawals[token];\n\n    emit WithdrawalExecuted(\n      token, withdrawal.recipient, withdrawal.amount, s_tokenAmounts[token].totalWithdrawn\n    );\n    return (withdrawal, s_tokenAmounts[token].totalWithdrawn);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function getScheduledWithdrawal(\n    address token\n  ) external view override returns (Withdrawal memory) {\n    return s_withdrawals[token];\n  }\n\n  /// @notice Checks if the withdrawal amount is valid\n  /// @dev Throws if the amount is zero or the project does not have enough tokens to withdraw the\n  /// amount\n  /// @param token The project token address\n  /// @param amount The withdrawal amount\n  function _validateNewWithdrawal(address token, uint256 amount) private view {\n    // Use != 0 instead of > 0 for unsigned integer comparison\n    if (isClaimContractPaused(token) && amount != 0) {\n      // If the claim contract is emergency paused, we bypass the available amount validation and\n      // allow the project to withdraw the remaining tokens.\n      return;\n    }\n    uint256 maxAvailable = _calcMaxAvailableForWithdrawalOrNewSeason(s_tokenAmounts[token]);\n    if (amount == 0 || amount > maxAvailable) {\n      revert InvalidWithdrawalAmount(amount, maxAvailable);\n    }\n  }\n\n  // ================================================================\n  // |                      Pausing Projects                        |\n  // ================================================================\n\n  /// @inheritdoc IBUILDFactory\n  function pauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    _requireClaimNotPaused(token);\n    _ensureProjectExists(token);\n    s_claimPaused[token] = true;\n    emit ClaimPaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function unpauseClaimContract(\n    address token\n  ) external override onlyRole(PAUSER_ROLE) {\n    if (!isClaimContractPaused(token)) {\n      revert ExpectedPause();\n    }\n    _ensureProjectExists(token);\n    s_claimPaused[token] = false;\n    emit ClaimUnpaused(token);\n  }\n\n  /// @inheritdoc IBUILDFactory\n  function isClaimContractPaused(\n    address token\n  ) public view override returns (bool) {\n    return paused() || s_claimPaused[token];\n  }\n\n  /// @notice throws if the claims contract is paused.\n  /// @param token address of the project token\n  function _requireClaimNotPaused(\n    address token\n  ) internal view virtual {\n    if (isClaimContractPaused(token)) {\n      revert EnforcedPause();\n    }\n  }\n\n  /// @notice throws if the project does not exist.\n  /// @param token address of the project token\n  function _ensureProjectExists(\n    address token\n  ) internal view {\n    if (!s_projectsList.contains(token)) revert ProjectDoesNotExist(token);\n  }\n\n  /// ================================================================\n  /// |                     Delegate Registry                        |\n  /// ================================================================\n\n  function getDelegateRegistry() external view returns (IDelegateRegistry) {\n    return s_delegateRegistry;\n  }\n\n  function setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegateRegistry(delegateRegistry);\n  }\n\n  function _setDelegateRegistry(\n    IDelegateRegistry delegateRegistry\n  ) internal {\n    if (address(delegateRegistry) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n    if (address(delegateRegistry) == address(s_delegateRegistry)) {\n      return;\n    }\n    s_delegateRegistry = delegateRegistry;\n    emit DelegateRegistryUpdated(address(delegateRegistry));\n  }\n}", "modifiers": [], "stateMutability": null, "returnParameters": [], "visibility": "internal", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/BUILDFactory.sol"}, {"type": "FunctionDefinition", "name": "ManagedAccessControl.emergencyPause", "start_line": 24, "end_line": 26, "offset_start": 984, "offset_end": 1059, "content": "function emergencyPause() external onlyRole(PAUSER_ROLE) {\n    _pause();\n  }", "contract_name": "ManagedAccessControl", "contract_code": "{\n  /// @notice This is the ID for the pauser role, which is given to the addresses that can pause and\n  /// unpause the contract.\n  /// @dev Hash: 65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n  constructor(\n    uint48 adminRoleTransferDelay,\n    address admin\n  ) AccessControlDefaultAdminRules(adminRoleTransferDelay, admin) {}\n\n  /// @notice This function pauses the contract\n  /// @dev Sets the pause flag to true\n  function emergencyPause() external onlyRole(PAUSER_ROLE) {\n    _pause();\n  }\n\n  /// @notice This function unpauses the contract\n  /// @dev Sets the pause flag to false\n  function emergencyUnpause() external onlyRole(PAUSER_ROLE) {\n    _unpause();\n  }\n\n  /// @notice Closes the contract\n  /// @dev This is an irreversible operation\n  /// @dev Only callable by the default admin\n  /// @dev Only callable when the contract is open\n  function close() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _close();\n  }\n}", "modifiers": [null], "stateMutability": null, "returnParameters": [], "visibility": "external", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/ManagedAccessControl.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/ManagedAccessControl.sol"}, {"type": "FunctionDefinition", "name": "ManagedAccessControl.emergencyUnpause", "start_line": 30, "end_line": 32, "offset_start": 1154, "offset_end": 1233, "content": "function emergencyUnpause() external onlyRole(PAUSER_ROLE) {\n    _unpause();\n  }", "contract_name": "ManagedAccessControl", "contract_code": "{\n  /// @notice This is the ID for the pauser role, which is given to the addresses that can pause and\n  /// unpause the contract.\n  /// @dev Hash: 65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n  constructor(\n    uint48 adminRoleTransferDelay,\n    address admin\n  ) AccessControlDefaultAdminRules(adminRoleTransferDelay, admin) {}\n\n  /// @notice This function pauses the contract\n  /// @dev Sets the pause flag to true\n  function emergencyPause() external onlyRole(PAUSER_ROLE) {\n    _pause();\n  }\n\n  /// @notice This function unpauses the contract\n  /// @dev Sets the pause flag to false\n  function emergencyUnpause() external onlyRole(PAUSER_ROLE) {\n    _unpause();\n  }\n\n  /// @notice Closes the contract\n  /// @dev This is an irreversible operation\n  /// @dev Only callable by the default admin\n  /// @dev Only callable when the contract is open\n  function close() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _close();\n  }\n}", "modifiers": [null], "stateMutability": null, "returnParameters": [], "visibility": "external", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/ManagedAccessControl.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/ManagedAccessControl.sol"}, {"type": "FunctionDefinition", "name": "ManagedAccessControl.close", "start_line": 38, "end_line": 40, "offset_start": 1414, "offset_end": 1487, "content": "function close() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _close();\n  }", "contract_name": "ManagedAccessControl", "contract_code": "{\n  /// @notice This is the ID for the pauser role, which is given to the addresses that can pause and\n  /// unpause the contract.\n  /// @dev Hash: 65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n  constructor(\n    uint48 adminRoleTransferDelay,\n    address admin\n  ) AccessControlDefaultAdminRules(adminRoleTransferDelay, admin) {}\n\n  /// @notice This function pauses the contract\n  /// @dev Sets the pause flag to true\n  function emergencyPause() external onlyRole(PAUSER_ROLE) {\n    _pause();\n  }\n\n  /// @notice This function unpauses the contract\n  /// @dev Sets the pause flag to false\n  function emergencyUnpause() external onlyRole(PAUSER_ROLE) {\n    _unpause();\n  }\n\n  /// @notice Closes the contract\n  /// @dev This is an irreversible operation\n  /// @dev Only callable by the default admin\n  /// @dev Only callable when the contract is open\n  function close() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _close();\n  }\n}", "modifiers": [null], "stateMutability": null, "returnParameters": [], "visibility": "external", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/ManagedAccessControl.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/ManagedAccessControl.sol"}, {"type": "FunctionDefinition", "name": "Closable._close", "start_line": 17, "end_line": 20, "offset_start": 545, "offset_end": 626, "content": "function _close() internal whenOpen {\n    s_isOpen = false;\n    emit Closed();\n  }", "contract_name": "Closable", "contract_code": "{\n  /// @notice This event is emitted when the factory is closed\n  event Closed();\n\n  /// @notice This error is thrown when attempting to close and the factory is already closed\n  error AlreadyClosed();\n\n  /// @notice Whether the contract is open for depositing and claiming\n  bool private s_isOpen = true;\n\n  /// @notice Closes the factory. Irreversible.\n  /// Only callable by the default admin\n  function _close() internal whenOpen {\n    s_isOpen = false;\n    emit Closed();\n  }\n\n  /// @notice Returns whether the contract is open or closed\n  /// @return True if the contract is open\n  function isOpen() external view returns (bool) {\n    return s_isOpen;\n  }\n\n  /// @notice Modifier to check if the contract is open\n  /// @dev Throws AlreadyClosed if the contract is closed\n  modifier whenOpen() {\n    if (!s_isOpen) revert AlreadyClosed();\n    _;\n  }\n}", "modifiers": [null], "stateMutability": null, "returnParameters": [], "visibility": "internal", "node_count": 4, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/Closable.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/Closable.sol"}, {"type": "FunctionDefinition", "name": "Closable.isOpen", "start_line": 24, "end_line": 26, "offset_start": 735, "offset_end": 807, "content": "function isOpen() external view returns (bool) {\n    return s_isOpen;\n  }", "contract_name": "Closable", "contract_code": "{\n  /// @notice This event is emitted when the factory is closed\n  event Closed();\n\n  /// @notice This error is thrown when attempting to close and the factory is already closed\n  error AlreadyClosed();\n\n  /// @notice Whether the contract is open for depositing and claiming\n  bool private s_isOpen = true;\n\n  /// @notice Closes the factory. Irreversible.\n  /// Only callable by the default admin\n  function _close() internal whenOpen {\n    s_isOpen = false;\n    emit Closed();\n  }\n\n  /// @notice Returns whether the contract is open or closed\n  /// @return True if the contract is open\n  function isOpen() external view returns (bool) {\n    return s_isOpen;\n  }\n\n  /// @notice Modifier to check if the contract is open\n  /// @dev Throws AlreadyClosed if the contract is closed\n  modifier whenOpen() {\n    if (!s_isOpen) revert AlreadyClosed();\n    _;\n  }\n}", "modifiers": [], "stateMutability": "view", "returnParameters": null, "visibility": "external", "node_count": 5, "relative_file_path": "./src/dataset/agent-v1-c4/chainlink/Closable.sol", "absolute_file_path": "/Users/xueyue/Desktop/projects/finite-monkey-engine/src/dataset/agent-v1-c4/chainlink/Closable.sol"}]