下面整理了文中关于 Web3 DeFi 借贷平台的各类漏洞，并尽可能涵盖所有细节：

---

## 1. 提前清算（Liquidation Before Default）

- **问题描述：**  
  清算操作应仅在借款人违约（如逾期还款或抵押品价值低于要求阈值）时执行。如果清算条件设置不当，允许在借款人按时还款前就可发起清算，则会导致借款人资金遭受提前夺取的严重风险。

- **示例 1：**  
  - 在 Sherlock 的 TellerV2 审计示例中，通过函数 `lastRepaidTimestamp(loan)` 处理逻辑：  
    - 当还款还未发生时，返回 `acceptedTimestamp`（贷款被接受的时间）；  
    - 清算条件采用 `block.timestamp - lastRepaidTimestamp(loan) > paymentDefaultDuration` 判断。
  - **漏洞点：**  
    如果贷款刚被接受但首笔还款尚未到期，而 `paymentDefaultDuration` 小于还款周期（paymentCycleDuration），则借款人甚至在首笔还款到期前就可以被清算。

- **示例 2：**  
  - 来自 Hats Finance Tempus Raft 审计：  
    - 在 `liquidate()` 中传入的 `collateralToken` 参数未经过严格校验，可传入零地址或与借款人抵押品无关的代币地址；  
    - 用这种“不存在的”抵押品价格计算，可能导致计算出的抵押品价值为 0 或错误，从而允许在借款人未违约时触发清算。

- **防范措施：**  
  - 清算条件应基于下次还款到期时间为参考，确保只有在还款逾期一定时才允许清算。  
  - 严格验证传入的参数，确保抵押品代币与借款人的实际抵押资产一致。

---

## 2. 借款人不可被清算漏洞（Borrower Can't Be Liquidated）

- **问题描述：**  
  借款人可能利用合约漏洞，导致其抵押品被错误修改或覆盖，从而使得贷款在违约状态下无法被正确清算。

- **示例：**  
  - 在 Sherlock TellerV2 示例中，借款人在 `commitCollateral(loanId, token, amount)` 函数中：  
    - 使用 OpenZeppelin 的 `EnumerableSetUpgradeable.AddressSet.add()` 添加抵押代币，不检查其返回值；  
    - 如果该代币已存在，`add()` 返回 `false`，但函数继续执行，导致原有抵押记录的数量可以被覆盖（例如传入 0 数值），使得后续清算时抵押品数量错误，保护不到贷方。

- **防范措施：**  
  - 检查 `AddressSet.add()` 的返回值，确保一旦抵押代币已存在，不允许随意修改其金额；  
  - 在贷款创建并验证后，应禁止借款人对已提交的抵押品进行覆盖性修改。

---

## 3. 债务关闭而无需全额还款（Debt Closed Without Repayment）

- **问题描述：**  
  若借款人能通过传入不存在的信贷 ID 来调用 `close()`，合约可能返回默认的空 Credit 结构，导致部分检查失效，从而使贷款状态错误标记为“已还清”，而实际上借款人并未偿还本金。

- **示例：**  
  - 在 DebtDAO 审计示例中：  
    - 函数 `close(bytes32 id)` 未验证传入的 ID 是否存在，在 ID 不存在时返回默认 Credit；  
    - 随后在 `_close()` 中，由于 `credit.principal` 为 0，借款人即可调用关闭操作；  
    - 每次调用都会递减内部计数器 `count`，最终可能将整个贷款标记为已还清，且贷方资金归还操作也可能触发（或部分清算），但实际借款人未还清贷款。

- **防范措施：**  
  - 在关闭贷款前必须验证传入的 ID 是否存在，并确保 Credit 结构中相关数值有效；  
  - 防止利用空输入误导内部计数器，确保所有借贷状态一致性。

---

## 4. 还款停止而清算仍被允许（Repayments Paused While Liquidations Enabled）

- **问题描述：**  
  如果平台允许暂停还款，但同时清算操作仍开放，则会导致借款人无法还款的同时又能被强制清算。这种不一致状态对借款人极为不利。

- **示例：**  
  - 在 Sherlock 的 Blueberry 示例中：  
    - `repay()` 函数中检测了 `isRepayAllowed()`；  
    - 而 `liquidate()` 则没有同样的检查，导致即使还款被暂停，清算操作仍然可以进行。

- **防范措施：**  
  - 确保如果还款操作暂停，则清算操作也必须一并暂停。  
  - 审查逻辑，使用统一的标识（例如同一函数或状态标记）来决定两者是否同时可执行。

---

## 5. 代币禁止影响现有贷款（Token Disallow Stops Existing Repayment & Liquidation）

- **问题描述：**  
  平台治理可能允许停用之前允许的代币，作为能够用于还款或抵押的资产。如果停用后，原本使用该代币的贷款无法执行还款但仍能清算，会导致贷款双方（借款人和贷方）均面临风险。

- **示例：**  
  - BlueBerry 的更新示例中，如果通过治理将原允许的代币标记为不允许（disallowed），  
  - 借款人已有贷款由于仅能还款但不能清算，或反之，从而出现不一致状态。

- **防范措施：**  
  - 确保治理措施仅适用于新贷款，对于已有贷款，必须继续允许还款和清算操作，保证系统稳定性。

---

## 6. 还款恢复后立即被清算（Borrower Immediately Liquidated After Repayments Resume）

- **问题描述：**  
  如果平台在还款暂停期间发生市场波动，导致借款人状态恶化，一旦还款恢复，清算机器人会立即发动清算，借款人几乎没有挽救机会。

- **示例：**  
  - 当暂停结束后，借款人立即面临清算风险，因为清算机制依然基于当前不健康的风险指标，而借款人却没有足够的缓冲时间。

- **防范措施：**  
  - 在还款恢复后引入一个“宽限期”，宽限期的时长可以依据暂停时间确定，但设有最大上限，确保既保护借款人也不给清算者超高优势。

---

## 7. 清算者以不足还款额获得抵押品（Liquidator Takes Collateral With Insufficient Repayment）

- **问题描述：**  
  在部分清算场景中，清算者只需偿还部分债务即可获得抵押品。然而，若抵押品的分摊比例计算仅基于局部债务位置，而非借款人所有债务的总额，则可能允许清算者通过偿还很少的债务，获得远超比例的抵押品。

- **示例：**  
  - 在 Blueberry 审计示例中：  
    - 通过 `share / oldShare` 的计算方式，只对当前被清算的债务位置进行比例计算；  
    - 如果借款人的债务分布在多个位置，清算者可以只针对最低价值的债务位置进行还款，同时获得全部或大部分抵押品。

- **防范措施：**  
  - 必须确保抵押品比例的计算涵盖借款人全部债务，而非孤立的单个借贷位置。  
  - 加强清算算法，防止清算者滥用部分还款规则。

---

## 8. 无限展期（Infinite Loan Rollover）

- **问题描述：**  
  如果借款人可以无限制地展期他们的贷款，而贷方没有相应的限制措施，就可能出现贷方长期无法收回款项或无法清算借款人的情况，存在极大的资金回收风险。

- **防范措施：**  
  - 对贷款展期次数、展期时长或其他相关参数设置上限，确保贷方风险可控。

---

## 9. 还款转账到零地址（Repayment Sent to Zero Address）

- **问题描述：**  
  在还款过程中，如果执行还款后删除了借款记录，导致结构中如 `loan.lender` 等字段被重置为默认的零地址，那么转账操作可能把还款金额发送到零地址，资金永久丢失。

- **示例：**  
  - 在 Cooler 的 Sherlock 审计示例中：  
    - 先删除了 `loans[loanID]`（清除记录），接着执行 `debt.transferFrom(msg.sender, loan.lender, repaid)`；  
    - 此时 `loan.lender` 已为空，部分代币可能直接转账到地址(0)，虽然有些 ERC20 会 revert，但有许多会悄然执行，导致资金丢失。

- **防范措施：**  
  - 必须避免在转账之前删除存储的贷款记录，或提前读取并保存关键地址信息，确保还款资金不会丢失。

---

## 10. 借款人永久无法还贷（Borrower Permanently Unable To Repay Loan）

- **问题描述：**  
  如果系统进入一种状态，使得借款人始终无法调用 `repay()` 成功（例如因代币被禁用或其他逻辑错误），则借款人会因为无法还贷而面临被清算，且贷方也无法获得还款，双方均遭受损失。

- **防范措施：**  
  - 需要全面测试各种情况下 `repay()` 的可执行性，确保在活跃或逾期状态下借款人均能还贷，除非贷款确实处于清算状态。

---

## 11. 借款人还款部分计入（Borrower Repayment Only Partially Credited）

- **问题描述：**  
  当借款人一次性偿还款项用于多个贷款，若系统仅将还款金额全部转给当前贷款，而未将溢出部分用于后续贷款，则会造成借款人还款仅部分到账，最终导致借款人承担过多利息或被误判违约。

- **防范措施：**  
  - 实现批量还款机制，确保多笔贷款顺序偿还，溢出还款能按顺序用于后续贷款余额的偿还。

---

## 12. 小额欠款无清算激励（No Incentive To Liquidate Small Positions）

- **问题描述：**  
  由于实际链上 gas 费上涨，清算小额不良头寸的清算费可能低于操作成本，导致清算激励不足，从而积累大量“水下”头寸，给系统偿付能力带来风险。

- **防范措施：**  
  - 设定合理的清算费和最低清算激励，或者对清算机制进行补贴，确保所有不良头寸都能被及时清算，从而保障平台整体健康。

---

## 13. 清算后剩余头寸风险加剧（Liquidation Leaves Traders Unhealthier）

- **问题描述：**  
  清算操作应改善借款人的健康度（Health Score）。如果部分清算操作反而降低了剩余头寸的健康水平（例如优先清算较为稳定抵押品，留下风险较高的资产），那么借款人在清算后可能面临更高的违约风险，并可能被二次清算。

- **防范措施：**  
  - 确保清算算法设计为总是提升剩余头寸的安全性，优先清算风险较高或稳定性较差的资产。  
  - 对部分清算策略进行严格测试，确保清算后借款人的健康得分不再恶化。

