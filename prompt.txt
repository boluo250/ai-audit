function swap(address to, bytes memory callData) external {
    _validateCallData(to, callData);
    address approvalAddress = IAugustusSwapper(to).getTokenTransferProxy();
    address fromToken;
    uint256 fromAmount;
    assembly {
      fromToken := mload(add(callData, 68))
      fromAmount := mload(add(callData, 100))
    }
    IERC20(fromToken).safeApprove(approvalAddress, fromAmount);
    (bool success, ) = to.call(callData);
    require(success, "paraswap call reverted");
  }
function _validateCallData(address to, bytes memory callData) internal view {
    require(to == address(0xDEF171Fe48CF0115B1d80b88dc8eAB59176FEe57), "invalid paraswap callee");
    address receiver;
    assembly {
      receiver := mload(add(callData, 196))
    }
    require(receiver == address(this), "invalid paraswap calldata");
  }
// Contract State Variables:
using SafeERC20 for IERC20;

// Function Implementation:
function swap(address to, bytes memory callData) external {
    _validateCallData(to, callData);
    address approvalAddress = IAugustusSwapper(to).getTokenTransferProxy();
    address fromToken;
    uint256 fromAmount;
    assembly {
      fromToken := mload(add(callData, 68))
      fromAmount := mload(add(callData, 100))
    }
    IERC20(fromToken).safeApprove(approvalAddress, fromAmount);
    (bool success, ) = to.call(callData);
    require(success, "paraswap call reverted");
  }

// Contract State Variables:
using SafeERC20 for IERC20;
using SafeCast for uint256;
using Position for Position.Props;
bytes32 requestKey;
bool isSettle;
bytes32 public constant COLLATERAL_TOKEN = keccak256(abi.encode("COLLATERAL_TOKEN"));
bytes32 public constant SIZE_IN_USD = keccak256(abi.encode("SIZE_IN_USD"));
bytes32 public constant SIZE_IN_TOKENS = keccak256(abi.encode("SIZE_IN_TOKENS"));
bytes32 public constant COLLATERAL_AMOUNT = keccak256(abi.encode("COLLATERAL_AMOUNT"));
bytes32 public constant ESTIMATED_GAS_FEE_BASE_AMOUNT_V2_1 = keccak256(abi.encode("ESTIMATED_GAS_FEE_BASE_AMOUNT_V2_1"));
bytes32 public constant ESTIMATED_GAS_FEE_PER_ORACLE_PRICE = keccak256(abi.encode("ESTIMATED_GAS_FEE_PER_ORACLE_PRICE"));
bytes32 public constant ESTIMATED_GAS_FEE_MULTIPLIER_FACTOR = keccak256(abi.encode("ESTIMATED_GAS_FEE_MULTIPLIER_FACTOR"));
bytes32 public constant INCREASE_ORDER_GAS_LIMIT = keccak256(abi.encode("INCREASE_ORDER_GAS_LIMIT"));
bytes32 public constant DECREASE_ORDER_GAS_LIMIT = keccak256(abi.encode("DECREASE_ORDER_GAS_LIMIT"));
bytes32 public constant SWAP_ORDER_GAS_LIMIT = keccak256(abi.encode("SWAP_ORDER_GAS_LIMIT"));
bytes32 public constant SINGLE_SWAP_GAS_LIMIT = keccak256(abi.encode("SINGLE_SWAP_GAS_LIMIT"));
bytes32 public constant POSITION_FEE_FACTOR = keccak256(abi.encode("POSITION_FEE_FACTOR"));
bytes32 public constant EXECUTE_ORDER_FEATURE_DISABLED = keccak256(abi.encode("EXECUTE_ORDER_FEATURE_DISABLED"));
bytes32 public constant IS_LONG = keccak256(abi.encode("IS_LONG"));
bytes32 public constant referralCode = bytes32(0);
uint256 public constant PRECISION = 1e30;
uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
address public orderHandler;
address public liquidationHandler;
address public adlHandler;
IExchangeRouter public gExchangeRouter;
address public gmxRouter;
IDataStore public dataStore;
address public orderVault;
IGmxReader public gmxReader;
address public referralStorage;
address public perpVault;
OrderQueue public queue;
uint256 public minEth;

// Function Implementation:
function afterOrderCancellation(
    bytes32 requestKey,
    Order.OrderType orderType,
    IGmxProxy.OrderResultData memory orderResultData
  ) external {
    if (msg.sender != address(gmxProxy)) {
      revert Error.InvalidCall();
    }
    _gmxLock = false;

    if (orderResultData.isSettle) {
      // Retry settle action.
      nextAction.selector = NextActionSelector.SETTLE_ACTION;
    } else if (orderType == Order.OrderType.MarketSwap) {
      // If GMX swap fails, retry in the next action.
      nextAction.selector = NextActionSelector.SWAP_ACTION;
      // abi.encode(swapAmount, swapDirection): if swap direction is true, swap collateralToken to indexToken
      nextAction.data = abi.encode(swapProgressData.remaining, swapProgressData.isCollateralToIndex);
    } else {
      if (flow == FLOW.DEPOSIT) {
        nextAction.selector = NextActionSelector.INCREASE_ACTION;
        nextAction.data = abi.encode(beenLong);
      } else if (flow == FLOW.WITHDRAW) {
        nextAction.selector = NextActionSelector.WITHDRAW_ACTION;
      } else {
        // If signal change fails, the offchain script starts again from the current status.
        delete flowData;
        delete flow;
      }
    }
    emit GmxPositionCallbackCalled(requestKey, false);
  }

// Contract State Variables:
using SafeERC20 for IERC20;
using SafeCast for uint256;
using Position for Position.Props;
bytes32 requestKey;
bool isSettle;
bytes32 public constant COLLATERAL_TOKEN = keccak256(abi.encode("COLLATERAL_TOKEN"));
bytes32 public constant SIZE_IN_USD = keccak256(abi.encode("SIZE_IN_USD"));
bytes32 public constant SIZE_IN_TOKENS = keccak256(abi.encode("SIZE_IN_TOKENS"));
bytes32 public constant COLLATERAL_AMOUNT = keccak256(abi.encode("COLLATERAL_AMOUNT"));
bytes32 public constant ESTIMATED_GAS_FEE_BASE_AMOUNT_V2_1 = keccak256(abi.encode("ESTIMATED_GAS_FEE_BASE_AMOUNT_V2_1"));
bytes32 public constant ESTIMATED_GAS_FEE_PER_ORACLE_PRICE = keccak256(abi.encode("ESTIMATED_GAS_FEE_PER_ORACLE_PRICE"));
bytes32 public constant ESTIMATED_GAS_FEE_MULTIPLIER_FACTOR = keccak256(abi.encode("ESTIMATED_GAS_FEE_MULTIPLIER_FACTOR"));
bytes32 public constant INCREASE_ORDER_GAS_LIMIT = keccak256(abi.encode("INCREASE_ORDER_GAS_LIMIT"));
bytes32 public constant DECREASE_ORDER_GAS_LIMIT = keccak256(abi.encode("DECREASE_ORDER_GAS_LIMIT"));
bytes32 public constant SWAP_ORDER_GAS_LIMIT = keccak256(abi.encode("SWAP_ORDER_GAS_LIMIT"));
bytes32 public constant SINGLE_SWAP_GAS_LIMIT = keccak256(abi.encode("SINGLE_SWAP_GAS_LIMIT"));
bytes32 public constant POSITION_FEE_FACTOR = keccak256(abi.encode("POSITION_FEE_FACTOR"));
bytes32 public constant EXECUTE_ORDER_FEATURE_DISABLED = keccak256(abi.encode("EXECUTE_ORDER_FEATURE_DISABLED"));
bytes32 public constant IS_LONG = keccak256(abi.encode("IS_LONG"));
bytes32 public constant referralCode = bytes32(0);
uint256 public constant PRECISION = 1e30;
uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
address public orderHandler;
address public liquidationHandler;
address public adlHandler;
IExchangeRouter public gExchangeRouter;
address public gmxRouter;
IDataStore public dataStore;
address public orderVault;
IGmxReader public gmxReader;
address public referralStorage;
address public perpVault;
OrderQueue public queue;
uint256 public minEth;

// Function Implementation:
function afterOrderExecution(
    bytes32 requestKey,
    bytes32 positionKey,
    IGmxProxy.OrderResultData memory orderResultData,
    MarketPrices memory prices
  ) external nonReentrant {
    if (msg.sender != address(gmxProxy)) {
      revert Error.InvalidCall();
    }
    // MarketPrices memory marketPrices = gmxProxy.getMarketPrices(market);
    
    _gmxLock = false;
    // If the current action is `settle`
    if (orderResultData.isSettle) {
      nextAction.selector = NextActionSelector.WITHDRAW_ACTION;
      emit GmxPositionCallbackCalled(requestKey, true);
      return;
    }
    if (orderResultData.orderType == Order.OrderType.MarketIncrease) {
      curPositionKey = positionKey;
      if (flow == FLOW.DEPOSIT) {
        uint256 amount = depositInfo[counter].amount;
        uint256 feeAmount = vaultReader.getPositionFeeUsd(market, orderResultData.sizeDeltaUsd, false) / prices.shortTokenPrice.min;
        uint256 prevSizeInTokens = flowData;
        int256 priceImpact = vaultReader.getPriceImpactInCollateral(curPositionKey, orderResultData.sizeDeltaUsd, prevSizeInTokens, prices);
        uint256 increased;
        if (priceImpact > 0) {
          increased = amount - feeAmount - uint256(priceImpact) - 1;
        } else {
          increased = amount - feeAmount + uint256(-priceImpact) - 1;
        }
        _mint(counter, increased, false, prices);
        nextAction.selector = NextActionSelector.FINALIZE;
      } else {
        _updateState(false, orderResultData.isLong);
      }
    } else if (orderResultData.orderType == Order.OrderType.MarketDecrease) {
      uint256 sizeInUsd = vaultReader.getPositionSizeInUsd(curPositionKey);
      if (sizeInUsd == 0) {
        delete curPositionKey;
      }
      if (flow == FLOW.WITHDRAW) {
        nextAction.selector = NextActionSelector.FINALIZE;
        uint256 prevCollateralBalance = collateralToken.balanceOf(address(this)) - orderResultData.outputAmount;
        nextAction.data = abi.encode(prevCollateralBalance, sizeInUsd == 0, false);
      } else {
        _updateState(true, false);
      }
    } else if (orderResultData.orderType == Order.OrderType.MarketSwap) {
      uint256 outputAmount = orderResultData.outputAmount;
      if (swapProgressData.isCollateralToIndex) {
        emit GmxSwap(
          address(collateralToken),
          swapProgressData.remaining,
          indexToken,
          outputAmount,
          true
        );
      } else {
        emit GmxSwap(
          indexToken,
          swapProgressData.remaining,
          address(collateralToken),
          outputAmount,
          false
        );
      }
      
      if (flow == FLOW.DEPOSIT) {
        _mint(counter, outputAmount + swapProgressData.swapped, false, prices);
        _finalize(hex'');
      } else if (flow == FLOW.WITHDRAW) {
        _handleReturn(outputAmount + swapProgressData.swapped, false, false);
      } else {  // Same as if (flow == FLOW.SIGNAL_CHANGE || FLOW.COMPOUND)
        if (orderResultData.outputToken == indexToken) {
          _updateState(false, true);
        } else {
          _updateState(true, false);
        }
      }
    }
    
    emit GmxPositionCallbackCalled(requestKey, true);
    if (flow == FLOW.SIGNAL_CHANGE) {
      emit GmxPositionUpdated(
        positionKey,
        market,
        orderResultData.orderType == Order.OrderType.MarketIncrease,
        orderResultData.isLong,
        orderResultData.sizeDeltaUsd,
        prices.indexTokenPrice.min
      );
    }
  }

// Contract State Variables:
using SafeERC20 for IERC20;
bool isCollateralToIndex;
uint256 swapped;
uint256 remaining;
NextActionSelector selector;
bytes data;
uint256 amount;
uint256 shares;
address owner;
uint256 executionFee;
uint256 timestamp;
address recipient;
uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
uint256 constant ONE_USD = 1e30;
uint256 public totalShares;
uint256 counter;
mapping (uint256 => DepositInfo) public depositInfo;
mapping (address => EnumerableSet.UintSet) userDeposits;
address public market;
address public indexToken;
IERC20 public collateralToken;
IGmxProxy public gmxProxy;
IVaultReader public vaultReader;
address public keeper;
address public treasury;
bytes32 public curPositionKey;
uint256 public maxDepositAmount;
uint256 public minDepositAmount;
uint256 public totalDepositAmount;
uint256 public governanceFee;
uint256 public callbackGasLimit;

// Function Implementation:
function _doDexSwap(bytes memory data, bool isCollateralToIndex) internal returns (uint256 outputAmount) {
    (address to, uint256 amount, bytes memory callData) = abi.decode(data, (address, uint256, bytes));
    IERC20 inputToken;
    IERC20 outputToken;
    if (isCollateralToIndex) {
      inputToken = collateralToken;
      outputToken = IERC20(indexToken);
    } else {
      inputToken = IERC20(indexToken);
      outputToken = collateralToken;
    }
    uint256 balBefore = outputToken.balanceOf(address(this));
    ParaSwapUtils.swap(to, callData);
    outputAmount = IERC20(outputToken).balanceOf(address(this)) - balBefore;
    emit DexSwap(address(inputToken), amount, address(outputToken), outputAmount, isCollateralToIndex);
  }

// Contract State Variables:
using SafeERC20 for IERC20;
bool isCollateralToIndex;
uint256 swapped;
uint256 remaining;
NextActionSelector selector;
bytes data;
uint256 amount;
uint256 shares;
address owner;
uint256 executionFee;
uint256 timestamp;
address recipient;
uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
uint256 constant ONE_USD = 1e30;
uint256 public totalShares;
uint256 counter;
mapping (uint256 => DepositInfo) public depositInfo;
mapping (address => EnumerableSet.UintSet) userDeposits;
address public market;
address public indexToken;
IERC20 public collateralToken;
IGmxProxy public gmxProxy;
IVaultReader public vaultReader;
address public keeper;
address public treasury;
bytes32 public curPositionKey;
uint256 public maxDepositAmount;
uint256 public minDepositAmount;
uint256 public totalDepositAmount;
uint256 public governanceFee;
uint256 public callbackGasLimit;

// Function Implementation:
function _runSwap(bytes[] memory metadata, bool isCollateralToIndex, MarketPrices memory prices) internal returns (bool completed) {
    if (metadata.length == 0) {
      revert Error.InvalidData();
    }
    if (metadata.length == 2) {
      (PROTOCOL _protocol, bytes memory data) = abi.decode(metadata[0], (PROTOCOL, bytes));
      if (_protocol != PROTOCOL.DEX) {
        revert Error.InvalidData();
      }
      swapProgressData.swapped = swapProgressData.swapped + _doDexSwap(data, isCollateralToIndex);
      
      (_protocol, data) = abi.decode(metadata[1], (PROTOCOL, bytes));
      if (_protocol != PROTOCOL.GMX) {
        revert Error.InvalidData();
      }

      _doGmxSwap(data, isCollateralToIndex);
      return false;
    } else {
      if (metadata.length != 1) {
        revert Error.InvalidData();
      }
      (PROTOCOL _protocol, bytes memory data) = abi.decode(metadata[0], (PROTOCOL, bytes));
      if (_protocol == PROTOCOL.DEX) {
        uint256 outputAmount = _doDexSwap(data, isCollateralToIndex);
        
        // update global state
        if (flow == FLOW.DEPOSIT) {
          // last `depositId` equals with `counter` because another deposit is not allowed before previous deposit is completely processed
          _mint(counter, outputAmount + swapProgressData.swapped, true, prices);
        } else if (flow == FLOW.WITHDRAW) {
          _handleReturn(outputAmount + swapProgressData.swapped, false, true);
        } else {
          // in the flow of SIGNAL_CHANGE, if `isCollateralToIndex` is true, it is opening position, or closing position
          _updateState(!isCollateralToIndex, isCollateralToIndex);
        }
        
        return true;
      } else {
        _doGmxSwap(data, isCollateralToIndex);
        return false;
      }
    }
  }

// Contract State Variables:
using SafeCast for int256;
uint256 constant BPS = 10_000;
uint256 private constant GRACE_PERIOD_TIME = 3600;
AggregatorV2V3Interface internal sequencerUptimeFeed;
mapping (address => address) public dataFeed;
uint256 threshold;
mapping (address => uint256) public maxTimeWindow;
mapping (address => bool) public keepers;
mapping (address => uint256) public priceDiffThreshold;

// Function Implementation:
function run(
    bool isOpen,
    bool isLong,
    MarketPrices memory prices,
    bytes[] memory metadata
  ) external nonReentrant {
    _noneFlow();
    _onlyKeeper();
    if (gmxProxy.lowerThanMinEth()) {
      revert Error.LowerThanMinEth();
    }
    flow = FLOW.SIGNAL_CHANGE;

    if (isOpen) {
      if (positionIsClosed) {
        if (_isFundIdle() == false) {
          revert Error.InsufficientAmount();
        }
        if (_isLongOneLeverage(isLong)) {
          _runSwap(metadata, true, prices);
        } else {
          (uint256 acceptablePrice) = abi.decode(metadata[0], (uint256));
          _createIncreasePosition(isLong, acceptablePrice, prices);
        }
      } else {
        if (beenLong == isLong) {
          revert Error.NoAction();
        } else {
          // Close current position first and then open the requested position in the next action
          nextAction.selector = NextActionSelector.INCREASE_ACTION;
          nextAction.data = abi.encode(isLong);
          if (_isLongOneLeverage(beenLong)) {
            _runSwap(metadata, false, prices);
          } else {
            (uint256 acceptablePrice) = abi.decode(metadata[0], (uint256));
            _createDecreasePosition(0, 0, beenLong, acceptablePrice, prices);
          }
        }
      }
    } else {
      if (positionIsClosed == false) {
        if (_isLongOneLeverage(beenLong)) {
          _runSwap(metadata, false, prices);
        } else {
          (uint256 acceptablePrice) = abi.decode(metadata[0], (uint256));
          _createDecreasePosition(0, 0, beenLong, acceptablePrice, prices);
        }
      } else {
        revert Error.NoAction();
      }
    }
  }

// Contract State Variables:
using SafeERC20 for IERC20;
bool isCollateralToIndex;
uint256 swapped;
uint256 remaining;
NextActionSelector selector;
bytes data;
uint256 amount;
uint256 shares;
address owner;
uint256 executionFee;
uint256 timestamp;
address recipient;
uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
uint256 constant ONE_USD = 1e30;
uint256 public totalShares;
uint256 counter;
mapping (uint256 => DepositInfo) public depositInfo;
mapping (address => EnumerableSet.UintSet) userDeposits;
address public market;
address public indexToken;
IERC20 public collateralToken;
IGmxProxy public gmxProxy;
IVaultReader public vaultReader;
address public keeper;
address public treasury;
bytes32 public curPositionKey;
uint256 public maxDepositAmount;
uint256 public minDepositAmount;
uint256 public totalDepositAmount;
uint256 public governanceFee;
uint256 public callbackGasLimit;

// Function Implementation:
function _cancelFlow() internal {
    if (flow == FLOW.DEPOSIT) {
      uint256 depositId = counter;
      collateralToken.safeTransfer(depositInfo[depositId].owner, depositInfo[depositId].amount);
      totalDepositAmount = totalDepositAmount - depositInfo[depositId].amount;
      EnumerableSet.remove(userDeposits[depositInfo[depositId].owner], depositId);
      try IGmxProxy(gmxProxy).refundExecutionFee(
        depositInfo[counter].owner,
        depositInfo[counter].executionFee
      ) {} catch {}
      delete depositInfo[depositId];
    } else if (flow == FLOW.WITHDRAW) {
      try IGmxProxy(gmxProxy).refundExecutionFee(
        depositInfo[counter].owner,
        depositInfo[counter].executionFee
      ) {} catch {}
    }
    
    // Setting flow to liquidation has no meaning.
    // The aim is to run FINAIZE action. (swap indexToken to collateralToken);
    flow = FLOW.LIQUIDATION;
    nextAction.selector = NextActionSelector.FINALIZE;
  }

// Contract State Variables:
using SafeCast for int256;
uint256 constant BPS = 10_000;
uint256 private constant GRACE_PERIOD_TIME = 3600;
AggregatorV2V3Interface internal sequencerUptimeFeed;
mapping (address => address) public dataFeed;
uint256 threshold;
mapping (address => uint256) public maxTimeWindow;
mapping (address => bool) public keepers;
mapping (address => uint256) public priceDiffThreshold;

// Function Implementation:
function cancelFlow() external nonReentrant gmxLock {
    _onlyKeeper();
    _cancelFlow();
  }

// Contract State Variables:
using SafeCast for int256;
uint256 constant BPS = 10_000;
uint256 private constant GRACE_PERIOD_TIME = 3600;
AggregatorV2V3Interface internal sequencerUptimeFeed;
mapping (address => address) public dataFeed;
uint256 threshold;
mapping (address => uint256) public maxTimeWindow;
mapping (address => bool) public keepers;
mapping (address => uint256) public priceDiffThreshold;

// Function Implementation:
function runNextAction(MarketPrices memory prices, bytes[] memory metadata) external nonReentrant gmxLock {
    _onlyKeeper();
    Action memory _nextAction = nextAction;
    delete nextAction;
    if (_nextAction.selector == NextActionSelector.INCREASE_ACTION) {
      (bool _isLong) = abi.decode(_nextAction.data, (bool));

      if (_isLongOneLeverage(_isLong)) {
        _runSwap(metadata, true, prices);
      } else {
        // swap indexToken that could be generated from the last action into collateralToken
        // use only DexSwap
        if (
          IERC20(indexToken).balanceOf(address(this)) * prices.indexTokenPrice.min >= ONE_USD
        ) {
          (, bytes memory data) = abi.decode(metadata[1], (PROTOCOL, bytes));
          _doDexSwap(data, false);
        }
        (uint256 acceptablePrice) = abi.decode(metadata[0], (uint256));
        _createIncreasePosition(_isLong, acceptablePrice, prices);
      }
    } else if (_nextAction.selector == NextActionSelector.WITHDRAW_ACTION) {
      // swap indexToken that could be generated from settle action or liquidation/ADL into collateralToken
      // use only DexSwap
      if (
        IERC20(indexToken).balanceOf(address(this)) * prices.indexTokenPrice.min >= ONE_USD
      ) {
        (, bytes memory data) = abi.decode(metadata[1], (PROTOCOL, bytes));
        _doDexSwap(data, false);
      }
      uint256 depositId = flowData;
      _withdraw(depositId, metadata[0], prices);
    } else if (_nextAction.selector == NextActionSelector.SWAP_ACTION) {
      (, bool isCollateralToIndex) = abi.decode(
        _nextAction.data,
        (uint256, bool)
      );
      _runSwap(metadata, isCollateralToIndex, prices);
    } else if (_nextAction.selector == NextActionSelector.SETTLE_ACTION) {
      _settle();
    } else if (_nextAction.selector == NextActionSelector.FINALIZE) {
      if (
        IERC20(indexToken).balanceOf(address(this)) * prices.indexTokenPrice.min >= ONE_USD
      ) {
        (, bytes memory data) = abi.decode(metadata[1], (PROTOCOL, bytes));
        _doDexSwap(data, false);
      }
      _finalize(_nextAction.data);
    } else if (positionIsClosed == false && _isFundIdle()) {
      flow = FLOW.COMPOUND;
      if (_isLongOneLeverage(beenLong)) {
        _runSwap(metadata, true, prices);
      } else {
        (uint256 acceptablePrice) = abi.decode(metadata[0], (uint256));
        _createIncreasePosition(beenLong, acceptablePrice, prices);
      }
    } else {
      revert Error.InvalidCall();
    }
  }

// Contract State Variables:
using SafeERC20 for IERC20;
using SafeCast for uint256;
using Position for Position.Props;
bytes32 requestKey;
bool isSettle;
bytes32 public constant COLLATERAL_TOKEN = keccak256(abi.encode("COLLATERAL_TOKEN"));
bytes32 public constant SIZE_IN_USD = keccak256(abi.encode("SIZE_IN_USD"));
bytes32 public constant SIZE_IN_TOKENS = keccak256(abi.encode("SIZE_IN_TOKENS"));
bytes32 public constant COLLATERAL_AMOUNT = keccak256(abi.encode("COLLATERAL_AMOUNT"));
bytes32 public constant ESTIMATED_GAS_FEE_BASE_AMOUNT_V2_1 = keccak256(abi.encode("ESTIMATED_GAS_FEE_BASE_AMOUNT_V2_1"));
bytes32 public constant ESTIMATED_GAS_FEE_PER_ORACLE_PRICE = keccak256(abi.encode("ESTIMATED_GAS_FEE_PER_ORACLE_PRICE"));
bytes32 public constant ESTIMATED_GAS_FEE_MULTIPLIER_FACTOR = keccak256(abi.encode("ESTIMATED_GAS_FEE_MULTIPLIER_FACTOR"));
bytes32 public constant INCREASE_ORDER_GAS_LIMIT = keccak256(abi.encode("INCREASE_ORDER_GAS_LIMIT"));
bytes32 public constant DECREASE_ORDER_GAS_LIMIT = keccak256(abi.encode("DECREASE_ORDER_GAS_LIMIT"));
bytes32 public constant SWAP_ORDER_GAS_LIMIT = keccak256(abi.encode("SWAP_ORDER_GAS_LIMIT"));
bytes32 public constant SINGLE_SWAP_GAS_LIMIT = keccak256(abi.encode("SINGLE_SWAP_GAS_LIMIT"));
bytes32 public constant POSITION_FEE_FACTOR = keccak256(abi.encode("POSITION_FEE_FACTOR"));
bytes32 public constant EXECUTE_ORDER_FEATURE_DISABLED = keccak256(abi.encode("EXECUTE_ORDER_FEATURE_DISABLED"));
bytes32 public constant IS_LONG = keccak256(abi.encode("IS_LONG"));
bytes32 public constant referralCode = bytes32(0);
uint256 public constant PRECISION = 1e30;
uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
address public orderHandler;
address public liquidationHandler;
address public adlHandler;
IExchangeRouter public gExchangeRouter;
address public gmxRouter;
IDataStore public dataStore;
address public orderVault;
IGmxReader public gmxReader;
address public referralStorage;
address public perpVault;
OrderQueue public queue;
uint256 public minEth;

// Function Implementation:
function createOrder(
    Order.OrderType orderType,
    IGmxProxy.OrderData memory orderData
  ) public returns (bytes32) {
    require(msg.sender == perpVault, "invalid caller");
    uint256 positionExecutionFee = getExecutionGasLimit(
      orderType,
      orderData.callbackGasLimit
    ) * tx.gasprice;
    require(
      address(this).balance >= positionExecutionFee,
      "insufficient eth balance"
    );
    
    // check if execution feature is enabled
    bytes32 executeOrderFeatureKey = keccak256(
      abi.encode(
        EXECUTE_ORDER_FEATURE_DISABLED,
        orderHandler,
        orderType
      )
    );
    require(
      dataStore.getBool(executeOrderFeatureKey) == false,
      "gmx execution disabled"
    );

    gExchangeRouter.sendWnt{value: positionExecutionFee}(
      orderVault,
      positionExecutionFee
    );
    if (
      orderType == Order.OrderType.MarketSwap ||
      orderType == Order.OrderType.MarketIncrease
    ) {
      IERC20(orderData.initialCollateralToken).safeApprove(
        address(gmxRouter),
        orderData.amountIn
      );
      gExchangeRouter.sendTokens(
        orderData.initialCollateralToken,
        orderVault,
        orderData.amountIn
      );
    }
    CreateOrderParamsAddresses memory paramsAddresses = CreateOrderParamsAddresses({
      receiver: perpVault,
      cancellationReceiver: address(perpVault),
      callbackContract: address(this),
      uiFeeReceiver: address(0),
      market: orderData.market,
      initialCollateralToken: orderData.initialCollateralToken,
      swapPath: orderData.swapPath
    });

    CreateOrderParamsNumbers memory paramsNumber = CreateOrderParamsNumbers({
      sizeDeltaUsd: orderData.sizeDeltaUsd,
      initialCollateralDeltaAmount: orderData.initialCollateralDeltaAmount,
      triggerPrice: 0,
      acceptablePrice: orderData.acceptablePrice,
      executionFee: positionExecutionFee,
      callbackGasLimit: orderData.callbackGasLimit,
      minOutputAmount: orderData.minOutputAmount,      // this param is used when swapping. is not used in opening position even though swap involved.
      validFromTime: 0
    });
    CreateOrderParams memory params = CreateOrderParams({
      addresses: paramsAddresses,
      numbers: paramsNumber,
      orderType: orderType,
      decreasePositionSwapType: Order
        .DecreasePositionSwapType
        .SwapPnlTokenToCollateralToken,
      isLong: orderData.isLong,
      shouldUnwrapNativeToken: false,
      autoCancel: false,
      referralCode: referralCode
    });
    bytes32 requestKey = gExchangeRouter.createOrder(params);
    queue.requestKey = requestKey;
    return requestKey;
  }

// Contract State Variables:
using SafeERC20 for IERC20;
using SafeCast for uint256;
using Position for Position.Props;
bytes32 requestKey;
bool isSettle;
bytes32 public constant COLLATERAL_TOKEN = keccak256(abi.encode("COLLATERAL_TOKEN"));
bytes32 public constant SIZE_IN_USD = keccak256(abi.encode("SIZE_IN_USD"));
bytes32 public constant SIZE_IN_TOKENS = keccak256(abi.encode("SIZE_IN_TOKENS"));
bytes32 public constant COLLATERAL_AMOUNT = keccak256(abi.encode("COLLATERAL_AMOUNT"));
bytes32 public constant ESTIMATED_GAS_FEE_BASE_AMOUNT_V2_1 = keccak256(abi.encode("ESTIMATED_GAS_FEE_BASE_AMOUNT_V2_1"));
bytes32 public constant ESTIMATED_GAS_FEE_PER_ORACLE_PRICE = keccak256(abi.encode("ESTIMATED_GAS_FEE_PER_ORACLE_PRICE"));
bytes32 public constant ESTIMATED_GAS_FEE_MULTIPLIER_FACTOR = keccak256(abi.encode("ESTIMATED_GAS_FEE_MULTIPLIER_FACTOR"));
bytes32 public constant INCREASE_ORDER_GAS_LIMIT = keccak256(abi.encode("INCREASE_ORDER_GAS_LIMIT"));
bytes32 public constant DECREASE_ORDER_GAS_LIMIT = keccak256(abi.encode("DECREASE_ORDER_GAS_LIMIT"));
bytes32 public constant SWAP_ORDER_GAS_LIMIT = keccak256(abi.encode("SWAP_ORDER_GAS_LIMIT"));
bytes32 public constant SINGLE_SWAP_GAS_LIMIT = keccak256(abi.encode("SINGLE_SWAP_GAS_LIMIT"));
bytes32 public constant POSITION_FEE_FACTOR = keccak256(abi.encode("POSITION_FEE_FACTOR"));
bytes32 public constant EXECUTE_ORDER_FEATURE_DISABLED = keccak256(abi.encode("EXECUTE_ORDER_FEATURE_DISABLED"));
bytes32 public constant IS_LONG = keccak256(abi.encode("IS_LONG"));
bytes32 public constant referralCode = bytes32(0);
uint256 public constant PRECISION = 1e30;
uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
address public orderHandler;
address public liquidationHandler;
address public adlHandler;
IExchangeRouter public gExchangeRouter;
address public gmxRouter;
IDataStore public dataStore;
address public orderVault;
IGmxReader public gmxReader;
address public referralStorage;
address public perpVault;
OrderQueue public queue;
uint256 public minEth;

// Function Implementation:
function settle(
    IGmxProxy.OrderData memory orderData
  ) external returns (bytes32) {
    require(msg.sender == perpVault, "invalid caller");
    uint256 positionExecutionFee = getExecutionGasLimit(
      Order.OrderType.MarketDecrease,
      orderData.callbackGasLimit
    ) * tx.gasprice;
    require(
      address(this).balance >= positionExecutionFee,
      "insufficient eth balance"
    );
    gExchangeRouter.sendWnt{value: positionExecutionFee}(
      orderVault,
      positionExecutionFee
    );
    CreateOrderParamsAddresses memory paramsAddresses = CreateOrderParamsAddresses({
      receiver: perpVault,
      cancellationReceiver: address(perpVault),
      callbackContract: address(this),
      uiFeeReceiver: address(0),
      market: orderData.market,
      initialCollateralToken: orderData.initialCollateralToken,
      swapPath: new address[](0)
    });
    CreateOrderParamsNumbers memory paramsNumber = CreateOrderParamsNumbers({
      sizeDeltaUsd: 0,
      initialCollateralDeltaAmount: 1,
      triggerPrice: 0,
      acceptablePrice: 0,
      executionFee: positionExecutionFee,
      callbackGasLimit: orderData.callbackGasLimit,
      minOutputAmount: 0,      // this param is used when swapping. is not used in opening position even though swap involved.
      validFromTime: 0
    });
    CreateOrderParams memory params = CreateOrderParams({
      addresses: paramsAddresses,
      numbers: paramsNumber,
      orderType: Order.OrderType.MarketDecrease,
      decreasePositionSwapType: Order
        .DecreasePositionSwapType
        .SwapPnlTokenToCollateralToken,
      isLong: orderData.isLong,
      shouldUnwrapNativeToken: false,
      autoCancel: false,
      referralCode: referralCode
    });
    bytes32 requestKey = gExchangeRouter.createOrder(params);
    queue.requestKey = requestKey;
    queue.isSettle = true;
    return requestKey;
  }

// Contract State Variables:
using SafeERC20 for IERC20;
bool isCollateralToIndex;
uint256 swapped;
uint256 remaining;
NextActionSelector selector;
bytes data;
uint256 amount;
uint256 shares;
address owner;
uint256 executionFee;
uint256 timestamp;
address recipient;
uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
uint256 constant ONE_USD = 1e30;
uint256 public totalShares;
uint256 counter;
mapping (uint256 => DepositInfo) public depositInfo;
mapping (address => EnumerableSet.UintSet) userDeposits;
address public market;
address public indexToken;
IERC20 public collateralToken;
IGmxProxy public gmxProxy;
IVaultReader public vaultReader;
address public keeper;
address public treasury;
bytes32 public curPositionKey;
uint256 public maxDepositAmount;
uint256 public minDepositAmount;
uint256 public totalDepositAmount;
uint256 public governanceFee;
uint256 public callbackGasLimit;

// Function Implementation:
function _settle() internal {
    IGmxProxy.OrderData memory orderData = IGmxProxy.OrderData({
      market: market,
      indexToken: indexToken,
      initialCollateralToken: address(collateralToken),
      swapPath: new address[](0),
      isLong: beenLong,
      sizeDeltaUsd: 0,
      initialCollateralDeltaAmount: 0,
      amountIn: 0,
      callbackGasLimit: callbackGasLimit,
      acceptablePrice: 0,
      minOutputAmount: 0
    });
    _gmxLock = true;
    gmxProxy.settle(orderData);
  }

// Contract State Variables:
using SafeERC20 for IERC20;
bool isCollateralToIndex;
uint256 swapped;
uint256 remaining;
NextActionSelector selector;
bytes data;
uint256 amount;
uint256 shares;
address owner;
uint256 executionFee;
uint256 timestamp;
address recipient;
uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
uint256 constant ONE_USD = 1e30;
uint256 public totalShares;
uint256 counter;
mapping (uint256 => DepositInfo) public depositInfo;
mapping (address => EnumerableSet.UintSet) userDeposits;
address public market;
address public indexToken;
IERC20 public collateralToken;
IGmxProxy public gmxProxy;
IVaultReader public vaultReader;
address public keeper;
address public treasury;
bytes32 public curPositionKey;
uint256 public maxDepositAmount;
uint256 public minDepositAmount;
uint256 public totalDepositAmount;
uint256 public governanceFee;
uint256 public callbackGasLimit;

// Function Implementation:
function withdraw(address recipient, uint256 depositId) public payable nonReentrant {
    _noneFlow();
    flow = FLOW.WITHDRAW;
    flowData = depositId;

    if (recipient == address(0)) {
      revert Error.ZeroValue();
    }
    if (depositInfo[depositId].timestamp + lockTime >= block.timestamp) {
      revert Error.Locked();
    }
    if (EnumerableSet.contains(userDeposits[msg.sender], depositId) == false) {
      revert Error.InvalidUser();
    }
    if (depositInfo[depositId].shares == 0) {
      revert Error.ZeroValue();
    }

    depositInfo[depositId].recipient = recipient;
    _payExecutionFee(depositId, false);
    if (curPositionKey != bytes32(0)) {
      nextAction.selector = NextActionSelector.WITHDRAW_ACTION;
      _settle();  // Settles any outstanding fees and updates state before processing withdrawal
    } else {
      MarketPrices memory prices;
      _withdraw(depositId, hex'', prices);
    }
  }

// Contract State Variables:
using SafeERC20 for IERC20;
bool isCollateralToIndex;
uint256 swapped;
uint256 remaining;
NextActionSelector selector;
bytes data;
uint256 amount;
uint256 shares;
address owner;
uint256 executionFee;
uint256 timestamp;
address recipient;
uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
uint256 constant ONE_USD = 1e30;
uint256 public totalShares;
uint256 counter;
mapping (uint256 => DepositInfo) public depositInfo;
mapping (address => EnumerableSet.UintSet) userDeposits;
address public market;
address public indexToken;
IERC20 public collateralToken;
IGmxProxy public gmxProxy;
IVaultReader public vaultReader;
address public keeper;
address public treasury;
bytes32 public curPositionKey;
uint256 public maxDepositAmount;
uint256 public minDepositAmount;
uint256 public totalDepositAmount;
uint256 public governanceFee;
uint256 public callbackGasLimit;

// Function Implementation:
function _finalize(bytes memory data) internal {
    if (flow == FLOW.WITHDRAW) {
      (uint256 prevCollateralBalance, bool positionClosed, bool refundFee) = abi.decode(data, (uint256, bool, bool));
      uint256 withdrawn = collateralToken.balanceOf(address(this)) - prevCollateralBalance;
      _handleReturn(withdrawn, positionClosed, refundFee);
    } else {
      delete swapProgressData;
      delete flowData;
      delete flow;
    }
  }

// Contract State Variables:
using SafeERC20 for IERC20;
bool isCollateralToIndex;
uint256 swapped;
uint256 remaining;
NextActionSelector selector;
bytes data;
uint256 amount;
uint256 shares;
address owner;
uint256 executionFee;
uint256 timestamp;
address recipient;
uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
uint256 constant ONE_USD = 1e30;
uint256 public totalShares;
uint256 counter;
mapping (uint256 => DepositInfo) public depositInfo;
mapping (address => EnumerableSet.UintSet) userDeposits;
address public market;
address public indexToken;
IERC20 public collateralToken;
IGmxProxy public gmxProxy;
IVaultReader public vaultReader;
address public keeper;
address public treasury;
bytes32 public curPositionKey;
uint256 public maxDepositAmount;
uint256 public minDepositAmount;
uint256 public totalDepositAmount;
uint256 public governanceFee;
uint256 public callbackGasLimit;

// Function Implementation:
function deposit(uint256 amount) external nonReentrant payable {
    _noneFlow();
    if (depositPaused == true) {
      revert Error.Paused();
    }
    if (amount < minDepositAmount) {
      revert Error.InsufficientAmount();
    }
    if (totalDepositAmount + amount > maxDepositAmount) {
      revert Error.ExceedMaxDepositCap();
    }
    flow = FLOW.DEPOSIT;
    collateralToken.safeTransferFrom(msg.sender, address(this), amount);
    counter++;
    depositInfo[counter] = DepositInfo(amount, 0, msg.sender, 0, block.timestamp, address(0));
    totalDepositAmount += amount;
    EnumerableSet.add(userDeposits[msg.sender], counter);

    if (positionIsClosed) {
      MarketPrices memory prices;
      _mint(counter, amount, false, prices);
      _finalize(hex'');
    } else {
      _payExecutionFee(counter, true);
      // mint share token in the NextAction to involve off-chain price data and improve security
      nextAction.selector = NextActionSelector.INCREASE_ACTION;
      nextAction.data = abi.encode(beenLong);
    }
  }

// Contract State Variables:
using SafeERC20 for IERC20;
bool isCollateralToIndex;
uint256 swapped;
uint256 remaining;
NextActionSelector selector;
bytes data;
uint256 amount;
uint256 shares;
address owner;
uint256 executionFee;
uint256 timestamp;
address recipient;
uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
uint256 constant ONE_USD = 1e30;
uint256 public totalShares;
uint256 counter;
mapping (uint256 => DepositInfo) public depositInfo;
mapping (address => EnumerableSet.UintSet) userDeposits;
address public market;
address public indexToken;
IERC20 public collateralToken;
IGmxProxy public gmxProxy;
IVaultReader public vaultReader;
address public keeper;
address public treasury;
bytes32 public curPositionKey;
uint256 public maxDepositAmount;
uint256 public minDepositAmount;
uint256 public totalDepositAmount;
uint256 public governanceFee;
uint256 public callbackGasLimit;

// Function Implementation:
function afterLiquidationExecution() external {
    if (msg.sender != address(gmxProxy)) {
      revert Error.InvalidCall();
    }

    depositPaused = true;
    uint256 sizeInTokens = vaultReader.getPositionSizeInTokens(curPositionKey);
    if (sizeInTokens == 0) {
      delete curPositionKey;
    }

    if (flow == FLOW.NONE) {
      flow = FLOW.LIQUIDATION;
      nextAction.selector = NextActionSelector.FINALIZE;
    } else if (flow == FLOW.DEPOSIT) {
      flowData = sizeInTokens;
    } else if (flow == FLOW.WITHDRAW) {
      // restart the withdraw flow even though current step is FINALIZE.
      nextAction.selector = NextActionSelector.WITHDRAW_ACTION;
    }
  }

// Contract State Variables:
using SafeERC20 for IERC20;
using SafeCast for uint256;
using Position for Position.Props;
bytes32 requestKey;
bool isSettle;
bytes32 public constant COLLATERAL_TOKEN = keccak256(abi.encode("COLLATERAL_TOKEN"));
bytes32 public constant SIZE_IN_USD = keccak256(abi.encode("SIZE_IN_USD"));
bytes32 public constant SIZE_IN_TOKENS = keccak256(abi.encode("SIZE_IN_TOKENS"));
bytes32 public constant COLLATERAL_AMOUNT = keccak256(abi.encode("COLLATERAL_AMOUNT"));
bytes32 public constant ESTIMATED_GAS_FEE_BASE_AMOUNT_V2_1 = keccak256(abi.encode("ESTIMATED_GAS_FEE_BASE_AMOUNT_V2_1"));
bytes32 public constant ESTIMATED_GAS_FEE_PER_ORACLE_PRICE = keccak256(abi.encode("ESTIMATED_GAS_FEE_PER_ORACLE_PRICE"));
bytes32 public constant ESTIMATED_GAS_FEE_MULTIPLIER_FACTOR = keccak256(abi.encode("ESTIMATED_GAS_FEE_MULTIPLIER_FACTOR"));
bytes32 public constant INCREASE_ORDER_GAS_LIMIT = keccak256(abi.encode("INCREASE_ORDER_GAS_LIMIT"));
bytes32 public constant DECREASE_ORDER_GAS_LIMIT = keccak256(abi.encode("DECREASE_ORDER_GAS_LIMIT"));
bytes32 public constant SWAP_ORDER_GAS_LIMIT = keccak256(abi.encode("SWAP_ORDER_GAS_LIMIT"));
bytes32 public constant SINGLE_SWAP_GAS_LIMIT = keccak256(abi.encode("SINGLE_SWAP_GAS_LIMIT"));
bytes32 public constant POSITION_FEE_FACTOR = keccak256(abi.encode("POSITION_FEE_FACTOR"));
bytes32 public constant EXECUTE_ORDER_FEATURE_DISABLED = keccak256(abi.encode("EXECUTE_ORDER_FEATURE_DISABLED"));
bytes32 public constant IS_LONG = keccak256(abi.encode("IS_LONG"));
bytes32 public constant referralCode = bytes32(0);
uint256 public constant PRECISION = 1e30;
uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
address public orderHandler;
address public liquidationHandler;
address public adlHandler;
IExchangeRouter public gExchangeRouter;
address public gmxRouter;
IDataStore public dataStore;
address public orderVault;
IGmxReader public gmxReader;
address public referralStorage;
address public perpVault;
OrderQueue public queue;
uint256 public minEth;

// Function Implementation:
function getExecutionGasLimit(bool isDeposit) public view returns (uint256 minExecutionGasLimit) {
    if (positionIsClosed == false) {
      if (_isLongOneLeverage(beenLong)) {
        minExecutionGasLimit = gmxProxy.getExecutionGasLimit(Order.OrderType.MarketSwap, callbackGasLimit);
      } else {
        if (isDeposit) {
          minExecutionGasLimit = gmxProxy.getExecutionGasLimit(Order.OrderType.MarketIncrease, callbackGasLimit);
        } else {
          // withdraw action has 2 gmx call parts: settle + decrease position
          minExecutionGasLimit = gmxProxy.getExecutionGasLimit(Order.OrderType.MarketDecrease, callbackGasLimit) * 2;
        }
      }
    }
  }

// Contract State Variables:
using SafeERC20 for IERC20;
bool isCollateralToIndex;
uint256 swapped;
uint256 remaining;
NextActionSelector selector;
bytes data;
uint256 amount;
uint256 shares;
address owner;
uint256 executionFee;
uint256 timestamp;
address recipient;
uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
uint256 constant ONE_USD = 1e30;
uint256 public totalShares;
uint256 counter;
mapping (uint256 => DepositInfo) public depositInfo;
mapping (address => EnumerableSet.UintSet) userDeposits;
address public market;
address public indexToken;
IERC20 public collateralToken;
IGmxProxy public gmxProxy;
IVaultReader public vaultReader;
address public keeper;
address public treasury;
bytes32 public curPositionKey;
uint256 public maxDepositAmount;
uint256 public minDepositAmount;
uint256 public totalDepositAmount;
uint256 public governanceFee;
uint256 public callbackGasLimit;

// Function Implementation:
function _payExecutionFee(uint256 depositId, bool isDeposit) internal {
    uint256 minExecutionFee = getExecutionGasLimit(isDeposit) * tx.gasprice;

    if (msg.value < minExecutionFee) {
      revert Error.InsufficientAmount();
    }
    if (msg.value > 0) {
      payable(address(gmxProxy)).transfer(msg.value);
      depositInfo[depositId].executionFee = msg.value;
    }
  }

// Contract State Variables:
using SafeERC20 for IERC20;
bool isCollateralToIndex;
uint256 swapped;
uint256 remaining;
NextActionSelector selector;
bytes data;
uint256 amount;
uint256 shares;
address owner;
uint256 executionFee;
uint256 timestamp;
address recipient;
uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
uint256 constant ONE_USD = 1e30;
uint256 public totalShares;
uint256 counter;
mapping (uint256 => DepositInfo) public depositInfo;
mapping (address => EnumerableSet.UintSet) userDeposits;
address public market;
address public indexToken;
IERC20 public collateralToken;
IGmxProxy public gmxProxy;
IVaultReader public vaultReader;
address public keeper;
address public treasury;
bytes32 public curPositionKey;
uint256 public maxDepositAmount;
uint256 public minDepositAmount;
uint256 public totalDepositAmount;
uint256 public governanceFee;
uint256 public callbackGasLimit;

// Function Implementation:
function _createIncreasePosition(
    bool _isLong,
    uint256 acceptablePrice,
    MarketPrices memory prices
  ) internal {
    // Check available amounts to open positions
    uint256 amountIn;
    if (flow == FLOW.DEPOSIT) {
      amountIn = depositInfo[counter].amount;
      flowData = vaultReader.getPositionSizeInTokens(curPositionKey);
    } else {
      amountIn = collateralToken.balanceOf(address(this));
    }

    Order.OrderType orderType = Order.OrderType.MarketIncrease;
    collateralToken.safeTransfer(address(gmxProxy), amountIn);
    uint256 sizeDelta = prices.shortTokenPrice.max * amountIn * leverage / BASIS_POINTS_DIVISOR;
    IGmxProxy.OrderData memory orderData = IGmxProxy.OrderData({
      market: market,
      indexToken: indexToken,
      initialCollateralToken: address(collateralToken),
      swapPath: new address[](0),
      isLong: _isLong,
      sizeDeltaUsd: sizeDelta,
      initialCollateralDeltaAmount: 0,
      amountIn: amountIn,
      callbackGasLimit: callbackGasLimit,
      acceptablePrice: acceptablePrice,
      minOutputAmount: 0
    });
    _gmxLock = true;
    gmxProxy.createOrder(orderType, orderData);
  }

// Contract State Variables:
using SafeERC20 for IERC20;
bool isCollateralToIndex;
uint256 swapped;
uint256 remaining;
NextActionSelector selector;
bytes data;
uint256 amount;
uint256 shares;
address owner;
uint256 executionFee;
uint256 timestamp;
address recipient;
uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
uint256 constant ONE_USD = 1e30;
uint256 public totalShares;
uint256 counter;
mapping (uint256 => DepositInfo) public depositInfo;
mapping (address => EnumerableSet.UintSet) userDeposits;
address public market;
address public indexToken;
IERC20 public collateralToken;
IGmxProxy public gmxProxy;
IVaultReader public vaultReader;
address public keeper;
address public treasury;
bytes32 public curPositionKey;
uint256 public maxDepositAmount;
uint256 public minDepositAmount;
uint256 public totalDepositAmount;
uint256 public governanceFee;
uint256 public callbackGasLimit;

// Function Implementation:
function _createDecreasePosition(
    uint256 collateralDeltaAmount,
    uint256 sizeDeltaInUsd,
    bool _isLong,
    uint256 acceptablePrice,
    MarketPrices memory prices
  ) internal {
    address[] memory swapPath;
    Order.OrderType orderType = Order.OrderType.MarketDecrease;
    uint256 sizeInUsd = vaultReader.getPositionSizeInUsd(curPositionKey);
    if (
      sizeDeltaInUsd == 0 ||
      vaultReader.willPositionCollateralBeInsufficient(
        prices,
        curPositionKey,
        market,
        _isLong,
        sizeDeltaInUsd,
        collateralDeltaAmount
      )
    ) {
      sizeDeltaInUsd = sizeInUsd;
    }
    IGmxProxy.OrderData memory orderData = IGmxProxy.OrderData({
      market: market,
      indexToken: indexToken,
      initialCollateralToken: address(collateralToken),
      swapPath: swapPath,
      isLong: _isLong,
      sizeDeltaUsd: sizeDeltaInUsd,
      initialCollateralDeltaAmount: collateralDeltaAmount,
      amountIn: 0,
      callbackGasLimit: callbackGasLimit,
      acceptablePrice: acceptablePrice,
      minOutputAmount: 0
    });
    _gmxLock = true;
    gmxProxy.createOrder(orderType, orderData);
  }

// Contract State Variables:
using SafeERC20 for IERC20;
bool isCollateralToIndex;
uint256 swapped;
uint256 remaining;
NextActionSelector selector;
bytes data;
uint256 amount;
uint256 shares;
address owner;
uint256 executionFee;
uint256 timestamp;
address recipient;
uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
uint256 constant ONE_USD = 1e30;
uint256 public totalShares;
uint256 counter;
mapping (uint256 => DepositInfo) public depositInfo;
mapping (address => EnumerableSet.UintSet) userDeposits;
address public market;
address public indexToken;
IERC20 public collateralToken;
IGmxProxy public gmxProxy;
IVaultReader public vaultReader;
address public keeper;
address public treasury;
bytes32 public curPositionKey;
uint256 public maxDepositAmount;
uint256 public minDepositAmount;
uint256 public totalDepositAmount;
uint256 public governanceFee;
uint256 public callbackGasLimit;

// Function Implementation:
function _withdraw(uint256 depositId, bytes memory metadata, MarketPrices memory prices) internal {
    uint256 shares = depositInfo[depositId].shares;
    if (shares == 0) {
      revert Error.ZeroValue();
    }
    
    if (positionIsClosed) {
      _handleReturn(0, true, false);
    } else if (_isLongOneLeverage(beenLong)) {  // beenLong && leverage == BASIS_POINTS_DIVISOR
      uint256 swapAmount = IERC20(indexToken).balanceOf(address(this)) * shares / totalShares;
      nextAction.selector = NextActionSelector.SWAP_ACTION;
      // abi.encode(swapAmount, swapDirection): if swap direction is true, swap collateralToken to indexToken
      nextAction.data = abi.encode(swapAmount, false);
    } else if (curPositionKey == bytes32(0)) {    // vault liquidated
      _handleReturn(0, true, false);
    } else {
      IVaultReader.PositionData memory positionData = vaultReader.getPositionInfo(curPositionKey, prices);
      uint256 collateralDeltaAmount = positionData.collateralAmount * shares / totalShares;
      uint256 sizeDeltaInUsd = positionData.sizeInUsd * shares / totalShares;
      // we always charge the position fee of negative price impact case.
      uint256 feeAmount = vaultReader.getPositionFeeUsd(market, sizeDeltaInUsd, false) / prices.shortTokenPrice.max;
      int256 pnl = vaultReader.getPnl(curPositionKey, prices, sizeDeltaInUsd);
      if (pnl < 0) {
        collateralDeltaAmount = collateralDeltaAmount - feeAmount - uint256(-pnl) / prices.shortTokenPrice.max;
      } else {
        collateralDeltaAmount = collateralDeltaAmount - feeAmount;
      }
      uint256 acceptablePrice = abi.decode(metadata, (uint256));
      _createDecreasePosition(collateralDeltaAmount, sizeDeltaInUsd, beenLong, acceptablePrice, prices);
    }
  }

// Contract State Variables:
using SafeERC20 for IERC20;
bool isCollateralToIndex;
uint256 swapped;
uint256 remaining;
NextActionSelector selector;
bytes data;
uint256 amount;
uint256 shares;
address owner;
uint256 executionFee;
uint256 timestamp;
address recipient;
uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
uint256 constant ONE_USD = 1e30;
uint256 public totalShares;
uint256 counter;
mapping (uint256 => DepositInfo) public depositInfo;
mapping (address => EnumerableSet.UintSet) userDeposits;
address public market;
address public indexToken;
IERC20 public collateralToken;
IGmxProxy public gmxProxy;
IVaultReader public vaultReader;
address public keeper;
address public treasury;
bytes32 public curPositionKey;
uint256 public maxDepositAmount;
uint256 public minDepositAmount;
uint256 public totalDepositAmount;
uint256 public governanceFee;
uint256 public callbackGasLimit;

// Function Implementation:
function _doGmxSwap(bytes memory data, bool isCollateralToIndex) internal {
    Order.OrderType orderType = Order.OrderType.MarketSwap;
    (address[] memory gPath, uint256 amountIn, uint256 minOutputAmount) = abi.decode(data, (address[], uint256, uint256));
    swapProgressData.remaining = amountIn;
    swapProgressData.isCollateralToIndex = isCollateralToIndex;

    address tokenIn;
    if (isCollateralToIndex) {
      tokenIn = address(collateralToken);
    } else {
      tokenIn = address(indexToken);
    }
    IERC20(tokenIn).safeTransfer(address(gmxProxy), amountIn);
    
    IGmxProxy.OrderData memory orderData = IGmxProxy.OrderData({
      market: address(0),
      indexToken: address(0),
      initialCollateralToken: tokenIn,
      swapPath: gPath,
      isLong: isCollateralToIndex,    // this param has no meaning in swap order, but uses it to see the swap direction
      sizeDeltaUsd: 0,
      initialCollateralDeltaAmount: 0,
      amountIn: amountIn,
      callbackGasLimit: callbackGasLimit,
      acceptablePrice: 0,
      minOutputAmount: minOutputAmount
    });
    _gmxLock = true;
    gmxProxy.createOrder(orderType, orderData);
  }

// Contract State Variables:
using SafeERC20 for IERC20;

// Function Implementation:
function _validateCallData(address to, bytes memory callData) internal view {
    require(to == address(0xDEF171Fe48CF0115B1d80b88dc8eAB59176FEe57), "invalid paraswap callee");
    address receiver;
    assembly {
      receiver := mload(add(callData, 196))
    }
    require(receiver == address(this), "invalid paraswap calldata");
  }

// Contract State Variables:
using SafeERC20 for IERC20;
bool isCollateralToIndex;
uint256 swapped;
uint256 remaining;
NextActionSelector selector;
bytes data;
uint256 amount;
uint256 shares;
address owner;
uint256 executionFee;
uint256 timestamp;
address recipient;
uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
uint256 constant ONE_USD = 1e30;
uint256 public totalShares;
uint256 counter;
mapping (uint256 => DepositInfo) public depositInfo;
mapping (address => EnumerableSet.UintSet) userDeposits;
address public market;
address public indexToken;
IERC20 public collateralToken;
IGmxProxy public gmxProxy;
IVaultReader public vaultReader;
address public keeper;
address public treasury;
bytes32 public curPositionKey;
uint256 public maxDepositAmount;
uint256 public minDepositAmount;
uint256 public totalDepositAmount;
uint256 public governanceFee;
uint256 public callbackGasLimit;

// Function Implementation:
function _isLongOneLeverage(bool _isLong) internal view returns (bool) {
    return _isLong && leverage == BASIS_POINTS_DIVISOR;
  }

// Contract State Variables:
using SafeERC20 for IERC20;
bool isCollateralToIndex;
uint256 swapped;
uint256 remaining;
NextActionSelector selector;
bytes data;
uint256 amount;
uint256 shares;
address owner;
uint256 executionFee;
uint256 timestamp;
address recipient;
uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
uint256 constant ONE_USD = 1e30;
uint256 public totalShares;
uint256 counter;
mapping (uint256 => DepositInfo) public depositInfo;
mapping (address => EnumerableSet.UintSet) userDeposits;
address public market;
address public indexToken;
IERC20 public collateralToken;
IGmxProxy public gmxProxy;
IVaultReader public vaultReader;
address public keeper;
address public treasury;
bytes32 public curPositionKey;
uint256 public maxDepositAmount;
uint256 public minDepositAmount;
uint256 public totalDepositAmount;
uint256 public governanceFee;
uint256 public callbackGasLimit;

// Function Implementation:
function _noneFlow() internal view {
    if (flow != FLOW.NONE) {
      revert Error.FlowInProgress();
    }
  }

// Contract State Variables:
using SafeCast for uint256;
bytes32 public constant SIZE_IN_USD = keccak256(abi.encode("SIZE_IN_USD"));
bytes32 public constant SIZE_IN_TOKENS = keccak256(abi.encode("SIZE_IN_TOKENS"));
bytes32 public constant POSITION_FEE_FACTOR = keccak256(abi.encode("POSITION_FEE_FACTOR"));
uint256 public constant PRECISION = 1e30;
address public orderHandler;
IDataStore public dataStore;
address public orderVault;
IGmxReader public gmxReader;
address public referralStorage;

// Function Implementation:
function getPnl(
    bytes32 key,
    MarketPrices memory prices,
    uint256 sizeDeltaUsd
  ) external view returns (int256) {
    uint256 sizeInTokens = getPositionSizeInUsd(key);
    if (sizeInTokens == 0) return 0;
    
    PositionInfo memory positionInfo = gmxReader.getPositionInfo(
      address(dataStore),
      referralStorage,
      key,
      prices,
      sizeDeltaUsd,
      address(0),
      true
    );

    return positionInfo.pnlAfterPriceImpactUsd;
  }

// Contract State Variables:
using SafeCast for uint256;
bytes32 public constant SIZE_IN_USD = keccak256(abi.encode("SIZE_IN_USD"));
bytes32 public constant SIZE_IN_TOKENS = keccak256(abi.encode("SIZE_IN_TOKENS"));
bytes32 public constant POSITION_FEE_FACTOR = keccak256(abi.encode("POSITION_FEE_FACTOR"));
uint256 public constant PRECISION = 1e30;
address public orderHandler;
IDataStore public dataStore;
address public orderVault;
IGmxReader public gmxReader;
address public referralStorage;

// Function Implementation:
function getPositionInfo(
    bytes32 key,
    MarketPrices memory prices
  ) external view returns (PositionData memory) {
    uint256 sizeInTokens = getPositionSizeInUsd(key);
    if (sizeInTokens == 0) {
      return PositionData({
        sizeInUsd: 0,
        sizeInTokens: 0,
        collateralAmount: 0,
        netValue: 0,
        pnl: 0,
        isLong: true
      });
    }
    PositionInfo memory positionInfo = gmxReader.getPositionInfo(
      address(dataStore),
      referralStorage,
      key,
      prices,
      uint256(0),
      address(0),
      true
    );
    uint256 netValue = 
      positionInfo.position.numbers.collateralAmount * prices.shortTokenPrice.min +
      positionInfo.fees.funding.claimableLongTokenAmount * prices.longTokenPrice.min +
      positionInfo.fees.funding.claimableShortTokenAmount * prices.shortTokenPrice.min -
      positionInfo.fees.borrowing.borrowingFeeUsd -
      positionInfo.fees.funding.fundingFeeAmount * prices.shortTokenPrice.min -
      positionInfo.fees.positionFeeAmount * prices.shortTokenPrice.min;
    
    if (positionInfo.basePnlUsd >= 0) {
      netValue = netValue + uint256(positionInfo.basePnlUsd);
    } else {
      netValue = netValue - uint256(-positionInfo.basePnlUsd);
    }

    return PositionData({
      sizeInUsd: positionInfo.position.numbers.sizeInUsd,
      sizeInTokens: positionInfo.position.numbers.sizeInTokens,
      collateralAmount: positionInfo.position.numbers.collateralAmount,
      netValue: netValue,
      pnl: positionInfo.basePnlUsd,
      isLong: positionInfo.position.flags.isLong
    });
  }

// Contract State Variables:
using SafeCast for uint256;
bytes32 public constant SIZE_IN_USD = keccak256(abi.encode("SIZE_IN_USD"));
bytes32 public constant SIZE_IN_TOKENS = keccak256(abi.encode("SIZE_IN_TOKENS"));
bytes32 public constant POSITION_FEE_FACTOR = keccak256(abi.encode("POSITION_FEE_FACTOR"));
uint256 public constant PRECISION = 1e30;
address public orderHandler;
IDataStore public dataStore;
address public orderVault;
IGmxReader public gmxReader;
address public referralStorage;

// Function Implementation:
function getPositionSizeInUsd(bytes32 key) public view returns (uint256 sizeInUsd) {
    sizeInUsd = dataStore.getUint(keccak256(abi.encode(key, SIZE_IN_USD)));
  }

// Contract State Variables:
using SafeCast for uint256;
bytes32 public constant SIZE_IN_USD = keccak256(abi.encode("SIZE_IN_USD"));
bytes32 public constant SIZE_IN_TOKENS = keccak256(abi.encode("SIZE_IN_TOKENS"));
bytes32 public constant POSITION_FEE_FACTOR = keccak256(abi.encode("POSITION_FEE_FACTOR"));
uint256 public constant PRECISION = 1e30;
address public orderHandler;
IDataStore public dataStore;
address public orderVault;
IGmxReader public gmxReader;
address public referralStorage;

// Function Implementation:
function willPositionCollateralBeInsufficient(
    MarketPrices memory prices,
    bytes32 positionKey,
    address market,
    bool isLong,
    uint256 sizeDeltaUsd,
    uint256 collateralDeltaAmount
  ) external view returns (bool) {
    if (getPositionSizeInUsd(positionKey) == 0) return true;
    PositionInfo memory positionInfo = gmxReader.getPositionInfo(
      address(dataStore),
      referralStorage,
      positionKey,
      prices,
      uint256(0),
      address(0),
      true
    );
    int256 realizedPnlUsd;
    if (positionInfo.basePnlUsd > 0) {
      realizedPnlUsd = (uint256(positionInfo.basePnlUsd) * sizeDeltaUsd / positionInfo.position.numbers.sizeInUsd).toInt256();
    } else {
      realizedPnlUsd = -(uint256(-positionInfo.basePnlUsd) * uint256(sizeDeltaUsd) / uint256(positionInfo.position.numbers.sizeInUsd)).toInt256();
    }
    MarketUtils.WillPositionCollateralBeSufficientValues memory values = MarketUtils.WillPositionCollateralBeSufficientValues({
      positionSizeInUsd: positionInfo.position.numbers.sizeInUsd - sizeDeltaUsd,
      positionCollateralAmount: positionInfo.position.numbers.collateralAmount - collateralDeltaAmount,
      realizedPnlUsd: realizedPnlUsd,
      openInterestDelta: -int256(sizeDeltaUsd)
    });
    MarketProps memory marketInfo = getMarket(market);
    (bool willBeSufficient, ) = MarketUtils.willPositionCollateralBeSufficient(
      dataStore,
      marketInfo,
      prices,
      isLong,
      values
    );

    return !willBeSufficient;
  }

// Contract State Variables:
using SafeERC20 for IERC20;
bool isCollateralToIndex;
uint256 swapped;
uint256 remaining;
NextActionSelector selector;
bytes data;
uint256 amount;
uint256 shares;
address owner;
uint256 executionFee;
uint256 timestamp;
address recipient;
uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
uint256 constant ONE_USD = 1e30;
uint256 public totalShares;
uint256 counter;
mapping (uint256 => DepositInfo) public depositInfo;
mapping (address => EnumerableSet.UintSet) userDeposits;
address public market;
address public indexToken;
IERC20 public collateralToken;
IGmxProxy public gmxProxy;
IVaultReader public vaultReader;
address public keeper;
address public treasury;
bytes32 public curPositionKey;
uint256 public maxDepositAmount;
uint256 public minDepositAmount;
uint256 public totalDepositAmount;
uint256 public governanceFee;
uint256 public callbackGasLimit;

// Function Implementation:
function _handleReturn(uint256 withdrawn, bool positionClosed, bool refundFee) internal {
    (uint256 depositId) = flowData;
    uint256 shares = depositInfo[depositId].shares;
    uint256 amount;
    if (positionClosed) {
      amount = collateralToken.balanceOf(address(this)) * shares / totalShares;
    } else {
      uint256 balanceBeforeWithdrawal = collateralToken.balanceOf(address(this)) - withdrawn;
      amount = withdrawn + balanceBeforeWithdrawal * shares / totalShares;
    }
    if (amount > 0) {
      _transferToken(depositId, amount);
    }
    emit Burned(depositId, depositInfo[depositId].recipient, depositInfo[depositId].shares, amount);
    _burn(depositId);

    if (refundFee) {
      uint256 usedFee = callbackGasLimit * tx.gasprice;
      if (depositInfo[depositId].executionFee > usedFee) {
        try IGmxProxy(gmxProxy).refundExecutionFee(depositInfo[counter].owner, depositInfo[counter].executionFee - usedFee) {} catch {}
      }
    }

    // update global state
    delete swapProgressData;
    delete flowData;
    delete flow;
  }

// Contract State Variables:
using SafeERC20 for IERC20;
bool isCollateralToIndex;
uint256 swapped;
uint256 remaining;
NextActionSelector selector;
bytes data;
uint256 amount;
uint256 shares;
address owner;
uint256 executionFee;
uint256 timestamp;
address recipient;
uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
uint256 constant ONE_USD = 1e30;
uint256 public totalShares;
uint256 counter;
mapping (uint256 => DepositInfo) public depositInfo;
mapping (address => EnumerableSet.UintSet) userDeposits;
address public market;
address public indexToken;
IERC20 public collateralToken;
IGmxProxy public gmxProxy;
IVaultReader public vaultReader;
address public keeper;
address public treasury;
bytes32 public curPositionKey;
uint256 public maxDepositAmount;
uint256 public minDepositAmount;
uint256 public totalDepositAmount;
uint256 public governanceFee;
uint256 public callbackGasLimit;

// Function Implementation:
function _transferToken(uint256 depositId, uint256 amount) internal {
    uint256 fee;
    if (amount > depositInfo[depositId].amount) {
      fee = (amount - depositInfo[depositId].amount) * governanceFee / BASIS_POINTS_DIVISOR;
      if (fee > 0) {
        collateralToken.safeTransfer(treasury, fee);
      }
    }
    
    try collateralToken.transfer(depositInfo[depositId].recipient, amount - fee) {}
    catch  {
      collateralToken.transfer(treasury, amount - fee);
      emit TokenTranferFailed(depositInfo[depositId].recipient, amount - fee);
    }
    totalDepositAmount -= depositInfo[depositId].amount;
    
    emit GovernanceFeeCollected(address(collateralToken), fee);
  }

// Contract State Variables:
using SafeERC20 for IERC20;
using SafeCast for uint256;
using Position for Position.Props;
bytes32 requestKey;
bool isSettle;
bytes32 public constant COLLATERAL_TOKEN = keccak256(abi.encode("COLLATERAL_TOKEN"));
bytes32 public constant SIZE_IN_USD = keccak256(abi.encode("SIZE_IN_USD"));
bytes32 public constant SIZE_IN_TOKENS = keccak256(abi.encode("SIZE_IN_TOKENS"));
bytes32 public constant COLLATERAL_AMOUNT = keccak256(abi.encode("COLLATERAL_AMOUNT"));
bytes32 public constant ESTIMATED_GAS_FEE_BASE_AMOUNT_V2_1 = keccak256(abi.encode("ESTIMATED_GAS_FEE_BASE_AMOUNT_V2_1"));
bytes32 public constant ESTIMATED_GAS_FEE_PER_ORACLE_PRICE = keccak256(abi.encode("ESTIMATED_GAS_FEE_PER_ORACLE_PRICE"));
bytes32 public constant ESTIMATED_GAS_FEE_MULTIPLIER_FACTOR = keccak256(abi.encode("ESTIMATED_GAS_FEE_MULTIPLIER_FACTOR"));
bytes32 public constant INCREASE_ORDER_GAS_LIMIT = keccak256(abi.encode("INCREASE_ORDER_GAS_LIMIT"));
bytes32 public constant DECREASE_ORDER_GAS_LIMIT = keccak256(abi.encode("DECREASE_ORDER_GAS_LIMIT"));
bytes32 public constant SWAP_ORDER_GAS_LIMIT = keccak256(abi.encode("SWAP_ORDER_GAS_LIMIT"));
bytes32 public constant SINGLE_SWAP_GAS_LIMIT = keccak256(abi.encode("SINGLE_SWAP_GAS_LIMIT"));
bytes32 public constant POSITION_FEE_FACTOR = keccak256(abi.encode("POSITION_FEE_FACTOR"));
bytes32 public constant EXECUTE_ORDER_FEATURE_DISABLED = keccak256(abi.encode("EXECUTE_ORDER_FEATURE_DISABLED"));
bytes32 public constant IS_LONG = keccak256(abi.encode("IS_LONG"));
bytes32 public constant referralCode = bytes32(0);
uint256 public constant PRECISION = 1e30;
uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
address public orderHandler;
address public liquidationHandler;
address public adlHandler;
IExchangeRouter public gExchangeRouter;
address public gmxRouter;
IDataStore public dataStore;
address public orderVault;
IGmxReader public gmxReader;
address public referralStorage;
address public perpVault;
OrderQueue public queue;
uint256 public minEth;

// Function Implementation:
function refundExecutionFee(address receipient, uint256 amount) external {
    require(msg.sender == perpVault, "invalid caller");
    payable(receipient).transfer(amount);
  }

// Contract State Variables:
using SafeERC20 for IERC20;
bool isCollateralToIndex;
uint256 swapped;
uint256 remaining;
NextActionSelector selector;
bytes data;
uint256 amount;
uint256 shares;
address owner;
uint256 executionFee;
uint256 timestamp;
address recipient;
uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
uint256 constant ONE_USD = 1e30;
uint256 public totalShares;
uint256 counter;
mapping (uint256 => DepositInfo) public depositInfo;
mapping (address => EnumerableSet.UintSet) userDeposits;
address public market;
address public indexToken;
IERC20 public collateralToken;
IGmxProxy public gmxProxy;
IVaultReader public vaultReader;
address public keeper;
address public treasury;
bytes32 public curPositionKey;
uint256 public maxDepositAmount;
uint256 public minDepositAmount;
uint256 public totalDepositAmount;
uint256 public governanceFee;
uint256 public callbackGasLimit;

// Function Implementation:
function _burn(uint256 depositId) internal {
    EnumerableSet.remove(userDeposits[depositInfo[depositId].owner], depositId);
    totalShares = totalShares - depositInfo[depositId].shares;
    delete depositInfo[depositId];
  }

// Contract State Variables:
using SafeCast for uint256;
bytes32 public constant SIZE_IN_USD = keccak256(abi.encode("SIZE_IN_USD"));
bytes32 public constant SIZE_IN_TOKENS = keccak256(abi.encode("SIZE_IN_TOKENS"));
bytes32 public constant POSITION_FEE_FACTOR = keccak256(abi.encode("POSITION_FEE_FACTOR"));
uint256 public constant PRECISION = 1e30;
address public orderHandler;
IDataStore public dataStore;
address public orderVault;
IGmxReader public gmxReader;
address public referralStorage;

// Function Implementation:
function getPositionFeeUsd(address market, uint256 sizeDeltaUsd, bool forPositiveImpact) external view returns (uint256 positionFeeAmount) {
    uint256 positionFeeFactor = dataStore.getUint(keccak256(abi.encode(
      POSITION_FEE_FACTOR,
      market,
      forPositiveImpact
    )));
    positionFeeAmount = sizeDeltaUsd * positionFeeFactor / PRECISION;
  }

// Contract State Variables:
using SafeERC20 for IERC20;
bool isCollateralToIndex;
uint256 swapped;
uint256 remaining;
NextActionSelector selector;
bytes data;
uint256 amount;
uint256 shares;
address owner;
uint256 executionFee;
uint256 timestamp;
address recipient;
uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
uint256 constant ONE_USD = 1e30;
uint256 public totalShares;
uint256 counter;
mapping (uint256 => DepositInfo) public depositInfo;
mapping (address => EnumerableSet.UintSet) userDeposits;
address public market;
address public indexToken;
IERC20 public collateralToken;
IGmxProxy public gmxProxy;
IVaultReader public vaultReader;
address public keeper;
address public treasury;
bytes32 public curPositionKey;
uint256 public maxDepositAmount;
uint256 public minDepositAmount;
uint256 public totalDepositAmount;
uint256 public governanceFee;
uint256 public callbackGasLimit;

// Function Implementation:
function _mint(uint256 depositId, uint256 amount, bool refundFee, MarketPrices memory prices) internal {
    uint256 _shares;
    if (totalShares == 0) {
      _shares = depositInfo[depositId].amount * 1e8;
    } else {
      uint256 totalAmountBefore;
      if (positionIsClosed == false && _isLongOneLeverage(beenLong)) {
        totalAmountBefore = IERC20(indexToken).balanceOf(address(this)) - amount;
      } else {
        totalAmountBefore = _totalAmount(prices) - amount;
      }
      if (totalAmountBefore == 0) totalAmountBefore = 1;
      _shares = amount * totalShares / totalAmountBefore;
    }

    depositInfo[depositId].shares = _shares;
    totalShares = totalShares + _shares;

    if (refundFee) {
      uint256 usedFee = callbackGasLimit * tx.gasprice;
      if (depositInfo[counter].executionFee > usedFee) {
        try IGmxProxy(gmxProxy).refundExecutionFee(depositInfo[counter].owner, depositInfo[counter].executionFee - usedFee) {} catch {}
      }
    }

    emit Minted(depositId, depositInfo[depositId].owner, _shares, amount);
  }

// Contract State Variables:
using SafeERC20 for IERC20;
bool isCollateralToIndex;
uint256 swapped;
uint256 remaining;
NextActionSelector selector;
bytes data;
uint256 amount;
uint256 shares;
address owner;
uint256 executionFee;
uint256 timestamp;
address recipient;
uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
uint256 constant ONE_USD = 1e30;
uint256 public totalShares;
uint256 counter;
mapping (uint256 => DepositInfo) public depositInfo;
mapping (address => EnumerableSet.UintSet) userDeposits;
address public market;
address public indexToken;
IERC20 public collateralToken;
IGmxProxy public gmxProxy;
IVaultReader public vaultReader;
address public keeper;
address public treasury;
bytes32 public curPositionKey;
uint256 public maxDepositAmount;
uint256 public minDepositAmount;
uint256 public totalDepositAmount;
uint256 public governanceFee;
uint256 public callbackGasLimit;

// Function Implementation:
function _totalAmount(MarketPrices memory prices) internal view returns (uint256) {
    if (positionIsClosed) {
      return collateralToken.balanceOf(address(this));
    } else {
      IVaultReader.PositionData memory positionData = vaultReader.getPositionInfo(curPositionKey, prices);
      uint256 total = IERC20(indexToken).balanceOf(address(this)) * prices.indexTokenPrice.min / prices.shortTokenPrice.min
          + collateralToken.balanceOf(address(this))
          + positionData.netValue / prices.shortTokenPrice.min;

      return total;
    }
  }

// Contract State Variables:
using SafeCast for uint256;
bytes32 public constant SIZE_IN_USD = keccak256(abi.encode("SIZE_IN_USD"));
bytes32 public constant SIZE_IN_TOKENS = keccak256(abi.encode("SIZE_IN_TOKENS"));
bytes32 public constant POSITION_FEE_FACTOR = keccak256(abi.encode("POSITION_FEE_FACTOR"));
uint256 public constant PRECISION = 1e30;
address public orderHandler;
IDataStore public dataStore;
address public orderVault;
IGmxReader public gmxReader;
address public referralStorage;

// Function Implementation:
function getMarket(address market) public view returns (MarketProps memory) {
    return gmxReader.getMarket(address(dataStore), market);
  }

// Contract State Variables:
using SignedSafeMath for int256;
using SafeCast for int256;
using SafeCast for uint256;
uint256 public constant FLOAT_PRECISION = 10 ** 30;
bytes32 public constant OPEN_INTEREST = keccak256(abi.encode("OPEN_INTEREST"));
bytes32 public constant MIN_COLLATERAL_FACTOR_FOR_OPEN_INTEREST_MULTIPLIER = keccak256(abi.encode("MIN_COLLATERAL_FACTOR_FOR_OPEN_INTEREST_MULTIPLIER"));
bytes32 public constant MIN_COLLATERAL_FACTOR = keccak256(abi.encode("MIN_COLLATERAL_FACTOR"));
uint256 positionSizeInUsd;
uint256 positionCollateralAmount;
int256 realizedPnlUsd;
int256 openInterestDelta;

// Function Implementation:
function willPositionCollateralBeSufficient(
        IDataStore dataStore,
        MarketProps memory market,
        MarketPrices memory prices,
        bool isLong,
        WillPositionCollateralBeSufficientValues memory values
    ) external view returns (bool, int256) {
        PriceProps memory collateralTokenPrice = prices.shortTokenPrice;

        int256 remainingCollateralUsd = values.positionCollateralAmount.toInt256() * collateralTokenPrice.min.toInt256();

        // deduct realized pnl if it is negative since this would be paid from
        // the position's collateral
        if (values.realizedPnlUsd < 0) {
            remainingCollateralUsd = remainingCollateralUsd + values.realizedPnlUsd;
        }

        if (remainingCollateralUsd < 0) {
            return (false, remainingCollateralUsd);
        }

        // the min collateral factor will increase as the open interest for a market increases
        // this may lead to previously created limit increase orders not being executable
        //
        // the position's pnl is not factored into the remainingCollateralUsd value, since
        // factoring in a positive pnl may allow the user to manipulate price and bypass this check
        // it may be useful to factor in a negative pnl for this check, this can be added if required
        uint256 minCollateralFactor = MarketUtils.getMinCollateralFactorForOpenInterest(
            dataStore,
            market,
            values.openInterestDelta,
            isLong
        );

        uint256 minCollateralFactorForMarket = MarketUtils.getMinCollateralFactor(dataStore, market.marketToken);
        // use the minCollateralFactor for the market if it is larger
        if (minCollateralFactorForMarket > minCollateralFactor) {
            minCollateralFactor = minCollateralFactorForMarket;
        }

        int256 minCollateralUsdForLeverage = applyFactor(values.positionSizeInUsd, minCollateralFactor).toInt256();
        bool willBeSufficient = remainingCollateralUsd >= minCollateralUsdForLeverage;

        return (willBeSufficient, remainingCollateralUsd);
    }

// Contract State Variables:
using SignedSafeMath for int256;
using SafeCast for int256;
using SafeCast for uint256;
uint256 public constant FLOAT_PRECISION = 10 ** 30;
bytes32 public constant OPEN_INTEREST = keccak256(abi.encode("OPEN_INTEREST"));
bytes32 public constant MIN_COLLATERAL_FACTOR_FOR_OPEN_INTEREST_MULTIPLIER = keccak256(abi.encode("MIN_COLLATERAL_FACTOR_FOR_OPEN_INTEREST_MULTIPLIER"));
bytes32 public constant MIN_COLLATERAL_FACTOR = keccak256(abi.encode("MIN_COLLATERAL_FACTOR"));
uint256 positionSizeInUsd;
uint256 positionCollateralAmount;
int256 realizedPnlUsd;
int256 openInterestDelta;

// Function Implementation:
function getMinCollateralFactorForOpenInterest(
        IDataStore dataStore,
        MarketProps memory market,
        int256 openInterestDelta,
        bool isLong
    ) internal view returns (uint256) {
        uint256 openInterest = getOpenInterest(dataStore, market, isLong);
        openInterest = sumReturnUint256(openInterest, openInterestDelta);
        uint256 multiplierFactor = getMinCollateralFactorForOpenInterestMultiplier(dataStore, market.marketToken, isLong);
        return applyFactor(openInterest, multiplierFactor);
    }

// Contract State Variables:
using SignedSafeMath for int256;
using SafeCast for int256;
using SafeCast for uint256;
uint256 public constant FLOAT_PRECISION = 10 ** 30;
bytes32 public constant OPEN_INTEREST = keccak256(abi.encode("OPEN_INTEREST"));
bytes32 public constant MIN_COLLATERAL_FACTOR_FOR_OPEN_INTEREST_MULTIPLIER = keccak256(abi.encode("MIN_COLLATERAL_FACTOR_FOR_OPEN_INTEREST_MULTIPLIER"));
bytes32 public constant MIN_COLLATERAL_FACTOR = keccak256(abi.encode("MIN_COLLATERAL_FACTOR"));
uint256 positionSizeInUsd;
uint256 positionCollateralAmount;
int256 realizedPnlUsd;
int256 openInterestDelta;

// Function Implementation:
function getMinCollateralFactor(IDataStore dataStore, address market) internal view returns (uint256) {
        return dataStore.getUint(minCollateralFactorKey(market));
    }

// Contract State Variables:
using SignedSafeMath for int256;
using SafeCast for int256;
using SafeCast for uint256;
uint256 public constant FLOAT_PRECISION = 10 ** 30;
bytes32 public constant OPEN_INTEREST = keccak256(abi.encode("OPEN_INTEREST"));
bytes32 public constant MIN_COLLATERAL_FACTOR_FOR_OPEN_INTEREST_MULTIPLIER = keccak256(abi.encode("MIN_COLLATERAL_FACTOR_FOR_OPEN_INTEREST_MULTIPLIER"));
bytes32 public constant MIN_COLLATERAL_FACTOR = keccak256(abi.encode("MIN_COLLATERAL_FACTOR"));
uint256 positionSizeInUsd;
uint256 positionCollateralAmount;
int256 realizedPnlUsd;
int256 openInterestDelta;

// Function Implementation:
function applyFactor(uint256 value, uint256 factor) internal pure returns (uint256) {
        return Math.mulDiv(value, factor, FLOAT_PRECISION);
    }
After analyzing the code, I've identified a critical vulnerability related to the ERC20 approval mechanism:

Vulnerability: Missing approval reset before setting new approval amount

The vulnerability exists in the `swap` function where `safeApprove` is called without first resetting the previous approval to zero. Some ERC20 tokens (like USDT) require the current allowance to be zero before setting a new non-zero allowance for security reasons.

Detailed Exploit Steps:

1. First call to the swap function succeeds:
```solidity
// First swap with amount 100
IERC20(fromToken).safeApprove(approvalAddress, 100);
```

2. Second call with a different amount will revert:
```solidity
// Second swap with amount 200 will revert for tokens like USDT
IERC20(fromToken).safeApprove(approvalAddress, 200);
```

The fix is to reset the approval to zero before setting the new amount:
```solidity
function swap(address to, bytes memory callData) external {
    _validateCallData(to, callData);
    address approvalAddress = IAugustusSwapper(to).getTokenTransferProxy();
    address fromToken;
    uint256 fromAmount;
    assembly {
        fromToken := mload(add(callData, 68))
        fromAmount := mload(add(callData, 100))
    }
    
    // Fix: Reset approval to zero first
    IERC20(fromToken).safeApprove(approvalAddress, 0);
    IERC20(fromToken).safeApprove(approvalAddress, fromAmount);
    
    (bool success, ) = to.call(callData);
    require(success, "paraswap call reverted");
}
```

Impact:
- The contract becomes unusable after the first swap when using certain ERC20 tokens
- Subsequent transactions will revert
- Users cannot perform multiple swaps with different amounts
- This is a practical issue that affects real-world tokens like USDT

This vulnerability is particularly dangerous because it can completely block the functionality of the contract for certain tokens, making it unusable after the first swap operation.

        First analyze this vulnerability step by step, and then determine if it really exists based on the analysis result or need deeper function code.
        Please note the following points:
        0.If the vulnerability description indicates that no vulnerability is found, directly conclude that it [[does not exist]]
        1. If the vulnerability is an integer overflow vulnerability, directly conclude that the vulnerability [does not exist]
        2. If the vulnerability is a reentrancy vulnerability, directly conclude that the vulnerability [does not exist]
        3. If the vulnerability requires inserting new address transaction operations from external sources during function execution, directly determine it [does not exist], because transactions are atomic
        4. When assessing vulnerabilities in functions with permission controls, consider not only the functionality itself but also how easily these permission roles can be obtained, as functions with "permission protection" may still be vulnerable if the permissions are easily accessible
        5. If more information is needed to confirm the vulnerability, please clearly state what content needs to be understood (e.g., specific function implementations, variable usage patterns, permission check logic, etc.)
        6. If the vulnerable function has an onlyowner modifier, directly conclude that the vulnerability [does not exist]
        7. Any vulnerability or risk that could cause potential losses is valid(event small losses), it doesn't necessarily need to cause major security issues
        Please format your output as follows:
        1. Detailed analysis process
        2. Whether more information is needed (if yes, please specify what content needs to be understood and why)
        3. Preliminary conclusion based on current information
        
