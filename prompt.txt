function connectVaultsAndMarkets(uint256[] calldata marketIds, uint256[] calldata vaultIds) external onlyOwner {
        // revert if no marketIds are provided
        if (marketIds.length == 0) {
            revert Errors.ZeroInput("connectedMarketIds");
        }

        // revert if no vaultIds are provided
        if (vaultIds.length == 0) {
            revert Errors.ZeroInput("connectedVaultIds");
        }

        // define array that will contain a single vault id to recalculate credit for
        uint256[] memory vaultIdToRecalculate = new uint256[](1);

        // iterate over vault ids
        for (uint128 i; i < vaultIds.length; i++) {
            // if vault has connected markets
            if (Vault.load(vaultIds[i].toUint128()).connectedMarkets.length > 0) {
                // cache vault id
                vaultIdToRecalculate[0] = vaultIds[i];

                // recalculate the credit capacity of the vault
                Vault.recalculateVaultsCreditCapacity(vaultIdToRecalculate);
            }
        }

        for (uint256 i; i < marketIds.length; i++) {
            _configureMarketConnectedVaults(marketIds[i].toUint128(), vaultIds);
        }

        // perform state updates for markets connected to each market id
        for (uint256 i; i < vaultIds.length; i++) {
            _configureVaultConnectedMarkets(vaultIds[i].toUint128(), marketIds);
        }
    }
function updateVaultSwapStrategy(
        uint128 vaultId,
        bytes memory assetDexSwapPath,
        bytes memory usdcDexSwapPath,
        uint128 assetDexSwapStrategyId,
        uint128 usdcDexSwapStrategyId
    )
        external
        onlyOwner
    {
        Vault.updateVaultSwapStrategy(
            vaultId, assetDexSwapPath, usdcDexSwapPath, assetDexSwapStrategyId, usdcDexSwapStrategyId
        );
    }
function updateVaultConfiguration(Vault.UpdateParams calldata params) external onlyOwner {
        if (params.depositCap == 0) {
            revert Errors.ZeroInput("depositCap");
        }

        if (params.withdrawalDelay == 0) {
            revert Errors.ZeroInput("withdrawDelay");
        }

        if (params.vaultId == 0) {
            revert Errors.ZeroInput("vaultId");
        }

        Vault.update(params);

        emit LogUpdateVaultConfiguration(msg.sender, params.vaultId);
    }
function configureVaultDepositAndRedeemFeeRecipient(address vaultDepositAndRedeemFeeRecipient)
        external
        onlyOwner
    {
        // revert if the vaultDepositAndRedeemFeeRecipient is zero
        if (vaultDepositAndRedeemFeeRecipient == address(0)) {
            revert Errors.ZeroInput("vaultDepositAndRedeemFeeRecipient");
        }

        // load the market making engine configuration from storage
        MarketMakingEngineConfiguration.Data storage marketMakingEngineConfiguration =
            MarketMakingEngineConfiguration.load();

        // update the vault deposit and redeem fee recipient
        marketMakingEngineConfiguration.vaultDepositAndRedeemFeeRecipient = vaultDepositAndRedeemFeeRecipient;

        // emit the LogConfigureVaultDepositAndRedeemFeeRecipient event
        emit LogConfigureVaultDepositAndRedeemFeeRecipient(vaultDepositAndRedeemFeeRecipient);
    }
function createVault(Vault.CreateParams calldata params) external onlyOwner {
        if (params.indexToken == address(0)) {
            revert Errors.ZeroInput("indexToken");
        }

        if (params.depositCap == 0) {
            revert Errors.ZeroInput("depositCap");
        }

        if (params.withdrawalDelay == 0) {
            revert Errors.ZeroInput("withdrawDelay");
        }

        if (params.vaultId == 0) {
            revert Errors.ZeroInput("vaultId");
        }

        if (params.engine == address(0)) {
            revert Errors.ZeroInput("engine");
        }

        Vault.create(params);

        emit LogCreateVault(msg.sender, params.vaultId);
    }
// Contract State Variables:
using DexSwapStrategy for DexSwapStrategy.Data;
using EnumerableSet for EnumerableSet.UintSet;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;
using SafeCast for uint256;
using DexSwapStrategy for DexSwapStrategy.Data;
using LiveMarkets for LiveMarkets.Data;
using AssetSwapPath for AssetSwapPath.Data;

// Function Implementation:
function connectVaultsAndMarkets(uint256[] calldata marketIds, uint256[] calldata vaultIds) external onlyOwner {
        // revert if no marketIds are provided
        if (marketIds.length == 0) {
            revert Errors.ZeroInput("connectedMarketIds");
        }

        // revert if no vaultIds are provided
        if (vaultIds.length == 0) {
            revert Errors.ZeroInput("connectedVaultIds");
        }

        // define array that will contain a single vault id to recalculate credit for
        uint256[] memory vaultIdToRecalculate = new uint256[](1);

        // iterate over vault ids
        for (uint128 i; i < vaultIds.length; i++) {
            // if vault has connected markets
            if (Vault.load(vaultIds[i].toUint128()).connectedMarkets.length > 0) {
                // cache vault id
                vaultIdToRecalculate[0] = vaultIds[i];

                // recalculate the credit capacity of the vault
                Vault.recalculateVaultsCreditCapacity(vaultIdToRecalculate);
            }
        }

        for (uint256 i; i < marketIds.length; i++) {
            _configureMarketConnectedVaults(marketIds[i].toUint128(), vaultIds);
        }

        // perform state updates for markets connected to each market id
        for (uint256 i; i < vaultIds.length; i++) {
            _configureVaultConnectedMarkets(vaultIds[i].toUint128(), marketIds);
        }
    }

// Contract State Variables:
using DexSwapStrategy for DexSwapStrategy.Data;
using EnumerableSet for EnumerableSet.UintSet;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;
using SafeCast for uint256;
using DexSwapStrategy for DexSwapStrategy.Data;
using LiveMarkets for LiveMarkets.Data;
using AssetSwapPath for AssetSwapPath.Data;

// Function Implementation:
function _configureMarketConnectedVaults(uint128 marketId, uint256[] calldata vaultIds) internal {
        // revert if vaultId is set to zero
        if (marketId == 0) {
            revert Errors.ZeroInput("marketId");
        }

        // load vault data from storage
        Market.Data storage market = Market.load(marketId);

        // if market has connected vaults
        if (market.connectedVaults.length > 0) {
            // Make sure that vaults connected to markets that are updated but not passed as an argument
            uint256[] memory vaultIdToRecalculate = market.connectedVaults[market.connectedVaults.length - 1].values();

            // recalculate the credit capacity for current market vaults
            Vault.recalculateVaultsCreditCapacity(vaultIdToRecalculate);
        }

        // push new array of connected markets
        market.connectedVaults.push();

        // add markets ids to connected markets
        for (uint256 i; i < vaultIds.length; i++) {
            // use [vault.connectedVaults.length - 1] to get the last connected markets array
            market.connectedVaults[market.connectedVaults.length - 1].add(vaultIds[i]);
        }

        // emit event LogConfigureMarketConnectedVaults
        emit LogConfigureMarketConnectedVaults(marketId, vaultIds);
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using CreditDelegation for CreditDelegation.Data;
using Distribution for Distribution.Data;
using EnumerableSet for EnumerableSet.UintSet;
using Market for Market.Data;
using SafeCast for uint256;
using SafeCast for int256;
uint128 usdcDexSwapStrategyId;
bytes usdcDexSwapPath;
uint128 assetDexSwapStrategyId;
bytes assetDexSwapPath;
uint256 depositFee;
uint256 redeemFee;
uint128 id;
uint128 totalCreditDelegationWeight;
uint128 depositCap;
uint128 withdrawalDelay;
uint128 lockedCreditRatio;
int128 marketsUnrealizedDebtUsd;
int128 marketsRealizedDebtUsd;
uint128 depositedUsdc;
address indexToken;
address engine;
bool isLive;
SwapStrategy swapStrategy;
mapping(address => uint128) withdrawalRequestIdCounter;
uint256 depositFee;
uint256 redeemFee;
uint128 vaultId;
uint128 depositCap;
uint128 withdrawalDelay;
address indexToken;
address engine;
uint128 vaultId;
uint128 depositCap;
uint128 withdrawalDelay;
bool isLive;
uint128 lockedCreditRatio;

// Function Implementation:
function load(uint128 marketId) internal pure returns (Data storage market) {
        bytes32 slot = keccak256(abi.encode(MARKET_LOCATION, marketId));
        assembly {
            market.slot := slot
        }
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using CreditDelegation for CreditDelegation.Data;
using Distribution for Distribution.Data;
using EnumerableSet for EnumerableSet.UintSet;
using Market for Market.Data;
using SafeCast for uint256;
using SafeCast for int256;
uint128 usdcDexSwapStrategyId;
bytes usdcDexSwapPath;
uint128 assetDexSwapStrategyId;
bytes assetDexSwapPath;
uint256 depositFee;
uint256 redeemFee;
uint128 id;
uint128 totalCreditDelegationWeight;
uint128 depositCap;
uint128 withdrawalDelay;
uint128 lockedCreditRatio;
int128 marketsUnrealizedDebtUsd;
int128 marketsRealizedDebtUsd;
uint128 depositedUsdc;
address indexToken;
address engine;
bool isLive;
SwapStrategy swapStrategy;
mapping(address => uint128) withdrawalRequestIdCounter;
uint256 depositFee;
uint256 redeemFee;
uint128 vaultId;
uint128 depositCap;
uint128 withdrawalDelay;
address indexToken;
address engine;
uint128 vaultId;
uint128 depositCap;
uint128 withdrawalDelay;
bool isLive;
uint128 lockedCreditRatio;

// Function Implementation:
function recalculateVaultsCreditCapacity(uint256[] memory vaultsIds) internal {
        for (uint256 i; i < vaultsIds.length; i++) {
            // uint256 -> uint128
            uint128 vaultId = vaultsIds[i].toUint128();

            // load the vault storage pointer
            Data storage self = load(vaultId);

            // make sure there are markets connected to the vault
            uint256 connectedMarketsConfigLength = self.connectedMarkets.length;
            if (connectedMarketsConfigLength == 0) continue;

            // loads the connected markets storage pointer by taking the last configured market ids uint set
            EnumerableSet.UintSet storage connectedMarkets = self.connectedMarkets[connectedMarketsConfigLength - 1];

            // cache the connected markets ids to avoid multiple storage reads, as we're going to loop over them twice
            // at `_recalculateConnectedMarketsState` and `_updateCreditDelegations`
            uint128[] memory connectedMarketsIdsCache = new uint128[](connectedMarkets.length());

            // update vault and credit delegation weight
            updateVaultAndCreditDelegationWeight(self, connectedMarketsIdsCache);

            // iterate over each connected market id and distribute its debt so we can have the latest credit
            // delegation of the vault id being iterated to the provided `marketId`
            (
                uint128[] memory updatedConnectedMarketsIdsCache,
                SD59x18 vaultTotalRealizedDebtChangeUsdX18,
                SD59x18 vaultTotalUnrealizedDebtChangeUsdX18,
                UD60x18 vaultTotalUsdcCreditChangeX18,
                UD60x18 vaultTotalWethRewardChangeX18
            ) = _recalculateConnectedMarketsState(self, connectedMarketsIdsCache, true);

            // gas optimization: only write to storage if values have changed
            //
            // updates the vault's stored unsettled realized debt distributed from markets
            if (!vaultTotalRealizedDebtChangeUsdX18.isZero()) {
                self.marketsRealizedDebtUsd = sd59x18(self.marketsRealizedDebtUsd).add(
                    vaultTotalRealizedDebtChangeUsdX18
                ).intoInt256().toInt128();
            }

            // updates the vault's stored unrealized debt distributed from markets
            if (!vaultTotalUnrealizedDebtChangeUsdX18.isZero()) {
                self.marketsUnrealizedDebtUsd = sd59x18(self.marketsUnrealizedDebtUsd).add(
                    vaultTotalUnrealizedDebtChangeUsdX18
                ).intoInt256().toInt128();
            }

            // adds the vault's total USDC credit change, earned from its connected markets, to the
            // `depositedUsdc` variable
            if (!vaultTotalUsdcCreditChangeX18.isZero()) {
                self.depositedUsdc = ud60x18(self.depositedUsdc).add(vaultTotalUsdcCreditChangeX18).intoUint128();
            }

            // distributes the vault's total WETH reward change, earned from its connected markets
            if (!vaultTotalWethRewardChangeX18.isZero() && self.wethRewardDistribution.totalShares != 0) {
                SD59x18 vaultTotalWethRewardChangeSD59X18 =
                    sd59x18(int256(vaultTotalWethRewardChangeX18.intoUint256()));
                self.wethRewardDistribution.distributeValue(vaultTotalWethRewardChangeSD59X18);
            }

            // update the vault's credit delegations
            (, SD59x18 vaultNewCreditCapacityUsdX18) =
                _updateCreditDelegations(self, updatedConnectedMarketsIdsCache, false);

            emit LogUpdateVaultCreditCapacity(
                vaultId,
                vaultTotalRealizedDebtChangeUsdX18.intoInt256(),
                vaultTotalUnrealizedDebtChangeUsdX18.intoInt256(),
                vaultTotalUsdcCreditChangeX18.intoUint256(),
                vaultTotalWethRewardChangeX18.intoUint256(),
                vaultNewCreditCapacityUsdX18.intoInt256()
            );
        }
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using CreditDelegation for CreditDelegation.Data;
using Distribution for Distribution.Data;
using EnumerableSet for EnumerableSet.UintSet;
using Market for Market.Data;
using SafeCast for uint256;
using SafeCast for int256;
uint128 usdcDexSwapStrategyId;
bytes usdcDexSwapPath;
uint128 assetDexSwapStrategyId;
bytes assetDexSwapPath;
uint256 depositFee;
uint256 redeemFee;
uint128 id;
uint128 totalCreditDelegationWeight;
uint128 depositCap;
uint128 withdrawalDelay;
uint128 lockedCreditRatio;
int128 marketsUnrealizedDebtUsd;
int128 marketsRealizedDebtUsd;
uint128 depositedUsdc;
address indexToken;
address engine;
bool isLive;
SwapStrategy swapStrategy;
mapping(address => uint128) withdrawalRequestIdCounter;
uint256 depositFee;
uint256 redeemFee;
uint128 vaultId;
uint128 depositCap;
uint128 withdrawalDelay;
address indexToken;
address engine;
uint128 vaultId;
uint128 depositCap;
uint128 withdrawalDelay;
bool isLive;
uint128 lockedCreditRatio;

// Function Implementation:
function updateVaultAndCreditDelegationWeight(
        Data storage self,
        uint128[] memory connectedMarketsIdsCache
    )
        internal
    {
        // cache the connected markets length
        uint256 connectedMarketsConfigLength = self.connectedMarkets.length;

        // loads the connected markets storage pointer by taking the last configured market ids uint set
        EnumerableSet.UintSet storage connectedMarkets = self.connectedMarkets[connectedMarketsConfigLength - 1];

        // get the total of shares
        uint128 newWeight = uint128(IERC4626(self.indexToken).totalAssets());

        for (uint256 i; i < connectedMarketsIdsCache.length; i++) {
            // load the credit delegation to the given market id
            CreditDelegation.Data storage creditDelegation =
                CreditDelegation.load(self.id, connectedMarkets.at(i).toUint128());

            // update the credit delegation weight
            creditDelegation.weight = newWeight;
        }

        // update the vault weight
        self.totalCreditDelegationWeight = newWeight;
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using CreditDelegation for CreditDelegation.Data;
using Distribution for Distribution.Data;
using EnumerableSet for EnumerableSet.UintSet;
using Market for Market.Data;
using SafeCast for uint256;
using SafeCast for int256;
uint128 usdcDexSwapStrategyId;
bytes usdcDexSwapPath;
uint128 assetDexSwapStrategyId;
bytes assetDexSwapPath;
uint256 depositFee;
uint256 redeemFee;
uint128 id;
uint128 totalCreditDelegationWeight;
uint128 depositCap;
uint128 withdrawalDelay;
uint128 lockedCreditRatio;
int128 marketsUnrealizedDebtUsd;
int128 marketsRealizedDebtUsd;
uint128 depositedUsdc;
address indexToken;
address engine;
bool isLive;
SwapStrategy swapStrategy;
mapping(address => uint128) withdrawalRequestIdCounter;
uint256 depositFee;
uint256 redeemFee;
uint128 vaultId;
uint128 depositCap;
uint128 withdrawalDelay;
address indexToken;
address engine;
uint128 vaultId;
uint128 depositCap;
uint128 withdrawalDelay;
bool isLive;
uint128 lockedCreditRatio;

// Function Implementation:
function update(UpdateParams memory params) internal {
        Data storage self = load(params.vaultId);

        if (self.id == 0) {
            revert Errors.ZeroInput("vaultId");
        }

        self.depositCap = params.depositCap;
        self.withdrawalDelay = params.withdrawalDelay;
        self.isLive = params.isLive;
        self.lockedCreditRatio = params.lockedCreditRatio;
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using CreditDelegation for CreditDelegation.Data;
using Distribution for Distribution.Data;
using EnumerableSet for EnumerableSet.UintSet;
using Market for Market.Data;
using SafeCast for uint256;
using SafeCast for int256;
uint128 usdcDexSwapStrategyId;
bytes usdcDexSwapPath;
uint128 assetDexSwapStrategyId;
bytes assetDexSwapPath;
uint256 depositFee;
uint256 redeemFee;
uint128 id;
uint128 totalCreditDelegationWeight;
uint128 depositCap;
uint128 withdrawalDelay;
uint128 lockedCreditRatio;
int128 marketsUnrealizedDebtUsd;
int128 marketsRealizedDebtUsd;
uint128 depositedUsdc;
address indexToken;
address engine;
bool isLive;
SwapStrategy swapStrategy;
mapping(address => uint128) withdrawalRequestIdCounter;
uint256 depositFee;
uint256 redeemFee;
uint128 vaultId;
uint128 depositCap;
uint128 withdrawalDelay;
address indexToken;
address engine;
uint128 vaultId;
uint128 depositCap;
uint128 withdrawalDelay;
bool isLive;
uint128 lockedCreditRatio;

// Function Implementation:
function _recalculateConnectedMarketsState(
        Data storage self,
        uint128[] memory connectedMarketsIdsCache,
        bool shouldRehydrateCache
    )
        private
        returns (
            uint128[] memory rehydratedConnectedMarketsIdsCache,
            SD59x18 vaultTotalRealizedDebtChangeUsdX18,
            SD59x18 vaultTotalUnrealizedDebtChangeUsdX18,
            UD60x18 vaultTotalUsdcCreditChangeX18,
            UD60x18 vaultTotalWethRewardChangeX18
        )
    {
        RecalculateConnectedMarketsState_Context memory ctx;
        rehydratedConnectedMarketsIdsCache = new uint128[](connectedMarketsIdsCache.length);

        // cache the vault id
        ctx.vaultId = self.id;

        // cache the connected markets length
        uint256 connectedMarketsConfigLength = self.connectedMarkets.length;

        // loads the connected markets storage pointer by taking the last configured market ids uint set
        EnumerableSet.UintSet storage connectedMarkets = self.connectedMarkets[connectedMarketsConfigLength - 1];

        for (uint256 i; i < connectedMarketsIdsCache.length; i++) {
            if (shouldRehydrateCache) {
                rehydratedConnectedMarketsIdsCache[i] = connectedMarkets.at(i).toUint128();
            } else {
                rehydratedConnectedMarketsIdsCache[i] = connectedMarketsIdsCache[i];
            }

            // loads the market storage pointer
            Market.Data storage market = Market.load(rehydratedConnectedMarketsIdsCache[i]);

            // first we cache the market's unrealized and realized debt
            ctx.marketUnrealizedDebtUsdX18 = market.getUnrealizedDebtUsd();
            ctx.marketRealizedDebtUsdX18 = market.getRealizedDebtUsd();

            // if market has debt distribute it
            if (!ctx.marketUnrealizedDebtUsdX18.isZero() || !ctx.marketRealizedDebtUsdX18.isZero()) {
                // distribute the market's debt to its connected vaults
                market.distributeDebtToVaults(ctx.marketUnrealizedDebtUsdX18, ctx.marketRealizedDebtUsdX18);
            }

            // load the credit delegation to the given market id
            CreditDelegation.Data storage creditDelegation =
                CreditDelegation.load(ctx.vaultId, rehydratedConnectedMarketsIdsCache[i]);

            // prevent division by zero
            if (!market.getTotalDelegatedCreditUsd().isZero()) {
                // get the vault's accumulated debt, credit and reward changes from the market to update its stored
                // values
                (
                    ctx.realizedDebtChangeUsdX18,
                    ctx.unrealizedDebtChangeUsdX18,
                    ctx.usdcCreditChangeX18,
                    ctx.wethRewardChangeX18
                ) = market.getVaultAccumulatedValues(
                    ud60x18(creditDelegation.valueUsd),
                    sd59x18(creditDelegation.lastVaultDistributedRealizedDebtUsdPerShare),
                    sd59x18(creditDelegation.lastVaultDistributedUnrealizedDebtUsdPerShare),
                    ud60x18(creditDelegation.lastVaultDistributedUsdcCreditPerShare),
                    ud60x18(creditDelegation.lastVaultDistributedWethRewardPerShare)
                );
            }

            // if there's been no change in any of the returned values, we can iterate to the next
            // market id
            if (
                ctx.realizedDebtChangeUsdX18.isZero() && ctx.unrealizedDebtChangeUsdX18.isZero()
                    && ctx.usdcCreditChangeX18.isZero() && ctx.wethRewardChangeX18.isZero()
            ) {
                continue;
            }

            // update the vault's state by adding its share of the market's latest state variables
            vaultTotalRealizedDebtChangeUsdX18 = vaultTotalRealizedDebtChangeUsdX18.add(ctx.realizedDebtChangeUsdX18);
            vaultTotalUnrealizedDebtChangeUsdX18 =
                vaultTotalUnrealizedDebtChangeUsdX18.add(ctx.unrealizedDebtChangeUsdX18);
            vaultTotalUsdcCreditChangeX18 = vaultTotalUsdcCreditChangeX18.add(ctx.usdcCreditChangeX18);
            vaultTotalWethRewardChangeX18 = vaultTotalWethRewardChangeX18.add(ctx.wethRewardChangeX18);

            // update the last distributed debt, credit and reward values to the vault's credit delegation to the
            // given market id, in order to keep next calculations consistent
            creditDelegation.updateVaultLastDistributedValues(
                sd59x18(market.realizedDebtUsdPerVaultShare),
                sd59x18(market.unrealizedDebtUsdPerVaultShare),
                ud60x18(market.usdcCreditPerVaultShare),
                ud60x18(market.wethRewardPerVaultShare)
            );
        }
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using Distribution for Distribution.Data;
using LiveMarkets for LiveMarkets.Data;
using EnumerableSet for EnumerableSet.AddressSet;
using EnumerableSet for EnumerableSet.UintSet;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using SafeCast for int256;
using SafeCast for uint256;
uint128 id;
uint128 autoDeleverageStartThreshold;
uint128 autoDeleverageEndThreshold;
uint128 autoDeleverageExponentZ;
int128 netUsdTokenIssuance;
uint128 creditDepositsValueCacheUsd;
uint128 lastCreditDepositsValueRehydration;
int128 realizedDebtUsdPerVaultShare;
int128 unrealizedDebtUsdPerVaultShare;
uint128 usdcCreditPerVaultShare;
uint128 wethRewardPerVaultShare;
uint128 availableProtocolWethReward;
uint128 totalDelegatedCreditUsd;
address engine;

// Function Implementation:
function getUnrealizedDebtUsd(Data storage self) internal view returns (SD59x18 unrealizedDebtUsdX18) {
        unrealizedDebtUsdX18 = sd59x18(IEngine(self.engine).getUnrealizedDebt(self.id));
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using Distribution for Distribution.Data;
using LiveMarkets for LiveMarkets.Data;
using EnumerableSet for EnumerableSet.AddressSet;
using EnumerableSet for EnumerableSet.UintSet;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using SafeCast for int256;
using SafeCast for uint256;
uint128 id;
uint128 autoDeleverageStartThreshold;
uint128 autoDeleverageEndThreshold;
uint128 autoDeleverageExponentZ;
int128 netUsdTokenIssuance;
uint128 creditDepositsValueCacheUsd;
uint128 lastCreditDepositsValueRehydration;
int128 realizedDebtUsdPerVaultShare;
int128 unrealizedDebtUsdPerVaultShare;
uint128 usdcCreditPerVaultShare;
uint128 wethRewardPerVaultShare;
uint128 availableProtocolWethReward;
uint128 totalDelegatedCreditUsd;
address engine;

// Function Implementation:
function getTotalDelegatedCreditUsd(Data storage self)
        internal
        view
        returns (UD60x18 totalDelegatedCreditUsdX18)
    {
        totalDelegatedCreditUsdX18 = ud60x18(self.totalDelegatedCreditUsd);
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using Distribution for Distribution.Data;
using LiveMarkets for LiveMarkets.Data;
using EnumerableSet for EnumerableSet.AddressSet;
using EnumerableSet for EnumerableSet.UintSet;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using SafeCast for int256;
using SafeCast for uint256;
uint128 id;
uint128 autoDeleverageStartThreshold;
uint128 autoDeleverageEndThreshold;
uint128 autoDeleverageExponentZ;
int128 netUsdTokenIssuance;
uint128 creditDepositsValueCacheUsd;
uint128 lastCreditDepositsValueRehydration;
int128 realizedDebtUsdPerVaultShare;
int128 unrealizedDebtUsdPerVaultShare;
uint128 usdcCreditPerVaultShare;
uint128 wethRewardPerVaultShare;
uint128 availableProtocolWethReward;
uint128 totalDelegatedCreditUsd;
address engine;

// Function Implementation:
function getRealizedDebtUsd(Data storage self) internal view returns (SD59x18 realizedDebtUsdX18) {
        // prepare the credit deposits usd value variable;
        UD60x18 creditDepositsValueUsdX18;

        // if the credit deposits usd value cache is up to date, return the stored value
        if (block.timestamp <= self.lastCreditDepositsValueRehydration) {
            creditDepositsValueUsdX18 = ud60x18(self.creditDepositsValueCacheUsd);
        } else {
            // otherwise, we'll need to loop over credit deposits to calculate it
            creditDepositsValueUsdX18 = getCreditDepositsValueUsd(self);
        }

        // finally after determining the market's latest credit deposits usd value, sum it with the stored net usd
        // token issuance to return the net realized debt usd value
        realizedDebtUsdX18 = creditDepositsValueUsdX18.intoSD59x18().add(sd59x18(self.netUsdTokenIssuance));
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using Distribution for Distribution.Data;
using LiveMarkets for LiveMarkets.Data;
using EnumerableSet for EnumerableSet.AddressSet;
using EnumerableSet for EnumerableSet.UintSet;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using SafeCast for int256;
using SafeCast for uint256;
uint128 id;
uint128 autoDeleverageStartThreshold;
uint128 autoDeleverageEndThreshold;
uint128 autoDeleverageExponentZ;
int128 netUsdTokenIssuance;
uint128 creditDepositsValueCacheUsd;
uint128 lastCreditDepositsValueRehydration;
int128 realizedDebtUsdPerVaultShare;
int128 unrealizedDebtUsdPerVaultShare;
uint128 usdcCreditPerVaultShare;
uint128 wethRewardPerVaultShare;
uint128 availableProtocolWethReward;
uint128 totalDelegatedCreditUsd;
address engine;

// Function Implementation:
function getCreditDepositsValueUsd(Data storage self) internal view returns (UD60x18 creditDepositsValueUsdX18) {
        // load the map of credit deposits and cache length
        EnumerableMap.AddressToUintMap storage creditDeposits = self.creditDeposits;
        uint256 creditDepositsLength = creditDeposits.length();

        for (uint256 i; i < creditDepositsLength; i++) {
            // load each credit deposit data & associated collateral
            (address asset, uint256 value) = creditDeposits.at(i);
            Collateral.Data storage collateral = Collateral.load(asset);

            // update the total credit deposits value
            creditDepositsValueUsdX18 =
                creditDepositsValueUsdX18.add((collateral.getAdjustedPrice().mul(ud60x18(value))));
        }
    }

// Contract State Variables:
using SafeERC20 for IERC20;
using Collateral for Collateral.Data;
using Distribution for Distribution.Data;
using Vault for Vault.Data;
using SafeCast for uint256;
using MathOpenZeppelin for uint256;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;

// Function Implementation:
function deposit(
        uint128 vaultId,
        uint128 assets,
        uint128 minShares,
        bytes memory referralCode,
        bool isCustomReferralCode
    )
        external
    {
        if (assets == 0) revert Errors.ZeroInput("assets");

        // load the mm engine configuration from storage
        MarketMakingEngineConfiguration.Data storage marketMakingEngineConfiguration =
            MarketMakingEngineConfiguration.load();

        // enforce whitelist if enabled
        address whitelistCache = marketMakingEngineConfiguration.whitelist;
        if (whitelistCache != address(0)) {
            if (!Whitelist(whitelistCache).verifyIfUserIsAllowed(msg.sender)) {
                revert Errors.UserIsNotAllowed(msg.sender);
            }
        }

        // fetch storage slot for vault by id, vault must exist with valid collateral
        Vault.Data storage vault = Vault.loadLive(vaultId);
        if (!vault.collateral.isEnabled) revert Errors.VaultDoesNotExist(vaultId);

        // define context struct and get vault collateral asset
        DepositContext memory ctx;
        ctx.vaultAsset = vault.collateral.asset;

        // prepare the `Vault::recalculateVaultsCreditCapacity` call
        uint256[] memory vaultsIds = new uint256[](1);
        vaultsIds[0] = uint256(vaultId);

        // recalculates the vault's credit capacity
        // note: we need to update the vaults credit capacity before depositing new assets in order to calculate the
        // correct conversion rate between assets and shares, and to validate the involved invariants accurately
        Vault.recalculateVaultsCreditCapacity(vaultsIds);

        // load the referral module contract
        ctx.referralModule = IReferral(marketMakingEngineConfiguration.referralModule);

        // register the given referral code
        if (referralCode.length != 0) {
            ctx.referralModule.registerReferral(
                abi.encode(msg.sender), msg.sender, referralCode, isCustomReferralCode
            );
        }

        // cache the vault assets decimals value for gas savings
        ctx.vaultAssetDecimals = vault.collateral.decimals;

        // uint256 -> ud60x18 18 decimals
        ctx.assetsX18 = Math.convertTokenAmountToUd60x18(ctx.vaultAssetDecimals, assets);

        // cache the deposit fee
        ctx.vaultDepositFee = ud60x18(vault.depositFee);

        // if deposit fee is zero, skip needless processing
        if (ctx.vaultDepositFee.isZero()) {
            ctx.assetsMinusFees = assets;
        } else {
            // otherwise calculate the deposit fee
            ctx.assetFeesX18 = ctx.assetsX18.mul(ctx.vaultDepositFee);

            // ud60x18 -> uint256 asset decimals
            ctx.assetFees = Math.convertUd60x18ToTokenAmount(ctx.vaultAssetDecimals, ctx.assetFeesX18);

            // invariant: if vault enforces fees then calculated fee must be non-zero
            if (ctx.assetFees == 0) revert Errors.ZeroFeeNotAllowed();

            // enforce positive amount left over after deducting fees
            ctx.assetsMinusFees = assets - ctx.assetFees;
            if (ctx.assetsMinusFees == 0) revert Errors.DepositTooSmall();
        }

        // transfer tokens being deposited minus fees into this contract
        IERC20(ctx.vaultAsset).safeTransferFrom(msg.sender, address(this), ctx.assetsMinusFees);

        // transfer fees from depositor to fee recipient address
        if (ctx.assetFees > 0) {
            IERC20(ctx.vaultAsset).safeTransferFrom(
                msg.sender, marketMakingEngineConfiguration.vaultDepositAndRedeemFeeRecipient, ctx.assetFees
            );
        }

        // increase vault allowance to transfer tokens minus fees from this contract to vault
        address indexTokenCache = vault.indexToken;
        IERC20(ctx.vaultAsset).approve(indexTokenCache, ctx.assetsMinusFees);

        // then perform the actual deposit
        // NOTE: the following call will update the total assets deposited in the vault
        // NOTE: the following call will validate the vault's deposit cap
        // invariant: no tokens should remain stuck in this contract
        ctx.shares = IERC4626(indexTokenCache).deposit(ctx.assetsMinusFees, msg.sender);

        // assert min shares minted
        if (ctx.shares < minShares) revert Errors.SlippageCheckFailed(minShares, ctx.shares);

        // invariant: received shares must be > 0 even when minShares = 0; no donation allowed
        if (ctx.shares == 0) revert Errors.DepositMustReceiveShares();

        // emit an event
        emit LogDeposit(vaultId, msg.sender, ctx.assetsMinusFees);
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using Distribution for Distribution.Data;
using LiveMarkets for LiveMarkets.Data;
using EnumerableSet for EnumerableSet.AddressSet;
using EnumerableSet for EnumerableSet.UintSet;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using SafeCast for int256;
using SafeCast for uint256;
uint128 id;
uint128 autoDeleverageStartThreshold;
uint128 autoDeleverageEndThreshold;
uint128 autoDeleverageExponentZ;
int128 netUsdTokenIssuance;
uint128 creditDepositsValueCacheUsd;
uint128 lastCreditDepositsValueRehydration;
int128 realizedDebtUsdPerVaultShare;
int128 unrealizedDebtUsdPerVaultShare;
uint128 usdcCreditPerVaultShare;
uint128 wethRewardPerVaultShare;
uint128 availableProtocolWethReward;
uint128 totalDelegatedCreditUsd;
address engine;

// Function Implementation:
function getVaultAccumulatedValues(
        Data storage self,
        UD60x18 vaultDelegatedCreditUsdX18,
        SD59x18 lastVaultDistributedRealizedDebtUsdPerShareX18,
        SD59x18 lastVaultDistributedUnrealizedDebtUsdPerShareX18,
        UD60x18 lastVaultDistributedUsdcCreditPerShareX18,
        UD60x18 lastVaultDistributedWethRewardPerShareX18
    )
        internal
        view
        returns (
            SD59x18 realizedDebtChangeUsdX18,
            SD59x18 unrealizedDebtChangeUsdX18,
            UD60x18 usdcCreditChangeX18,
            UD60x18 wethRewardChangeX18
        )
    {
        // calculate the vault's share of the total delegated credit, from 0 to 1
        UD60x18 vaultCreditShareX18 = vaultDelegatedCreditUsdX18.div(getTotalDelegatedCreditUsd(self));

        // calculate the vault's value changes since its last accumulation
        // note: if the last distributed value is zero, we assume it's the first time the vault is accumulating
        // values, thus, it needs to return zero changes

        realizedDebtChangeUsdX18 = !lastVaultDistributedRealizedDebtUsdPerShareX18.isZero()
            ? sd59x18(self.realizedDebtUsdPerVaultShare).sub(lastVaultDistributedRealizedDebtUsdPerShareX18).mul(
                vaultCreditShareX18.intoSD59x18()
            )
            : SD59x18_ZERO;

        unrealizedDebtChangeUsdX18 = !lastVaultDistributedUnrealizedDebtUsdPerShareX18.isZero()
            ? sd59x18(self.unrealizedDebtUsdPerVaultShare).sub(lastVaultDistributedUnrealizedDebtUsdPerShareX18).mul(
                vaultCreditShareX18.intoSD59x18()
            )
            : SD59x18_ZERO;

        usdcCreditChangeX18 = !lastVaultDistributedUsdcCreditPerShareX18.isZero()
            ? ud60x18(self.usdcCreditPerVaultShare).sub(lastVaultDistributedUsdcCreditPerShareX18).mul(
                vaultCreditShareX18
            )
            : UD60x18_ZERO;

        // TODO: fix the vaultCreditShareX18 flow to multiply by `wethRewardChangeX18`
        wethRewardChangeX18 = ud60x18(self.wethRewardPerVaultShare).sub(lastVaultDistributedWethRewardPerShareX18);
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using Distribution for Distribution.Data;
using LiveMarkets for LiveMarkets.Data;
using EnumerableSet for EnumerableSet.AddressSet;
using EnumerableSet for EnumerableSet.UintSet;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using SafeCast for int256;
using SafeCast for uint256;
uint128 id;
uint128 autoDeleverageStartThreshold;
uint128 autoDeleverageEndThreshold;
uint128 autoDeleverageExponentZ;
int128 netUsdTokenIssuance;
uint128 creditDepositsValueCacheUsd;
uint128 lastCreditDepositsValueRehydration;
int128 realizedDebtUsdPerVaultShare;
int128 unrealizedDebtUsdPerVaultShare;
uint128 usdcCreditPerVaultShare;
uint128 wethRewardPerVaultShare;
uint128 availableProtocolWethReward;
uint128 totalDelegatedCreditUsd;
address engine;

// Function Implementation:
function distributeDebtToVaults(
        Data storage self,
        SD59x18 newUnrealizedDebtUsdX18,
        SD59x18 newRealizedDebtUsdX18
    )
        internal
    {
        // cache the total vault's shares as SD59x18
        SD59x18 totalVaultSharesX18 = ud60x18(self.totalDelegatedCreditUsd).intoSD59x18();

        // if there is zero delegated credit and we're trying to distribute debt to vaults, we should revert and the
        // market is considered to be in a panic state
        if (totalVaultSharesX18.isZero()) {
            revert Errors.NoDelegatedCredit(self.id); // here
        }

        // update storage values
        self.realizedDebtUsdPerVaultShare = newRealizedDebtUsdX18.div(totalVaultSharesX18).intoInt256().toInt128();
        self.unrealizedDebtUsdPerVaultShare = newUnrealizedDebtUsdX18.div(totalVaultSharesX18).intoInt256().toInt128();
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using CreditDelegation for CreditDelegation.Data;
using Distribution for Distribution.Data;
using EnumerableSet for EnumerableSet.UintSet;
using Market for Market.Data;
using SafeCast for uint256;
using SafeCast for int256;
uint128 usdcDexSwapStrategyId;
bytes usdcDexSwapPath;
uint128 assetDexSwapStrategyId;
bytes assetDexSwapPath;
uint256 depositFee;
uint256 redeemFee;
uint128 id;
uint128 totalCreditDelegationWeight;
uint128 depositCap;
uint128 withdrawalDelay;
uint128 lockedCreditRatio;
int128 marketsUnrealizedDebtUsd;
int128 marketsRealizedDebtUsd;
uint128 depositedUsdc;
address indexToken;
address engine;
bool isLive;
SwapStrategy swapStrategy;
mapping(address => uint128) withdrawalRequestIdCounter;
uint256 depositFee;
uint256 redeemFee;
uint128 vaultId;
uint128 depositCap;
uint128 withdrawalDelay;
address indexToken;
address engine;
uint128 vaultId;
uint128 depositCap;
uint128 withdrawalDelay;
bool isLive;
uint128 lockedCreditRatio;

// Function Implementation:
function _updateCreditDelegations(
        Data storage self,
        uint128[] memory connectedMarketsIdsCache,
        bool shouldRehydrateCache
    )
        private
        returns (uint128[] memory rehydratedConnectedMarketsIdsCache, SD59x18 vaultCreditCapacityUsdX18)
    {
        rehydratedConnectedMarketsIdsCache = new uint128[](connectedMarketsIdsCache.length);
        // cache the vault id
        uint128 vaultId = self.id;

        // cache the connected markets length
        uint256 connectedMarketsConfigLength = self.connectedMarkets.length;

        // loads the connected markets storage pointer by taking the last configured market ids uint set
        EnumerableSet.UintSet storage connectedMarkets = self.connectedMarkets[connectedMarketsConfigLength - 1];

        // loop over each connected market id that has been cached once again in order to update this vault's
        // credit delegations
        for (uint256 i; i < connectedMarketsIdsCache.length; i++) {
            // rehydrate the markets ids cache if needed
            if (shouldRehydrateCache) {
                rehydratedConnectedMarketsIdsCache[i] = connectedMarkets.at(i).toUint128();
            } else {
                rehydratedConnectedMarketsIdsCache[i] = connectedMarketsIdsCache[i];
            }

            // loads the memory cached market id
            uint128 connectedMarketId = rehydratedConnectedMarketsIdsCache[i];

            // load the credit delegation to the given market id
            CreditDelegation.Data storage creditDelegation = CreditDelegation.load(vaultId, connectedMarketId);

            // cache the previous credit delegation value
            UD60x18 previousCreditDelegationUsdX18 = ud60x18(creditDelegation.valueUsd);

            // cache the latest credit delegation share of the vault's credit capacity
            uint128 totalCreditDelegationWeightCache = self.totalCreditDelegationWeight;

            if (totalCreditDelegationWeightCache != 0) {
                // get the latest credit delegation share of the vault's credit capacity
                UD60x18 creditDelegationShareX18 =
                    ud60x18(creditDelegation.weight).div(ud60x18(totalCreditDelegationWeightCache));

                // stores the vault's total credit capacity to be returned
                vaultCreditCapacityUsdX18 = getTotalCreditCapacityUsd(self);

                // if the vault's credit capacity went to zero or below, we set its credit delegation to that market
                // to zero
                UD60x18 newCreditDelegationUsdX18 = vaultCreditCapacityUsdX18.gt(SD59x18_ZERO)
                    ? vaultCreditCapacityUsdX18.intoUD60x18().mul(creditDelegationShareX18)
                    : UD60x18_ZERO;

                // calculate the delta applied to the market's total delegated credit
                UD60x18 creditDeltaUsdX18 = newCreditDelegationUsdX18.sub(previousCreditDelegationUsdX18);

                // loads the market's storage pointer and update total delegated credit
                Market.Data storage market = Market.load(connectedMarketId);
                market.updateTotalDelegatedCredit(creditDeltaUsdX18);

                // if new credit delegation is zero, we clear the credit delegation storage
                if (newCreditDelegationUsdX18.isZero()) {
                    creditDelegation.clear();
                } else {
                    // update the credit delegation stored usd value
                    creditDelegation.valueUsd = newCreditDelegationUsdX18.intoUint128();
                }
            }
        }
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using CreditDelegation for CreditDelegation.Data;
using Distribution for Distribution.Data;
using EnumerableSet for EnumerableSet.UintSet;
using Market for Market.Data;
using SafeCast for uint256;
using SafeCast for int256;
uint128 usdcDexSwapStrategyId;
bytes usdcDexSwapPath;
uint128 assetDexSwapStrategyId;
bytes assetDexSwapPath;
uint256 depositFee;
uint256 redeemFee;
uint128 id;
uint128 totalCreditDelegationWeight;
uint128 depositCap;
uint128 withdrawalDelay;
uint128 lockedCreditRatio;
int128 marketsUnrealizedDebtUsd;
int128 marketsRealizedDebtUsd;
uint128 depositedUsdc;
address indexToken;
address engine;
bool isLive;
SwapStrategy swapStrategy;
mapping(address => uint128) withdrawalRequestIdCounter;
uint256 depositFee;
uint256 redeemFee;
uint128 vaultId;
uint128 depositCap;
uint128 withdrawalDelay;
address indexToken;
address engine;
uint128 vaultId;
uint128 depositCap;
uint128 withdrawalDelay;
bool isLive;
uint128 lockedCreditRatio;

// Function Implementation:
function getTotalCreditCapacityUsd(Data storage self) internal view returns (SD59x18 creditCapacityUsdX18) {
        // load the collateral configuration storage pointer
        Collateral.Data storage collateral = self.collateral;

        // fetch the zlp vault's total assets amount
        UD60x18 totalAssetsX18 = ud60x18(IERC4626(self.indexToken).totalAssets());

        // calculate the total assets value in usd terms
        UD60x18 totalAssetsUsdX18 = collateral.getAdjustedPrice().mul(totalAssetsX18);

        // calculate the vault's credit capacity in usd terms
        creditCapacityUsdX18 = totalAssetsUsdX18.intoSD59x18().sub(getTotalDebt(self));
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using CreditDelegation for CreditDelegation.Data;
using Distribution for Distribution.Data;
using EnumerableSet for EnumerableSet.UintSet;
using Market for Market.Data;
using SafeCast for uint256;
using SafeCast for int256;
uint128 usdcDexSwapStrategyId;
bytes usdcDexSwapPath;
uint128 assetDexSwapStrategyId;
bytes assetDexSwapPath;
uint256 depositFee;
uint256 redeemFee;
uint128 id;
uint128 totalCreditDelegationWeight;
uint128 depositCap;
uint128 withdrawalDelay;
uint128 lockedCreditRatio;
int128 marketsUnrealizedDebtUsd;
int128 marketsRealizedDebtUsd;
uint128 depositedUsdc;
address indexToken;
address engine;
bool isLive;
SwapStrategy swapStrategy;
mapping(address => uint128) withdrawalRequestIdCounter;
uint256 depositFee;
uint256 redeemFee;
uint128 vaultId;
uint128 depositCap;
uint128 withdrawalDelay;
address indexToken;
address engine;
uint128 vaultId;
uint128 depositCap;
uint128 withdrawalDelay;
bool isLive;
uint128 lockedCreditRatio;

// Function Implementation:
function getTotalDebt(Data storage self) internal view returns (SD59x18 totalDebtUsdX18) {
        totalDebtUsdX18 = getUnrealizedDebtUsd(self).add(getRealizedDebtUsd(self));
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using CreditDelegation for CreditDelegation.Data;
using Distribution for Distribution.Data;
using EnumerableSet for EnumerableSet.UintSet;
using Market for Market.Data;
using SafeCast for uint256;
using SafeCast for int256;
uint128 usdcDexSwapStrategyId;
bytes usdcDexSwapPath;
uint128 assetDexSwapStrategyId;
bytes assetDexSwapPath;
uint256 depositFee;
uint256 redeemFee;
uint128 id;
uint128 totalCreditDelegationWeight;
uint128 depositCap;
uint128 withdrawalDelay;
uint128 lockedCreditRatio;
int128 marketsUnrealizedDebtUsd;
int128 marketsRealizedDebtUsd;
uint128 depositedUsdc;
address indexToken;
address engine;
bool isLive;
SwapStrategy swapStrategy;
mapping(address => uint128) withdrawalRequestIdCounter;
uint256 depositFee;
uint256 redeemFee;
uint128 vaultId;
uint128 depositCap;
uint128 withdrawalDelay;
address indexToken;
address engine;
uint128 vaultId;
uint128 depositCap;
uint128 withdrawalDelay;
bool isLive;
uint128 lockedCreditRatio;

// Function Implementation:
function getUnsettledRealizedDebt(Data storage self)
        internal
        view
        returns (SD59x18 unsettledRealizedDebtUsdX18)
    {
        unsettledRealizedDebtUsdX18 =
            sd59x18(self.marketsRealizedDebtUsd).add(unary(ud60x18(self.depositedUsdc).intoSD59x18()));
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using Distribution for Distribution.Data;
using LiveMarkets for LiveMarkets.Data;
using EnumerableSet for EnumerableSet.AddressSet;
using EnumerableSet for EnumerableSet.UintSet;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using SafeCast for int256;
using SafeCast for uint256;
uint128 id;
uint128 autoDeleverageStartThreshold;
uint128 autoDeleverageEndThreshold;
uint128 autoDeleverageExponentZ;
int128 netUsdTokenIssuance;
uint128 creditDepositsValueCacheUsd;
uint128 lastCreditDepositsValueRehydration;
int128 realizedDebtUsdPerVaultShare;
int128 unrealizedDebtUsdPerVaultShare;
uint128 usdcCreditPerVaultShare;
uint128 wethRewardPerVaultShare;
uint128 availableProtocolWethReward;
uint128 totalDelegatedCreditUsd;
address engine;

// Function Implementation:
function updateTotalDelegatedCredit(Data storage self, SD59x18 creditDeltaUsdX18) internal {
        self.totalDelegatedCreditUsd =
            ud60x18(self.totalDelegatedCreditUsd).intoSD59x18().add(creditDeltaUsdX18).intoUD60x18().intoUint128();
    }

// Contract State Variables:
using DexSwapStrategy for DexSwapStrategy.Data;
using EnumerableSet for EnumerableSet.UintSet;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;
using SafeCast for uint256;
using DexSwapStrategy for DexSwapStrategy.Data;
using LiveMarkets for LiveMarkets.Data;
using AssetSwapPath for AssetSwapPath.Data;

// Function Implementation:
function _configureVaultConnectedMarkets(uint128 vaultId, uint256[] calldata marketsIds) internal {
        // revert if vaultId is set to zero
        if (vaultId == 0) {
            revert Errors.ZeroInput("vaultId");
        }

        // load vault data from storage
        Vault.Data storage vault = Vault.load(vaultId);

        // push new array of connected markets
        vault.connectedMarkets.push();

        // use [vault.connectedMarkets.length - 1] to get the last connected markets array
        uint256 connectedMarketsConfigIndex = vault.connectedMarkets.length - 1;

        // add markets ids to connected markets
        for (uint256 i; i < marketsIds.length; i++) {
            vault.connectedMarkets[connectedMarketsConfigIndex].add(marketsIds[i]);
        }

        // emit event LogConfigureVaultConnectedMarkets
        emit LogConfigureVaultConnectedMarkets(vaultId, marketsIds);
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using CreditDelegation for CreditDelegation.Data;
using Distribution for Distribution.Data;
using EnumerableSet for EnumerableSet.UintSet;
using Market for Market.Data;
using SafeCast for uint256;
using SafeCast for int256;
uint128 usdcDexSwapStrategyId;
bytes usdcDexSwapPath;
uint128 assetDexSwapStrategyId;
bytes assetDexSwapPath;
uint256 depositFee;
uint256 redeemFee;
uint128 id;
uint128 totalCreditDelegationWeight;
uint128 depositCap;
uint128 withdrawalDelay;
uint128 lockedCreditRatio;
int128 marketsUnrealizedDebtUsd;
int128 marketsRealizedDebtUsd;
uint128 depositedUsdc;
address indexToken;
address engine;
bool isLive;
SwapStrategy swapStrategy;
mapping(address => uint128) withdrawalRequestIdCounter;
uint256 depositFee;
uint256 redeemFee;
uint128 vaultId;
uint128 depositCap;
uint128 withdrawalDelay;
address indexToken;
address engine;
uint128 vaultId;
uint128 depositCap;
uint128 withdrawalDelay;
bool isLive;
uint128 lockedCreditRatio;

// Function Implementation:
function loadLive(uint128 marketId) internal view returns (Data storage market) {
        market = loadExisting(marketId);

        if (!LiveMarkets.load().containsMarket(marketId)) {
            revert Errors.MarketIsDisabled(marketId);
        }
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using Distribution for Distribution.Data;
using LiveMarkets for LiveMarkets.Data;
using EnumerableSet for EnumerableSet.AddressSet;
using EnumerableSet for EnumerableSet.UintSet;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using SafeCast for int256;
using SafeCast for uint256;
uint128 id;
uint128 autoDeleverageStartThreshold;
uint128 autoDeleverageEndThreshold;
uint128 autoDeleverageExponentZ;
int128 netUsdTokenIssuance;
uint128 creditDepositsValueCacheUsd;
uint128 lastCreditDepositsValueRehydration;
int128 realizedDebtUsdPerVaultShare;
int128 unrealizedDebtUsdPerVaultShare;
uint128 usdcCreditPerVaultShare;
uint128 wethRewardPerVaultShare;
uint128 availableProtocolWethReward;
uint128 totalDelegatedCreditUsd;
address engine;

// Function Implementation:
function depositFee(Data storage self, address asset, UD60x18 amountX18) internal {
        AssetToAmountMap.update(self.receivedFees, asset, amountX18, true);
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using DexSwapStrategy for DexSwapStrategy.Data;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using Market for Market.Data;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;
using SafeCast for uint256;
using SafeCast for uint128;
using SafeCast for int256;
using SafeERC20 for IERC20;
using Vault for Vault.Data;

// Function Implementation:
function withdrawUsdTokenFromMarket(uint128 marketId, uint256 amount) external onlyRegisteredEngine(marketId) {
        // loads the market's data and connected vaults
        Market.Data storage market = Market.loadLive(marketId);
        uint256[] memory connectedVaults = market.getConnectedVaultsIds();

        // once the unrealized debt is distributed update credit delegated
        // by these vaults to the market
        Vault.recalculateVaultsCreditCapacity(connectedVaults);

        // cache the market's total debt and delegated credit
        SD59x18 marketTotalDebtUsdX18 = market.getTotalDebt();
        UD60x18 delegatedCreditUsdX18 = market.getTotalDelegatedCreditUsd();

        // calculate the market's credit capacity
        SD59x18 creditCapacityUsdX18 = Market.getCreditCapacityUsd(delegatedCreditUsdX18, marketTotalDebtUsdX18);

        // enforces that the market has enough credit capacity, if it's a listed market it must always have some
        // delegated credit, see Vault.Data.lockedCreditRatio.
        // NOTE: additionally, the ADL system if functioning properly must ensure that the market always has credit
        // capacity to cover USD Token mint requests. Deleverage happens when the perps engine calls
        // CreditDelegationBranch::getAdjustedProfitForMarketId.
        // NOTE: however, it still is possible to fall into a scenario where the credit capacity is <= 0, as the
        // delegated credit may be provided in form of volatile collateral assets, which could go down in value as
        // debt reaches its ceiling. In that case, the market will run out of mintable USD Token and the mm engine
        // must settle all outstanding debt for USDC, in order to keep previously paid USD Token fully backed.
        if (creditCapacityUsdX18.lte(SD59x18_ZERO)) {
            revert Errors.InsufficientCreditCapacity(marketId, creditCapacityUsdX18.intoInt256());
        }

        // uint256 -> UD60x18
        // NOTE: we don't need to scale decimals here as it's known that USD Token has 18 decimals
        UD60x18 amountX18 = ud60x18(amount);

        // prepare the amount of usdToken that will be minted to the perps engine;
        // initialize to default non-ADL state
        uint256 amountToMint = amount;

        // now we realize the added usd debt of the market
        // note: USD Token is assumed to be 1:1 with the system's usd accounting
        if (market.isAutoDeleverageTriggered(delegatedCreditUsdX18, marketTotalDebtUsdX18)) {
            // if the market is in the ADL state, it reduces the requested USD
            // Token amount by multiplying it by the ADL factor, which must be < 1
            UD60x18 adjustedUsdTokenToMintX18 =
                market.getAutoDeleverageFactor(delegatedCreditUsdX18, marketTotalDebtUsdX18).mul(amountX18);

            amountToMint = adjustedUsdTokenToMintX18.intoUint256();
            market.updateNetUsdTokenIssuance(adjustedUsdTokenToMintX18.intoSD59x18());
        } else {
            // if the market is not in the ADL state, it realizes the full requested USD Token amount
            market.updateNetUsdTokenIssuance(amountX18.intoSD59x18());
        }

        // loads the market making engine configuration storage pointer
        MarketMakingEngineConfiguration.Data storage marketMakingEngineConfiguration =
            MarketMakingEngineConfiguration.load();

        // mint USD Token to the perps engine
        UsdToken usdToken = UsdToken(marketMakingEngineConfiguration.usdTokenOfEngine[msg.sender]);
        usdToken.mint(msg.sender, amountToMint);

        // emit an event
        emit LogWithdrawUsdTokenFromMarket(msg.sender, marketId, amount, amountToMint);
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using DexSwapStrategy for DexSwapStrategy.Data;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using Market for Market.Data;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;
using SafeCast for uint256;
using SafeCast for uint128;
using SafeCast for int256;
using SafeERC20 for IERC20;
using Vault for Vault.Data;

// Function Implementation:
function updateVaultCreditCapacity(uint128 vaultId) external {
        // prepare the `Vault::recalculateVaultsCreditCapacity` call
        uint256[] memory vaultsIds = new uint256[](1);
        vaultsIds[0] = uint256(vaultId);

        // updates the vault's credit capacity
        Vault.recalculateVaultsCreditCapacity(vaultsIds);
    }

// Contract State Variables:
using SafeERC20 for IERC20;
using Collateral for Collateral.Data;
using Distribution for Distribution.Data;
using Vault for Vault.Data;
using SafeCast for uint256;
using MathOpenZeppelin for uint256;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;

// Function Implementation:
function unstake(uint128 vaultId, uint256 shares) external {
        // fetch storage slot for vault by id
        Vault.Data storage vault = Vault.loadLive(vaultId);

        // prepare the `Vault::recalculateVaultsCreditCapacity` call
        uint256[] memory vaultsIds = new uint256[](1);
        vaultsIds[0] = uint256(vaultId);

        // updates the vault's credit capacity and perform all vault
        // state transitions before updating `msg.sender` staked shares
        Vault.recalculateVaultsCreditCapacity(vaultsIds);

        // get vault staking fee distribution data
        Distribution.Data storage wethRewardDistribution = vault.wethRewardDistribution;

        // cast actor address to bytes32
        bytes32 actorId = bytes32(uint256(uint160(msg.sender)));

        // get the claimable amount of fees
        UD60x18 amountToClaimX18 = vault.wethRewardDistribution.getActorValueChange(actorId).intoUD60x18();

        // reverts if the claimable amount is NOT 0
        if (!amountToClaimX18.isZero()) revert Errors.UserHasPendingRewards(actorId, amountToClaimX18.intoUint256());

        // accumulate the actor's pending reward before unstaking
        wethRewardDistribution.accumulateActor(actorId);

        // get actor staked shares
        UD60x18 actorShares = wethRewardDistribution.getActorShares(actorId);

        // verify actor has shares they are attempting to unstake
        if (actorShares.lt(ud60x18(shares))) revert Errors.NotEnoughShares();

        UD60x18 updatedActorShares = actorShares.sub(ud60x18(shares));

        // update actor shares
        wethRewardDistribution.setActorShares(actorId, updatedActorShares);

        // transfer shares to user
        IERC20(vault.indexToken).safeTransfer(msg.sender, shares);

        // emit an event
        emit LogUnstake(vaultId, msg.sender, shares);
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using DexSwapStrategy for DexSwapStrategy.Data;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using Market for Market.Data;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;
using SafeCast for uint256;
using SafeCast for uint128;
using SafeCast for int256;
using SafeERC20 for IERC20;
using Vault for Vault.Data;

// Function Implementation:
function rebalanceVaultsAssets(uint128[2] calldata vaultsIds) external onlyRegisteredSystemKeepers {
        // load the storage pointers of the vaults in net credit and net debt
        Vault.Data storage inCreditVault = Vault.loadExisting(vaultsIds[0]);
        Vault.Data storage inDebtVault = Vault.loadExisting(vaultsIds[1]);

        // both vaults must belong to the same engine in order to have their debt
        // state rebalanced, as each usd token's debt is isolated
        if (inCreditVault.engine != inDebtVault.engine) {
            revert Errors.VaultsConnectedToDifferentEngines();
        }

        // create an in-memory dynamic array in order to call `Vault::recalculateVaultsCreditCapacity`
        uint256[] memory vaultsIdsForRecalculation = new uint256[](2);
        vaultsIdsForRecalculation[0] = vaultsIds[0];
        vaultsIdsForRecalculation[1] = vaultsIds[1];

        // recalculate the credit capacity of both vaults
        Vault.recalculateVaultsCreditCapacity(vaultsIdsForRecalculation);

        // cache the in debt vault & in credit vault unsettled debt
        SD59x18 inDebtVaultUnsettledRealizedDebtUsdX18 = inDebtVault.getUnsettledRealizedDebt();
        SD59x18 inCreditVaultUnsettledRealizedDebtUsdX18 = inCreditVault.getUnsettledRealizedDebt();

        // revert if 1) the vault that is supposed to be in credit is not OR
        //           2) the vault that is supposed to be in debt is not
        if (
            inCreditVaultUnsettledRealizedDebtUsdX18.lte(SD59x18_ZERO)
                || inDebtVaultUnsettledRealizedDebtUsdX18.gte(SD59x18_ZERO)
        ) {
            revert Errors.InvalidVaultDebtSettlementRequest();
        }

        // get debt absolute value
        SD59x18 inDebtVaultUnsettledRealizedDebtUsdX18Abs = inDebtVaultUnsettledRealizedDebtUsdX18.abs();

        // if debt absolute value > credit, use credit value, else use debt value
        SD59x18 depositAmountUsdX18 = inCreditVaultUnsettledRealizedDebtUsdX18.gt(
            inDebtVaultUnsettledRealizedDebtUsdX18Abs
        ) ? inDebtVaultUnsettledRealizedDebtUsdX18Abs : inCreditVaultUnsettledRealizedDebtUsdX18;

        // loads the dex swap strategy data storage pointer
        DexSwapStrategy.Data storage dexSwapStrategy =
            DexSwapStrategy.loadExisting(inDebtVault.swapStrategy.usdcDexSwapStrategyId);

        // load usdc address
        address usdc = MarketMakingEngineConfiguration.load().usdc;

        // cache input asset and dex adapter
        CalculateSwapContext memory ctx;
        ctx.inDebtVaultCollateralAsset = inDebtVault.collateral.asset;
        ctx.dexAdapter = dexSwapStrategy.dexAdapter;

        // get collateral asset amount in native precision of ctx.inDebtVaultCollateralAsset
        uint256 assetInputNative = IDexAdapter(ctx.dexAdapter).getExpectedOutput(
            usdc,
            ctx.inDebtVaultCollateralAsset,
            // convert usdc input to native precision
            Collateral.load(usdc).convertSd59x18ToTokenAmount(depositAmountUsdX18)
        );

        // prepare the data for executing the swap asset -> usdc
        SwapExactInputSinglePayload memory swapCallData = SwapExactInputSinglePayload({
            tokenIn: ctx.inDebtVaultCollateralAsset,
            tokenOut: usdc,
            amountIn: assetInputNative,
            recipient: address(this) // deposit the usdc to the market making engine proxy
         });

        // approve the collateral token to the dex adapter and swap assets for USDC
        IERC20(ctx.inDebtVaultCollateralAsset).approve(ctx.dexAdapter, assetInputNative);
        dexSwapStrategy.executeSwapExactInputSingle(swapCallData);

        // SD59x18 -> uint128 using zaros internal precision
        uint128 usdDelta = depositAmountUsdX18.intoUint256().toUint128();

        // important considerations:
        // 1) all subsequent storge updates must use zaros internal precision
        // 2) code implicitly assumes that 1 USD = 1 USDC
        //
        // deposits the USDC to the in-credit vault
        inCreditVault.depositedUsdc += usdDelta;
        // increase the in-credit vault's share of the markets realized debt
        // as it has received the USDC and needs to settle it in the future
        inCreditVault.marketsRealizedDebtUsd += usdDelta.toInt256().toInt128();

        // withdraws the USDC from the in-debt vault
        inDebtVault.depositedUsdc -= usdDelta;
        // decrease the in-debt vault's share of the markets realized debt
        // as it has transferred USDC to the in-credit vault
        inDebtVault.marketsRealizedDebtUsd -= usdDelta.toInt256().toInt128();

        // emit an event
        emit LogRebalanceVaultsAssets(vaultsIds[0], vaultsIds[1], usdDelta);
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using DexSwapStrategy for DexSwapStrategy.Data;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using Market for Market.Data;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;
using SafeCast for uint256;
using SafeCast for uint128;
using SafeCast for int256;
using SafeERC20 for IERC20;
using Vault for Vault.Data;

// Function Implementation:
function updateMarketCreditDelegations(uint128 marketId) public {
        Vault.recalculateVaultsCreditCapacity(Market.loadLive(marketId).getConnectedVaultsIds());
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using DexSwapStrategy for DexSwapStrategy.Data;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using Market for Market.Data;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;
using SafeCast for uint256;
using SafeCast for uint128;
using SafeCast for int256;
using SafeERC20 for IERC20;
using Vault for Vault.Data;

// Function Implementation:
function updateMarketCreditDelegationsAndReturnCapacity(uint128 marketId)
        external
        returns (SD59x18 creditCapacity)
    {
        updateMarketCreditDelegations(marketId);
        creditCapacity = getCreditCapacityForMarketId(marketId);
    }

// Contract State Variables:
using SafeERC20 for IERC20;
using Collateral for Collateral.Data;
using Distribution for Distribution.Data;
using Vault for Vault.Data;
using SafeCast for uint256;
using MathOpenZeppelin for uint256;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;

// Function Implementation:
function redeem(uint128 vaultId, uint128 withdrawalRequestId, uint256 minAssets) external {
        // fetch storage slot for vault by id
        Vault.Data storage vault = Vault.loadLive(vaultId);

        // load storage slot for previously created withdrawal request
        WithdrawalRequest.Data storage withdrawalRequest =
            WithdrawalRequest.loadExisting(vaultId, msg.sender, withdrawalRequestId);

        // revert if withdrawal request already fulfilled
        if (withdrawalRequest.fulfilled) revert Errors.WithdrawalRequestAlreadyFulfilled();

        // revert if withdrawal request delay not yet passed
        if (withdrawalRequest.timestamp + vault.withdrawalDelay > block.timestamp) {
            revert Errors.WithdrawDelayNotPassed();
        }

        // prepare the `Vault::recalculateVaultsCreditCapacity` call
        uint256[] memory vaultsIds = new uint256[](1);
        vaultsIds[0] = uint256(vaultId);

        // updates the vault's credit capacity before redeeming
        Vault.recalculateVaultsCreditCapacity(vaultsIds);

        // define context struct, get withdraw shares and associated assets
        RedeemContext memory ctx;
        ctx.shares = withdrawalRequest.shares;
        ctx.expectedAssetsX18 = getIndexTokenSwapRate(vaultId, ctx.shares, false);

        // load the mm engine configuration from storage
        MarketMakingEngineConfiguration.Data storage marketMakingEngineConfiguration =
            MarketMakingEngineConfiguration.load();

        // cache vault's redeem fee
        ctx.redeemFee = vault.redeemFee;

        // get assets minus redeem fee
        ctx.expectedAssetsMinusRedeemFeeX18 =
            ctx.expectedAssetsX18.sub(ctx.expectedAssetsX18.mul(ud60x18(ctx.redeemFee)));

        // calculate assets minus redeem fee as shares
        ctx.sharesMinusRedeemFeesX18 =
            getVaultAssetSwapRate(vaultId, ctx.expectedAssetsMinusRedeemFeeX18.intoUint256(), false);

        // get the shares to send to the vault deposit and redeem fee recipient
        ctx.sharesFees = ctx.shares - ctx.sharesMinusRedeemFeesX18.intoUint256();

        // cache the vault's credit capacity before redeeming
        ctx.creditCapacityBeforeRedeemUsdX18 = vault.getTotalCreditCapacityUsd();

        // cache the locked credit capacity before redeeming
        ctx.lockedCreditCapacityBeforeRedeemUsdX18 = vault.getLockedCreditCapacityUsd();

        // redeem shares previously transferred to the contract at `initiateWithdrawal` and store the returned assets
        address indexToken = vault.indexToken;
        uint256 assets =
            IERC4626(indexToken).redeem(ctx.sharesMinusRedeemFeesX18.intoUint256(), msg.sender, address(this));

        // get the redeem fee
        if (ctx.sharesFees > 0) {
            IERC4626(indexToken).redeem(
                ctx.sharesFees, marketMakingEngineConfiguration.vaultDepositAndRedeemFeeRecipient, address(this)
            );
        }

        // require at least min assets amount returned
        if (assets < minAssets) revert Errors.SlippageCheckFailed(minAssets, assets);

        // invariant: received assets must be > 0 even when minAssets = 0
        if (assets == 0) revert Errors.RedeemMustReceiveAssets();

        // if the credit capacity delta is greater than the locked credit capacity before the state transition, revert
        if (
            ctx.creditCapacityBeforeRedeemUsdX18.sub(vault.getTotalCreditCapacityUsd()).lte(
                ctx.lockedCreditCapacityBeforeRedeemUsdX18.intoSD59x18()
            )
        ) {
            revert Errors.NotEnoughUnlockedCreditCapacity();
        }

        // set withdrawal request to fulfilled
        withdrawalRequest.fulfilled = true;

        // emit an event
        emit LogRedeem(vaultId, msg.sender, ctx.sharesMinusRedeemFeesX18.intoUint256());
    }

// Contract State Variables:
using DexSwapStrategy for DexSwapStrategy.Data;
using EnumerableSet for EnumerableSet.UintSet;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;
using SafeCast for uint256;
using DexSwapStrategy for DexSwapStrategy.Data;
using LiveMarkets for LiveMarkets.Data;
using AssetSwapPath for AssetSwapPath.Data;

// Function Implementation:
function configureDepositAndRedeemFees(
        uint128[] calldata vaultsIds,
        uint128[] calldata depositFees,
        uint128[] calldata redeemFees
    )
        external
        onlyOwner
    {
        // verify the array length
        if (vaultsIds.length != depositFees.length) {
            revert Errors.ArrayLengthMismatch(vaultsIds.length, depositFees.length);
        }

        // verify the array length
        if (depositFees.length != redeemFees.length) {
            revert Errors.ArrayLengthMismatch(vaultsIds.length, depositFees.length);
        }

        // loop over the arrays
        for (uint256 i; i < vaultsIds.length; i++) {
            // load vault data from storage
            Vault.Data storage vault = Vault.load(vaultsIds[i]);

            // update deposit and redeem fees
            vault.depositFee = depositFees[i];
            vault.redeemFee = redeemFees[i];

            // emit events
            emit LogConfigureRedeemFee(vaultsIds[i], redeemFees[i]);
            emit LogConfigureDepositFee(vaultsIds[i], depositFees[i]);
        }
    }

// Contract State Variables:
using DexSwapStrategy for DexSwapStrategy.Data;
using EnumerableSet for EnumerableSet.UintSet;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;
using SafeCast for uint256;
using DexSwapStrategy for DexSwapStrategy.Data;
using LiveMarkets for LiveMarkets.Data;
using AssetSwapPath for AssetSwapPath.Data;

// Function Implementation:
function configureVaultDepositAndRedeemFeeRecipient(address vaultDepositAndRedeemFeeRecipient)
        external
        onlyOwner
    {
        // revert if the vaultDepositAndRedeemFeeRecipient is zero
        if (vaultDepositAndRedeemFeeRecipient == address(0)) {
            revert Errors.ZeroInput("vaultDepositAndRedeemFeeRecipient");
        }

        // load the market making engine configuration from storage
        MarketMakingEngineConfiguration.Data storage marketMakingEngineConfiguration =
            MarketMakingEngineConfiguration.load();

        // update the vault deposit and redeem fee recipient
        marketMakingEngineConfiguration.vaultDepositAndRedeemFeeRecipient = vaultDepositAndRedeemFeeRecipient;

        // emit the LogConfigureVaultDepositAndRedeemFeeRecipient event
        emit LogConfigureVaultDepositAndRedeemFeeRecipient(vaultDepositAndRedeemFeeRecipient);
    }

// Contract State Variables:
using SafeERC20 for IERC20;
using Collateral for Collateral.Data;
using Distribution for Distribution.Data;
using Vault for Vault.Data;
using SafeCast for uint256;
using MathOpenZeppelin for uint256;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;

// Function Implementation:
function getIndexTokenSwapRate(
        uint128 vaultId,
        uint256 sharesIn,
        bool shouldDiscountRedeemFee
    )
        public
        view
        returns (UD60x18 assetsOut)
    {
        // fetch storage slot for vault by id
        Vault.Data storage vault = Vault.loadExisting(vaultId);

        // get the vault's net credit capacity, i.e its total assets usd value minus its total debt (or adding its
        // credit if debt is negative)
        uint256 totalAssetsMinusVaultDebt = getVaultCreditCapacity(vaultId);

        // get decimal offset
        uint8 decimalOffset = Constants.SYSTEM_DECIMALS - IERC20Metadata(vault.indexToken).decimals();

        // Get the asset amount out for the input amount of shares, taking into account the vault's debt
        // See {IERC4626-previewRedeem}
        // `IERC4626(vault.indexToken).totalSupply() + 10 ** decimalOffset` could lead to problems
        uint256 previewAssetsOut = sharesIn.mulDiv(
            totalAssetsMinusVaultDebt,
            IERC4626(vault.indexToken).totalSupply() + 10 ** decimalOffset,
            MathOpenZeppelin.Rounding.Floor
        );

        // verify if should discount redeem fee
        if (shouldDiscountRedeemFee) {
            // get the preview assets out discounting redeem fee
            previewAssetsOut =
                ud60x18(previewAssetsOut).sub(ud60x18(previewAssetsOut).mul(ud60x18(vault.redeemFee))).intoUint256();
        }

        // Return the final adjusted amountOut as UD60x18
        return ud60x18(previewAssetsOut);
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using DexSwapStrategy for DexSwapStrategy.Data;
using Distribution for Distribution.Data;
using EnumerableSet for EnumerableSet.AddressSet;
using EnumerableSet for EnumerableSet.UintSet;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using Market for Market.Data;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;
using SafeERC20 for IERC20;
using Vault for Vault.Data;

// Function Implementation:
function _handleWethRewardDistribution(
        Market.Data storage market,
        address assetOut,
        UD60x18 receivedWethX18
    )
        internal
    {
        // cache the total fee recipients shares as UD60x18
        UD60x18 feeRecipientsSharesX18 = ud60x18(MarketMakingEngineConfiguration.load().totalFeeRecipientsShares);

        // calculate the weth rewards for protocol and vaults
        UD60x18 receivedProtocolWethRewardX18 = receivedWethX18.mul(feeRecipientsSharesX18);
        UD60x18 receivedVaultsWethRewardX18 =
            receivedWethX18.mul(ud60x18(Constants.MAX_SHARES).sub(feeRecipientsSharesX18));

        // calculate leftover reward
        UD60x18 leftover = receivedWethX18.sub(receivedProtocolWethRewardX18).sub(receivedVaultsWethRewardX18);

        // add leftover reward to vault reward
        receivedVaultsWethRewardX18 = receivedVaultsWethRewardX18.add(leftover);

        // adds the weth received for protocol and vaults rewards using the assets previously paid by the engine
        // as fees, and remove its balance from the market's `receivedMarketFees` map
        market.receiveWethReward(assetOut, receivedProtocolWethRewardX18, receivedVaultsWethRewardX18);

        // recalculate markes' vaults credit delegations after receiving fees to push reward distribution
        Vault.recalculateVaultsCreditCapacity(market.getConnectedVaultsIds());
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using DexSwapStrategy for DexSwapStrategy.Data;
using Distribution for Distribution.Data;
using EnumerableSet for EnumerableSet.AddressSet;
using EnumerableSet for EnumerableSet.UintSet;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using Market for Market.Data;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;
using SafeERC20 for IERC20;
using Vault for Vault.Data;

// Function Implementation:
function receiveMarketFee(
        uint128 marketId,
        address asset,
        uint256 amount
    )
        external
        onlyRegisteredEngine(marketId)
    {
        // verify input amount
        if (amount == 0) revert Errors.ZeroInput("amount");

        // loads the market data storage pointer
        Market.Data storage market = Market.loadExisting(marketId);

        // loads the collateral's data storage pointer
        Collateral.Data storage collateral = Collateral.load(asset);

        // reverts if collateral isn't supported
        collateral.verifyIsEnabled();

        // convert uint256 -> UD60x18; scales input amount to 18 decimals
        UD60x18 amountX18 = collateral.convertTokenAmountToUd60x18(amount);

        // transfer fee amount
        // note: we're calling `ERC20::transferFrom` before state transitions as `_handleWethRewardDistribution`
        // requires assets to be in the contract
        IERC20(asset).safeTransferFrom(msg.sender, address(this), amount);

        if (asset == MarketMakingEngineConfiguration.load().weth) {
            // if asset is weth, we can skip straight to handling the weth reward distribution
            _handleWethRewardDistribution(market, address(0), amountX18);
        } else {
            // update [asset => received fees] mapping
            market.depositFee(asset, amountX18);
        }

        // emit event to log the received fee
        emit LogReceiveMarketFee(asset, marketId, amount);
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using DexSwapStrategy for DexSwapStrategy.Data;
using Distribution for Distribution.Data;
using EnumerableSet for EnumerableSet.AddressSet;
using EnumerableSet for EnumerableSet.UintSet;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using Market for Market.Data;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;
using SafeERC20 for IERC20;
using Vault for Vault.Data;

// Function Implementation:
function convertAccumulatedFeesToWeth(
        uint128 marketId,
        address asset,
        uint128 dexSwapStrategyId,
        bytes calldata path
    )
        external
        onlyRegisteredSystemKeepers
    {
        // loads the collateral data storage pointer, collateral must be enabled
        Collateral.Data storage collateral = Collateral.load(asset);
        collateral.verifyIsEnabled();

        // loads the market data storage pointer
        Market.Data storage market = Market.loadExisting(marketId);

        // reverts if the market hasn't received any fees for the given asset
        (bool exists, uint256 receivedFees) = market.receivedFees.tryGet(asset);
        if (!exists) revert Errors.MarketDoesNotContainTheAsset(asset);
        if (receivedFees == 0) revert Errors.AssetAmountIsZero(asset);

        // working data, converted receivedFees uint256 -> UD60x18
        ConvertAccumulatedFeesToWethContext memory ctx;
        ctx.assetAmountX18 = ud60x18(receivedFees);

        // convert the asset amount to token amount
        ctx.assetAmount = collateral.convertUd60x18ToTokenAmount(ctx.assetAmountX18);

        // load weth address
        ctx.weth = MarketMakingEngineConfiguration.load().weth;

        // if asset is weth directly add to accumulated weth, else swap token for weth
        if (asset == ctx.weth) {
            // store the amount of weth
            ctx.receivedWethX18 = ctx.assetAmountX18;
        } else {
            // load the weth collateral data storage pointer
            Collateral.Data storage wethCollateral = Collateral.load(ctx.weth);

            // load custom swap path for asset if enabled
            AssetSwapPath.Data storage swapPath = AssetSwapPath.load(asset);

            // verify if the swap should be input multi-dex/custom swap path, single or multihop
            if (swapPath.enabled) {
                ctx.tokensSwapped = _performMultiDexSwap(swapPath, ctx.assetAmount);
            } else if (path.length == 0) {
                // loads the dex swap strategy data storage pointer
                DexSwapStrategy.Data storage dexSwapStrategy = DexSwapStrategy.loadExisting(dexSwapStrategyId);

                // approve the collateral token to the dex adapter
                IERC20(asset).approve(dexSwapStrategy.dexAdapter, ctx.assetAmount);

                // prepare the data for executing the swap
                SwapExactInputSinglePayload memory swapCallData = SwapExactInputSinglePayload({
                    tokenIn: asset,
                    tokenOut: ctx.weth,
                    amountIn: ctx.assetAmount,
                    recipient: address(this)
                });
                // Swap collected collateral fee amount for WETH and store the obtained amount
                ctx.tokensSwapped = dexSwapStrategy.executeSwapExactInputSingle(swapCallData);
            } else {
                // loads the dex swap strategy data storage pointer
                DexSwapStrategy.Data storage dexSwapStrategy = DexSwapStrategy.loadExisting(dexSwapStrategyId);

                // approve the collateral token to the dex adapter
                IERC20(asset).approve(dexSwapStrategy.dexAdapter, ctx.assetAmount);

                // prepare the data for executing the swap
                SwapExactInputPayload memory swapCallData = SwapExactInputPayload({
                    path: path,
                    tokenIn: asset,
                    tokenOut: ctx.weth,
                    amountIn: ctx.assetAmount,
                    recipient: address(this)
                });

                // Swap collected collateral fee amount for WETH and store the obtained amount
                ctx.tokensSwapped = dexSwapStrategy.executeSwapExactInput(swapCallData);
            }

            // uint256 -> ud60x18
            ctx.receivedWethX18 = wethCollateral.convertTokenAmountToUd60x18(ctx.tokensSwapped);
        }
        // handles distribution of the weth reward between the protocol and market
        _handleWethRewardDistribution(market, asset, ctx.receivedWethX18);

        // emit event to log the conversion of fees to weth
        emit LogConvertAccumulatedFeesToWeth(ctx.receivedWethX18.intoUint256());
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using DexSwapStrategy for DexSwapStrategy.Data;
using Distribution for Distribution.Data;
using EnumerableSet for EnumerableSet.AddressSet;
using EnumerableSet for EnumerableSet.UintSet;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using Market for Market.Data;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;
using SafeERC20 for IERC20;
using Vault for Vault.Data;

// Function Implementation:
function sendWethToFeeRecipients(uint128 marketId) external onlyRegisteredEngine(marketId) {
        // loads the fee data storage pointer
        Market.Data storage market = Market.loadExisting(marketId);

        // reverts if no protocol weth rewards have been collected
        if (market.availableProtocolWethReward == 0) revert Errors.NoWethFeesCollected();

        // loads the market making engine configuration data storage pointer
        MarketMakingEngineConfiguration.Data storage marketMakingEngineConfiguration =
            MarketMakingEngineConfiguration.load();

        // cache the weth address
        address weth = marketMakingEngineConfiguration.weth;

        // load weth collateral configuration
        Collateral.Data storage wethCollateralData = Collateral.load(weth);

        // convert collected fees to UD60x18 and convert decimals if needed, to ensure it's using the network's weth
        // decimals value
        uint256 availableProtocolWethReward =
            wethCollateralData.convertUd60x18ToTokenAmount(ud60x18(market.availableProtocolWethReward));

        // get total shares
        UD60x18 totalShares = ud60x18(marketMakingEngineConfiguration.totalFeeRecipientsShares);

        // this condition can never be hit since if shares is zero, availableProtocolWethReward
        // will also be zero, since in convertAccumulatedFeesToWeth at the end if there are no
        // fee recipient shares all weth rewards would go to the vaults
        if (totalShares.isZero()) {
            // if total shares is zero, revert
            revert Errors.NoSharesAvailable();
        }

        // set to zero the amount of pending weth to be distributed
        market.availableProtocolWethReward = 0;

        // sends the accumulated protocol weth reward to the configured fee recipients
        marketMakingEngineConfiguration.distributeProtocolAssetReward(weth, availableProtocolWethReward);

        // emit event to log the weth sent to fee recipients
        emit LogSendWethToFeeRecipients(marketId, availableProtocolWethReward);
    }

// Contract State Variables:
using SafeERC20 for IERC20;
using Collateral for Collateral.Data;
using Distribution for Distribution.Data;
using Vault for Vault.Data;
using SafeCast for uint256;
using MathOpenZeppelin for uint256;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;

// Function Implementation:
function stake(uint128 vaultId, uint128 shares) external {
        // to prevent safe cast overflow errors
        if (shares < Constants.MIN_OF_SHARES_TO_STAKE) {
            revert Errors.QuantityOfSharesLessThanTheMinimumAllowed(Constants.MIN_OF_SHARES_TO_STAKE, uint256(shares));
        }

        // fetch storage slot for vault by id
        Vault.Data storage vault = Vault.loadLive(vaultId);

        // prepare the `Vault::recalculateVaultsCreditCapacity` call
        uint256[] memory vaultsIds = new uint256[](1);
        vaultsIds[0] = uint256(vaultId);

        // updates the vault's credit capacity and perform all vault state
        // transitions before updating `msg.sender` staked shares
        Vault.recalculateVaultsCreditCapacity(vaultsIds);

        // load distribution data
        Distribution.Data storage wethRewardDistribution = vault.wethRewardDistribution;

        // cast actor address to bytes32
        bytes32 actorId = bytes32(uint256(uint160(msg.sender)));

        // accumulate the actor's pending reward before staking
        wethRewardDistribution.accumulateActor(actorId);

        // load actor distribution data
        Distribution.Actor storage actor = wethRewardDistribution.actor[actorId];

        // calculate actor updated shares amount
        UD60x18 updatedActorShares = ud60x18(actor.shares).add(ud60x18(shares));

        // update actor staked shares
        wethRewardDistribution.setActorShares(actorId, updatedActorShares);

        // transfer shares from actor
        IERC20(vault.indexToken).safeTransferFrom(msg.sender, address(this), shares);

        // emit an event
        emit LogStake(vaultId, msg.sender, shares);
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using DexSwapStrategy for DexSwapStrategy.Data;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using Market for Market.Data;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;
using SafeCast for uint256;
using SafeCast for uint128;
using SafeCast for int256;
using SafeERC20 for IERC20;
using Vault for Vault.Data;

// Function Implementation:
function settleVaultsDebt(uint256[] calldata vaultsIds) external onlyRegisteredSystemKeepers {
        // first, we need to update the credit capacity of the vaults
        Vault.recalculateVaultsCreditCapacity(vaultsIds);

        // working data, cache usdc address
        SettleVaultDebtContext memory ctx;
        ctx.usdc = MarketMakingEngineConfiguration.load().usdc;

        // load the usdc collateral data storage pointer
        Collateral.Data storage usdcCollateralConfig = Collateral.load(ctx.usdc);

        for (uint256 i; i < vaultsIds.length; i++) {
            // load the vault storage pointer
            Vault.Data storage vault = Vault.loadExisting(vaultsIds[i].toUint128());

            // cache the vault's unsettled debt, if zero skip to next vault
            // amount in zaros internal precision
            ctx.vaultUnsettledRealizedDebtUsdX18 = vault.getUnsettledRealizedDebt();
            if (ctx.vaultUnsettledRealizedDebtUsdX18.isZero()) continue;

            // otherwise vault has debt to be settled, cache the vault's collateral asset
            ctx.vaultAsset = vault.collateral.asset;

            // loads the dex swap strategy data storage pointer
            DexSwapStrategy.Data storage dexSwapStrategy =
                DexSwapStrategy.loadExisting(vault.swapStrategy.assetDexSwapStrategyId);

            // if the vault is in debt, swap its assets to USDC
            if (ctx.vaultUnsettledRealizedDebtUsdX18.lt(SD59x18_ZERO)) {
                // get swap amount; both input and output in native precision
                ctx.swapAmount = calculateSwapAmount(
                    dexSwapStrategy.dexAdapter,
                    ctx.usdc,
                    ctx.vaultAsset,
                    usdcCollateralConfig.convertSd59x18ToTokenAmount(ctx.vaultUnsettledRealizedDebtUsdX18.abs())
                );

                // swap the vault's assets to usdc in order to cover the usd denominated debt partially or fully
                // both input and output in native precision
                ctx.usdcOut = _convertAssetsToUsdc(
                    vault.swapStrategy.usdcDexSwapStrategyId,
                    ctx.vaultAsset,
                    ctx.swapAmount,
                    vault.swapStrategy.usdcDexSwapPath,
                    address(this),
                    ctx.usdc
                );

                // sanity check to ensure we didn't somehow give away the input tokens
                if (ctx.usdcOut == 0) revert Errors.ZeroOutputTokens();

                // uint256 -> udc60x18 scaling native precision to zaros internal precision
                ctx.usdcOutX18 = usdcCollateralConfig.convertTokenAmountToUd60x18(ctx.usdcOut);

                // use the amount of usdc bought with assets to update the vault's state
                // note: storage updates must be done using zaros internal precision
                //
                // deduct the amount of usdc swapped for assets from the vault's unsettled debt
                vault.marketsRealizedDebtUsd -= ctx.usdcOutX18.intoUint256().toInt256().toInt128();

                // allocate the usdc acquired to back the engine's usd token
                UsdTokenSwapConfig.load().usdcAvailableForEngine[vault.engine] += ctx.usdcOutX18.intoUint256();

                // update the variables to be logged
                ctx.assetIn = ctx.vaultAsset;
                ctx.assetInAmount = ctx.swapAmount;
                ctx.assetOut = ctx.usdc;
                ctx.assetOutAmount = ctx.usdcOut;
                // since we're handling debt, we provide a positive value
                ctx.settledDebt = ctx.usdcOut.toInt256();
            } else {
                // else vault is in credit, swap its USDC previously accumulated
                // from market and vault deposits into its underlying asset

                // get swap amount; both input and output in native precision
                ctx.usdcIn = calculateSwapAmount(
                    dexSwapStrategy.dexAdapter,
                    ctx.vaultAsset,
                    ctx.usdc,
                    usdcCollateralConfig.convertSd59x18ToTokenAmount(ctx.vaultUnsettledRealizedDebtUsdX18.abs())
                );

                // get deposited USDC balance of the vault, convert to native precision
                ctx.vaultUsdcBalance = usdcCollateralConfig.convertUd60x18ToTokenAmount(ud60x18(vault.depositedUsdc));

                // if the vault doesn't have enough usdc use whatever amount it has
                // make sure we compare native precision values together and output native precision
                ctx.usdcIn = (ctx.usdcIn <= ctx.vaultUsdcBalance) ? ctx.usdcIn : ctx.vaultUsdcBalance;

                // swaps the vault's usdc balance to more vault assets and
                // send them to the ZLP Vault contract (index token address)
                // both input and output in native precision
                ctx.assetOutAmount = _convertUsdcToAssets(
                    vault.swapStrategy.assetDexSwapStrategyId,
                    ctx.vaultAsset,
                    ctx.usdcIn,
                    vault.swapStrategy.assetDexSwapPath,
                    vault.indexToken,
                    ctx.usdc
                );

                // sanity check to ensure we didn't somehow give away the input tokens
                if (ctx.assetOutAmount == 0) revert Errors.ZeroOutputTokens();

                // subtract the usdc amount used to buy vault assets from the vault's deposited usdc, thus, settling
                // the due credit amount (partially or fully).
                // note: storage updates must be done using zaros internal precision
                vault.depositedUsdc -= usdcCollateralConfig.convertTokenAmountToUd60x18(ctx.usdcIn).intoUint128();

                // update the variables to be logged
                ctx.assetIn = ctx.usdc;
                ctx.assetInAmount = ctx.usdcIn;
                ctx.assetOut = ctx.vaultAsset;
                // since we're handling credit, we provide a negative value
                ctx.settledDebt = -ctx.usdcIn.toInt256();
            }

            // emit an event per vault settled
            emit LogSettleVaultDebt(
                vaultsIds[i].toUint128(),
                ctx.assetIn,
                ctx.assetInAmount,
                ctx.assetOut,
                ctx.assetOutAmount,
                ctx.settledDebt
            );
        }
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using Distribution for Distribution.Data;
using LiveMarkets for LiveMarkets.Data;
using EnumerableSet for EnumerableSet.AddressSet;
using EnumerableSet for EnumerableSet.UintSet;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using SafeCast for int256;
using SafeCast for uint256;
uint128 id;
uint128 autoDeleverageStartThreshold;
uint128 autoDeleverageEndThreshold;
uint128 autoDeleverageExponentZ;
int128 netUsdTokenIssuance;
uint128 creditDepositsValueCacheUsd;
uint128 lastCreditDepositsValueRehydration;
int128 realizedDebtUsdPerVaultShare;
int128 unrealizedDebtUsdPerVaultShare;
uint128 usdcCreditPerVaultShare;
uint128 wethRewardPerVaultShare;
uint128 availableProtocolWethReward;
uint128 totalDelegatedCreditUsd;
address engine;

// Function Implementation:
function settleCreditDeposit(Data storage self, address settledAsset, UD60x18 netUsdcReceivedX18) internal {
        // removes the credit deposit asset that has just been settled for usdc
        self.creditDeposits.remove(settledAsset);

        // calculate the usdc that has been accumulated per usd of credit delegated to the market
        UD60x18 addedUsdcPerCreditShareX18 = netUsdcReceivedX18.div(ud60x18(self.totalDelegatedCreditUsd));

        // add the usdc acquired to the accumulated usdc credit variable
        self.usdcCreditPerVaultShare =
            ud60x18(self.usdcCreditPerVaultShare).add(addedUsdcPerCreditShareX18).intoUint128();

        // deduct the amount of usdc credit from the realized debt per vault share, so we don't double count it
        self.realizedDebtUsdPerVaultShare = sd59x18(self.realizedDebtUsdPerVaultShare).sub(
            addedUsdcPerCreditShareX18.intoSD59x18()
        ).intoInt256().toInt128();
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using DexSwapStrategy for DexSwapStrategy.Data;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using Market for Market.Data;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;
using SafeCast for uint256;
using SafeCast for uint128;
using SafeCast for int256;
using SafeERC20 for IERC20;
using Vault for Vault.Data;

// Function Implementation:
function depositCreditForMarket(
        uint128 marketId,
        address collateralAddr,
        uint256 amount
    )
        external
        onlyRegisteredEngine(marketId)
    {
        if (amount == 0) revert Errors.ZeroInput("amount");

        // loads the collateral's data storage pointer, must be enabled
        Collateral.Data storage collateral = Collateral.load(collateralAddr);
        collateral.verifyIsEnabled();

        // loads the market's data storage pointer, must have delegated credit so
        // engine is not depositing credit to an empty distribution (with 0 total shares)
        // although this should never happen if the system functions properly.
        Market.Data storage market = Market.loadLive(marketId);
        if (market.getTotalDelegatedCreditUsd().isZero()) {
            revert Errors.NoDelegatedCredit(marketId);
        }

        // uint256 -> UD60x18 scaling decimals to zaros internal precision
        UD60x18 amountX18 = collateral.convertTokenAmountToUd60x18(amount);

        // caches the usdToken address
        address usdToken = MarketMakingEngineConfiguration.load().usdTokenOfEngine[msg.sender];

        // caches the usdc
        address usdc = MarketMakingEngineConfiguration.load().usdc;

        // note: storage updates must occur using zaros internal precision
        if (collateralAddr == usdToken) {
            // if the deposited collateral is USD Token, it reduces the market's realized debt
            market.updateNetUsdTokenIssuance(unary(amountX18.intoSD59x18()));
        } else {
            if (collateralAddr == usdc) {
                market.settleCreditDeposit(address(0), amountX18);
            } else {
                // deposits the received collateral to the market to be distributed to vaults
                // to be settled in the future
                market.depositCredit(collateralAddr, amountX18);
            }
        }

        // transfers the margin collateral asset from the registered engine to the market making engine
        // NOTE: The engine must approve the market making engine to transfer the margin collateral asset, see
        // PerpsEngineConfigurationBranch::setMarketMakingEngineAllowance
        // note: transfers must occur using token native precision
        IERC20(collateralAddr).safeTransferFrom(msg.sender, address(this), amount);

        // emit an event
        emit LogDepositCreditForMarket(msg.sender, marketId, collateralAddr, amount);
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using DexSwapStrategy for DexSwapStrategy.Data;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using Market for Market.Data;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;
using SafeCast for uint256;
using SafeCast for uint128;
using SafeCast for int256;
using SafeERC20 for IERC20;
using Vault for Vault.Data;

// Function Implementation:
function convertMarketsCreditDepositsToUsdc(
        uint128 marketId,
        address[] calldata assets,
        uint128[] calldata dexSwapStrategyIds,
        bytes[] calldata paths
    )
        external
        onlyRegisteredSystemKeepers
    {
        // revert if the arrays have different lengths
        if (assets.length != dexSwapStrategyIds.length || assets.length != paths.length) {
            // we ignore in purpose the error params here
            revert Errors.ArrayLengthMismatch(0, 0);
        }

        // load the market's data storage pointer
        Market.Data storage market = Market.loadExisting(marketId);

        // working area
        ConvertMarketsCreditDepositsToUsdcContext memory ctx;

        for (uint256 i; i < assets.length; i++) {
            // revert if the market hasn't received any fees for the given asset
            (bool exists, uint256 creditDeposits) = market.creditDeposits.tryGet(assets[i]);
            if (!exists) revert Errors.MarketDoesNotContainTheAsset(assets[i]);
            if (creditDeposits == 0) revert Errors.AssetAmountIsZero(assets[i]);

            // cache usdc address
            address usdc = MarketMakingEngineConfiguration.load().usdc;

            // creditDeposits in zaros internal precision so convert to native token decimals
            ctx.creditDepositsNativeDecimals =
                Collateral.load(assets[i]).convertUd60x18ToTokenAmount(ud60x18(creditDeposits));

            // convert the assets to USDC; both input and outputs in native token decimals
            uint256 usdcOut = _convertAssetsToUsdc(
                dexSwapStrategyIds[i], assets[i], ctx.creditDepositsNativeDecimals, paths[i], address(this), usdc
            );

            // sanity check to ensure we didn't somehow give away the input tokens
            if (usdcOut == 0) revert Errors.ZeroOutputTokens();

            // settles the credit deposit for the amount of USDC received
            // updating storage so convert from native token decimals to zaros internal precision
            market.settleCreditDeposit(assets[i], Collateral.load(usdc).convertTokenAmountToUd60x18(usdcOut));

            // emit an event
            emit LogConvertMarketCreditDepositsToUsdc(marketId, assets[i], creditDeposits, usdcOut);
        }
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using DexSwapStrategy for DexSwapStrategy.Data;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using Market for Market.Data;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;
using SafeCast for uint256;
using SafeCast for uint128;
using SafeCast for int256;
using SafeERC20 for IERC20;
using Vault for Vault.Data;

// Function Implementation:
function _convertUsdcToAssets(
        uint128 dexSwapStrategyId,
        address asset,
        uint256 usdcAmount,
        bytes memory path,
        address recipient,
        address usdc
    )
        internal
        returns (uint256 assetOut)
    {
        // revert if the amount is zero
        if (usdcAmount == 0) revert Errors.AssetAmountIsZero(usdc);

        // if the asset being handled is usdc, output it to `usdcOut`
        if (asset == usdc) {
            assetOut = usdcAmount;
        } else {
            // load the market making engine configuration storage pointer
            MarketMakingEngineConfiguration.Data storage marketMakingEngineConfiguration =
                MarketMakingEngineConfiguration.load();

            // cache the settlement base fee value using usdc's native decimals
            uint256 settlementBaseFeeUsd = Collateral.load(usdc).convertUd60x18ToTokenAmount(
                ud60x18(marketMakingEngineConfiguration.settlementBaseFeeUsdX18)
            );

            if (settlementBaseFeeUsd > 0) {
                // revert if there isn't enough usdc to convert the base fee
                // NOTE: keepers must be configured to buy good chunks of usdc at minimum (e.g $500)
                // as the settlement base fee shouldn't be much greater than $1.
                if (usdcAmount < settlementBaseFeeUsd) {
                    revert Errors.FailedToPaySettlementBaseFee();
                }

                // subtract fee from usdc input
                usdcAmount -= settlementBaseFeeUsd;

                // distribute the base fee to protocol fee recipients
                marketMakingEngineConfiguration.distributeProtocolAssetReward(usdc, settlementBaseFeeUsd);
            }

            // loads the dex swap strategy data storage pointer
            DexSwapStrategy.Data storage dexSwapStrategy = DexSwapStrategy.loadExisting(dexSwapStrategyId);

            // approve the asset to be spent by the dex adapter contract
            IERC20(usdc).approve(dexSwapStrategy.dexAdapter, usdcAmount);

            // verify if the swap should be input single or multihop
            if (path.length == 0) {
                // prepare the data for executing the swap
                SwapExactInputSinglePayload memory swapCallData = SwapExactInputSinglePayload({
                    tokenIn: usdc,
                    tokenOut: asset,
                    amountIn: usdcAmount,
                    recipient: recipient
                });

                // swap the credit deposit assets for USDC and store the output amount
                assetOut = dexSwapStrategy.executeSwapExactInputSingle(swapCallData);
            } else {
                // prepare the data for executing the swap
                SwapExactInputPayload memory swapCallData = SwapExactInputPayload({
                    path: path,
                    tokenIn: usdc,
                    tokenOut: asset,
                    amountIn: usdcAmount,
                    recipient: recipient
                });

                // swap the credit deposit assets for USDC and store the output amount
                assetOut = dexSwapStrategy.executeSwapExactInput(swapCallData);
            }
        }
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using Distribution for Distribution.Data;
using LiveMarkets for LiveMarkets.Data;
using EnumerableSet for EnumerableSet.AddressSet;
using EnumerableSet for EnumerableSet.UintSet;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using SafeCast for int256;
using SafeCast for uint256;
uint128 id;
uint128 autoDeleverageStartThreshold;
uint128 autoDeleverageEndThreshold;
uint128 autoDeleverageExponentZ;
int128 netUsdTokenIssuance;
uint128 creditDepositsValueCacheUsd;
uint128 lastCreditDepositsValueRehydration;
int128 realizedDebtUsdPerVaultShare;
int128 unrealizedDebtUsdPerVaultShare;
uint128 usdcCreditPerVaultShare;
uint128 wethRewardPerVaultShare;
uint128 availableProtocolWethReward;
uint128 totalDelegatedCreditUsd;
address engine;

// Function Implementation:
function rehydrateCreditDepositsValueCache(Data storage self)
        internal
        returns (UD60x18 creditDepositsValueUsdX18)
    {
        creditDepositsValueUsdX18 = getCreditDepositsValueUsd(self);
        self.creditDepositsValueCacheUsd = creditDepositsValueUsdX18.intoUint128();
        self.lastCreditDepositsValueRehydration = block.timestamp.toUint128();
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using DexSwapStrategy for DexSwapStrategy.Data;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using Market for Market.Data;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;
using SafeCast for uint256;
using SafeCast for uint128;
using SafeCast for int256;
using SafeERC20 for IERC20;
using Vault for Vault.Data;

// Function Implementation:
function getAdjustedProfitForMarketId(
        uint128 marketId,
        uint256 profitUsd
    )
        public
        view
        returns (UD60x18 adjustedProfitUsdX18)
    {
        // load the market's data storage pointer & cache total debt
        Market.Data storage market = Market.loadLive(marketId);
        SD59x18 marketTotalDebtUsdX18 = market.getTotalDebt();

        // caches the market's delegated credit & credit capacity
        UD60x18 delegatedCreditUsdX18 = market.getTotalDelegatedCreditUsd();
        SD59x18 creditCapacityUsdX18 = Market.getCreditCapacityUsd(delegatedCreditUsdX18, marketTotalDebtUsdX18);

        // if the credit capacity is less than or equal to zero then
        // the total debt has already taken all the delegated credit
        if (creditCapacityUsdX18.lte(SD59x18_ZERO)) {
            revert Errors.InsufficientCreditCapacity(marketId, creditCapacityUsdX18.intoInt256());
        }

        // uint256 -> UD60x18; output default case when market not in Auto Deleverage state
        adjustedProfitUsdX18 = ud60x18(profitUsd);

        // we don't need to add `profitUsd` as it's assumed to be part of the total debt
        // NOTE: If we don't return the adjusted profit in this if branch, we assume marketTotalDebtUsdX18 is positive
        if (market.isAutoDeleverageTriggered(delegatedCreditUsdX18, marketTotalDebtUsdX18)) {
            // if the market's auto deleverage system is triggered, it assumes marketTotalDebtUsdX18 > 0
            adjustedProfitUsdX18 =
                market.getAutoDeleverageFactor(delegatedCreditUsdX18, marketTotalDebtUsdX18).mul(adjustedProfitUsdX18);
        }
    }

// Contract State Variables:
using SafeERC20 for IERC20;
using Collateral for Collateral.Data;
using Distribution for Distribution.Data;
using Vault for Vault.Data;
using SafeCast for uint256;
using MathOpenZeppelin for uint256;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;

// Function Implementation:
function getVaultCreditCapacity(uint128 vaultId) public view returns (uint256) {
        // fetch storage slot for vault by id
        Vault.Data storage vault = Vault.loadExisting(vaultId);

        // fetch the vault's total assets in 18 dec
        SD59x18 totalAssetsX18 =
            vault.collateral.convertTokenAmountToSd59x18(IERC4626(vault.indexToken).totalAssets().toInt256());

        // we use the vault's net sum of all debt types coming from its connected markets to determine the swap rate
        SD59x18 vaultDebtUsdX18 = vault.getTotalDebt();

        // get collateral asset price
        UD60x18 assetPriceX18 = vault.collateral.getPrice();

        // convert the vault debt value in USD to the equivalent amount of assets to be credited or debited
        SD59x18 vaultDebtInAssetsX18 = vaultDebtUsdX18.div(assetPriceX18.intoSD59x18());

        // get decimal offset
        uint8 decimalOffset = Constants.SYSTEM_DECIMALS - vault.collateral.decimals;

        // subtract the vault's debt from the total assets
        // NOTE: we add 1 to the total assets to avoid division by zero.
        // Add 10 ** decimalsOffset since when converting back from x18 to uint256, it would equal 1
        // NOTE: credit is accounted as negative debt, so it would be added to the total assets
        SD59x18 totalAssetsMinusVaultDebtX18 =
            totalAssetsX18.add(sd59x18(int256(10 ** uint256(decimalOffset)))).sub(vaultDebtInAssetsX18);

        // sd59x18 -> uint256
        uint256 totalAssetsMinusVaultDebt = vault.collateral.convertSd59x18ToTokenAmount(totalAssetsMinusVaultDebtX18);

        return totalAssetsMinusVaultDebt;
    }

// Contract State Variables:
using SafeERC20 for IERC20;
using Collateral for Collateral.Data;
using Distribution for Distribution.Data;
using Vault for Vault.Data;
using SafeCast for uint256;
using MathOpenZeppelin for uint256;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;

// Function Implementation:
function getVaultAssetSwapRate(
        uint128 vaultId,
        uint256 assetsIn,
        bool shouldDiscountDepositFee
    )
        public
        view
        returns (UD60x18 sharesOut)
    {
        // fetch storage slot for vault by id
        Vault.Data storage vault = Vault.loadExisting(vaultId);

        // get the vault's net credit capacity, i.e its total assets usd value minus its total debt (or adding its
        // credit if debt is negative)
        uint256 totalAssetsMinusVaultDebt = getVaultCreditCapacity(vaultId);

        // get decimal offset
        uint8 decimalOffset = Constants.SYSTEM_DECIMALS - IERC20Metadata(vault.indexToken).decimals();

        // Get the shares amount out for the input amount of tokens, taking into account the unsettled debt
        // See {IERC4626-previewDeposit}.
        // `IERC4626(vault.indexToken).totalSupply() + 10 ** decimalOffset` could lead to problems
        uint256 previewSharesOut = assetsIn.mulDiv(
            IERC4626(vault.indexToken).totalSupply() + 10 ** decimalOffset,
            totalAssetsMinusVaultDebt,
            MathOpenZeppelin.Rounding.Floor
        );

        if (shouldDiscountDepositFee) {
            previewSharesOut =
                ud60x18(previewSharesOut).sub(ud60x18(previewSharesOut).mul(ud60x18(vault.depositFee))).intoUint256();
        }

        // Return the final adjusted amountOut as UD60x18
        return ud60x18(previewSharesOut);
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using CreditDelegation for CreditDelegation.Data;
using Distribution for Distribution.Data;
using EnumerableSet for EnumerableSet.UintSet;
using Market for Market.Data;
using SafeCast for uint256;
using SafeCast for int256;
uint128 usdcDexSwapStrategyId;
bytes usdcDexSwapPath;
uint128 assetDexSwapStrategyId;
bytes assetDexSwapPath;
uint256 depositFee;
uint256 redeemFee;
uint128 id;
uint128 totalCreditDelegationWeight;
uint128 depositCap;
uint128 withdrawalDelay;
uint128 lockedCreditRatio;
int128 marketsUnrealizedDebtUsd;
int128 marketsRealizedDebtUsd;
uint128 depositedUsdc;
address indexToken;
address engine;
bool isLive;
SwapStrategy swapStrategy;
mapping(address => uint128) withdrawalRequestIdCounter;
uint256 depositFee;
uint256 redeemFee;
uint128 vaultId;
uint128 depositCap;
uint128 withdrawalDelay;
address indexToken;
address engine;
uint128 vaultId;
uint128 depositCap;
uint128 withdrawalDelay;
bool isLive;
uint128 lockedCreditRatio;

// Function Implementation:
function getLockedCreditCapacityUsd(Data storage self)
        internal
        view
        returns (UD60x18 lockedCreditCapacityUsdX18)
    {
        SD59x18 creditCapacityUsdX18 = getTotalCreditCapacityUsd(self);
        lockedCreditCapacityUsdX18 = creditCapacityUsdX18.lte(SD59x18_ZERO)
            ? UD60x18_ZERO
            : creditCapacityUsdX18.intoUD60x18().mul(ud60x18(self.lockedCreditRatio));
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using DexSwapStrategy for DexSwapStrategy.Data;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using Market for Market.Data;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;
using SafeCast for uint256;
using SafeCast for uint128;
using SafeCast for int256;
using SafeERC20 for IERC20;
using Vault for Vault.Data;

// Function Implementation:
function getCreditCapacityForMarketId(uint128 marketId) public view returns (SD59x18) {
        Market.Data storage market = Market.loadExisting(marketId);

        return Market.getCreditCapacityUsd(market.getTotalDelegatedCreditUsd(), market.getTotalDebt());
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;
using SafeERC20 for IERC20;
using SafeCast for uint256;
using SafeCast for uint120;
using StabilityConfiguration for StabilityConfiguration.Data;
using UsdTokenSwapConfig for UsdTokenSwapConfig.Data;
using Vault for Vault.Data;

// Function Implementation:
function getAmountOfAssetOut(
        uint128 vaultId,
        UD60x18 usdAmountInX18,
        UD60x18 indexPriceX18
    )
        public
        view
        returns (UD60x18 amountOutX18)
    {
        // fetch the vault's storage pointer
        Vault.Data storage vault = Vault.load(vaultId);

        // fetch the vault's total assets in USD; if the vault is empty
        // revert here to prevent panic from subsequent divide by zero
        UD60x18 vaultAssetsUsdX18 = ud60x18(IERC4626(vault.indexToken).totalAssets()).mul(indexPriceX18);
        if (vaultAssetsUsdX18.isZero()) revert Errors.InsufficientVaultBalance(vaultId, 0, 0);

        // we use the vault's net sum of all debt types coming from its connected markets to determine the swap rate
        SD59x18 vaultDebtUsdX18 = vault.getTotalDebt();

        // calculate the premium or discount that may be applied to the vault asset's index price
        // note: if no premium or discount needs to be applied, the premiumDiscountFactorX18 will be
        // 1e18 (UD60x18 one value)
        UD60x18 premiumDiscountFactorX18 =
            UsdTokenSwapConfig.load().getPremiumDiscountFactor(vaultAssetsUsdX18, vaultDebtUsdX18);

        // get amounts out taking into consideration the CL price and the premium/discount
        amountOutX18 = usdAmountInX18.div(indexPriceX18).mul(premiumDiscountFactorX18);
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;
using SafeERC20 for IERC20;
using SafeCast for uint256;
using SafeCast for uint120;
using StabilityConfiguration for StabilityConfiguration.Data;
using UsdTokenSwapConfig for UsdTokenSwapConfig.Data;
using Vault for Vault.Data;

// Function Implementation:
function fulfillSwap(
        address user,
        uint128 requestId,
        bytes calldata priceData,
        address engine
    )
        external
        onlyRegisteredSystemKeepers
    {
        // load request for user by id
        UsdTokenSwapConfig.SwapRequest storage request = UsdTokenSwapConfig.load().swapRequests[user][requestId];

        // revert if already processed
        if (request.processed) {
            revert Errors.RequestAlreadyProcessed(user, requestId);
        }

        // working data
        FulfillSwapContext memory ctx;

        // if request dealine expired revert
        ctx.deadline = request.deadline;
        if (ctx.deadline < block.timestamp) {
            revert Errors.SwapRequestExpired(user, requestId, ctx.deadline);
        }

        // set request processed to true
        request.processed = true;

        // load market making engine config
        MarketMakingEngineConfiguration.Data storage marketMakingEngineConfiguration =
            MarketMakingEngineConfiguration.load();

        // load vault data
        ctx.vaultId = request.vaultId;
        Vault.Data storage vault = Vault.loadLive(ctx.vaultId);

        // get usd token of engine
        ctx.usdToken = UsdToken(marketMakingEngineConfiguration.usdTokenOfEngine[engine]);

        // load Stability configuration data
        StabilityConfiguration.Data storage stabilityConfiguration = StabilityConfiguration.load();

        // get price from report in 18 dec
        ctx.priceX18 = stabilityConfiguration.verifyOffchainPrice(priceData);

        // get amount out asset
        ctx.amountIn = request.amountIn;
        ctx.amountOutBeforeFeesX18 = getAmountOfAssetOut(ctx.vaultId, ud60x18(ctx.amountIn), ctx.priceX18);

        // gets the base fee and swap fee for the given amount out before fees
        (ctx.baseFeeX18, ctx.swapFeeX18) = getFeesForAssetsAmountOut(ctx.amountOutBeforeFeesX18, ctx.priceX18);

        // cache the collateral asset address
        ctx.asset = vault.collateral.asset;

        // load the collateral configuration storage pointer
        Collateral.Data storage collateral = Collateral.load(ctx.asset);

        // subtract the fees and convert the UD60x18 value to the collateral's decimals value
        ctx.amountOut =
            collateral.convertUd60x18ToTokenAmount(ctx.amountOutBeforeFeesX18.sub(ctx.baseFeeX18.add(ctx.swapFeeX18)));

        // slippage check
        ctx.minAmountOut = request.minAmountOut;
        if (ctx.amountOut < ctx.minAmountOut) {
            revert Errors.SlippageCheckFailed(ctx.minAmountOut, ctx.amountOut);
        }

        // calculates the protocol's share of the swap fee by multiplying the total swap fee by the protocol's fee
        // recipients' share.
        ctx.protocolSwapFeeX18 = ctx.swapFeeX18.mul(ud60x18(marketMakingEngineConfiguration.totalFeeRecipientsShares));
        // the protocol reward amount is the sum of the base fee and the protocol's share of the swap fee
        ctx.protocolReward = collateral.convertUd60x18ToTokenAmount(ctx.baseFeeX18.add(ctx.protocolSwapFeeX18));

        // update vault debt
        vault.marketsRealizedDebtUsd -= int128(ctx.amountIn);

        // burn usd amount from address(this)
        ctx.usdToken.burn(ctx.amountIn);

        // transfer the required assets from the vault to the mm engine contract before distributions
        // note: as the swap fee stays in the ZLP Vault, it is technically a net gain to share holders, i.e it is auto
        // accumulated to the contract
        IERC20(ctx.asset).safeTransferFrom(vault.indexToken, address(this), ctx.amountOut + ctx.protocolReward);

        // distribute protocol reward value
        marketMakingEngineConfiguration.distributeProtocolAssetReward(ctx.asset, ctx.protocolReward);

        // transfers the remaining amount out to the user, discounting fees
        // note: the vault's share of the swap fee remains in the index token contract, thus, we don't need transfer
        // it anywhere. The end result is that vaults have an amount of their debt paid off with a discount.
        IERC20(ctx.asset).safeTransfer(user, ctx.amountOut);

        emit LogFulfillSwap(
            user,
            requestId,
            ctx.vaultId,
            ctx.amountIn,
            ctx.minAmountOut,
            request.assetOut,
            ctx.deadline,
            ctx.amountOut,
            ctx.baseFeeX18.intoUint256(),
            ctx.swapFeeX18.intoUint256(),
            ctx.protocolReward
        );
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using Distribution for Distribution.Data;
using LiveMarkets for LiveMarkets.Data;
using EnumerableSet for EnumerableSet.AddressSet;
using EnumerableSet for EnumerableSet.UintSet;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using SafeCast for int256;
using SafeCast for uint256;
uint128 id;
uint128 autoDeleverageStartThreshold;
uint128 autoDeleverageEndThreshold;
uint128 autoDeleverageExponentZ;
int128 netUsdTokenIssuance;
uint128 creditDepositsValueCacheUsd;
uint128 lastCreditDepositsValueRehydration;
int128 realizedDebtUsdPerVaultShare;
int128 unrealizedDebtUsdPerVaultShare;
uint128 usdcCreditPerVaultShare;
uint128 wethRewardPerVaultShare;
uint128 availableProtocolWethReward;
uint128 totalDelegatedCreditUsd;
address engine;

// Function Implementation:
function receiveWethReward(
        Data storage self,
        address asset,
        UD60x18 receivedProtocolWethRewardX18,
        UD60x18 receivedVaultsWethRewardX18
    )
        internal
    {
        // if a market credit deposit asset has been used to acquire the received weth, we need to reset its balance
        if (asset != address(0)) {
            // removes the given asset from the received market fees enumerable map as we assume it's been fully
            // swapped to weth
            self.receivedFees.remove(asset);
        }

        // increment the amount of pending weth reward to be distributed to fee recipients
        self.availableProtocolWethReward =
            ud60x18(self.availableProtocolWethReward).add(receivedProtocolWethRewardX18).intoUint128();

        // increment the all time weth reward storage
        self.wethRewardPerVaultShare =
            ud60x18(self.wethRewardPerVaultShare).add(receivedVaultsWethRewardX18).intoUint128();
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using DexSwapStrategy for DexSwapStrategy.Data;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using Market for Market.Data;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;
using SafeCast for uint256;
using SafeCast for uint128;
using SafeCast for int256;
using SafeERC20 for IERC20;
using Vault for Vault.Data;

// Function Implementation:
function _convertAssetsToUsdc(
        uint128 dexSwapStrategyId,
        address asset,
        uint256 assetAmount,
        bytes memory path,
        address recipient,
        address usdc
    )
        internal
        returns (uint256 usdcOut)
    {
        // revert if the amount is zero
        if (assetAmount == 0) revert Errors.AssetAmountIsZero(asset);

        // if the asset being handled is usdc, simply output it to `usdcOut`
        if (asset == usdc) {
            usdcOut = assetAmount;
        } else {
            // approve the asset to be spent by the dex adapter contract
            DexSwapStrategy.Data storage dexSwapStrategy = DexSwapStrategy.loadExisting(dexSwapStrategyId);
            IERC20(asset).approve(dexSwapStrategy.dexAdapter, assetAmount);

            // verify if the swap should be input single or multihop
            if (path.length == 0) {
                // prepare the data for executing the swap
                SwapExactInputSinglePayload memory swapCallData = SwapExactInputSinglePayload({
                    tokenIn: asset,
                    tokenOut: usdc,
                    amountIn: assetAmount,
                    recipient: recipient
                });

                // swap the credit deposit assets for USDC and store the output amount
                usdcOut = dexSwapStrategy.executeSwapExactInputSingle(swapCallData);
            } else {
                // prepare the data for executing the swap
                SwapExactInputPayload memory swapCallData = SwapExactInputPayload({
                    path: path,
                    tokenIn: asset,
                    tokenOut: usdc,
                    amountIn: assetAmount,
                    recipient: recipient
                });

                // swap the credit deposit assets for USDC and store the output amount
                usdcOut = dexSwapStrategy.executeSwapExactInput(swapCallData);
            }

            // load market making config
            MarketMakingEngineConfiguration.Data storage marketMakingEngineConfiguration =
                MarketMakingEngineConfiguration.load();

            // cache the settlement base fee value using usdc's native decimals
            uint256 settlementBaseFeeUsd = Collateral.load(usdc).convertUd60x18ToTokenAmount(
                ud60x18(marketMakingEngineConfiguration.settlementBaseFeeUsdX18)
            );

            if (settlementBaseFeeUsd > 0) {
                // revert if there isn't enough usdc to cover the base fee
                // NOTE: keepers must be configured to buy good chunks of usdc at minimum (e.g $500)
                // as the settlement base fee shouldn't be much greater than $1.
                if (usdcOut < settlementBaseFeeUsd) {
                    revert Errors.FailedToPaySettlementBaseFee();
                }

                usdcOut -= settlementBaseFeeUsd;

                // distribute the base fee to protocol fee recipients
                marketMakingEngineConfiguration.distributeProtocolAssetReward(usdc, settlementBaseFeeUsd);
            }
        }
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using CreditDelegation for CreditDelegation.Data;
using Distribution for Distribution.Data;
using EnumerableSet for EnumerableSet.UintSet;
using Market for Market.Data;
using SafeCast for uint256;
using SafeCast for int256;
uint128 usdcDexSwapStrategyId;
bytes usdcDexSwapPath;
uint128 assetDexSwapStrategyId;
bytes assetDexSwapPath;
uint256 depositFee;
uint256 redeemFee;
uint128 id;
uint128 totalCreditDelegationWeight;
uint128 depositCap;
uint128 withdrawalDelay;
uint128 lockedCreditRatio;
int128 marketsUnrealizedDebtUsd;
int128 marketsRealizedDebtUsd;
uint128 depositedUsdc;
address indexToken;
address engine;
bool isLive;
SwapStrategy swapStrategy;
mapping(address => uint128) withdrawalRequestIdCounter;
uint256 depositFee;
uint256 redeemFee;
uint128 vaultId;
uint128 depositCap;
uint128 withdrawalDelay;
address indexToken;
address engine;
uint128 vaultId;
uint128 depositCap;
uint128 withdrawalDelay;
bool isLive;
uint128 lockedCreditRatio;

// Function Implementation:
function loadExisting(uint128 marketId) internal view returns (Data storage market) {
        market = load(marketId);

        if (market.id == 0) {
            revert Errors.MarketDoesNotExist(marketId);
        }
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using CreditDelegation for CreditDelegation.Data;
using Distribution for Distribution.Data;
using EnumerableSet for EnumerableSet.UintSet;
using Market for Market.Data;
using SafeCast for uint256;
using SafeCast for int256;
uint128 usdcDexSwapStrategyId;
bytes usdcDexSwapPath;
uint128 assetDexSwapStrategyId;
bytes assetDexSwapPath;
uint256 depositFee;
uint256 redeemFee;
uint128 id;
uint128 totalCreditDelegationWeight;
uint128 depositCap;
uint128 withdrawalDelay;
uint128 lockedCreditRatio;
int128 marketsUnrealizedDebtUsd;
int128 marketsRealizedDebtUsd;
uint128 depositedUsdc;
address indexToken;
address engine;
bool isLive;
SwapStrategy swapStrategy;
mapping(address => uint128) withdrawalRequestIdCounter;
uint256 depositFee;
uint256 redeemFee;
uint128 vaultId;
uint128 depositCap;
uint128 withdrawalDelay;
address indexToken;
address engine;
uint128 vaultId;
uint128 depositCap;
uint128 withdrawalDelay;
bool isLive;
uint128 lockedCreditRatio;

// Function Implementation:
function create(CreateParams memory params) internal {
        Data storage self = load(params.vaultId);

        if (self.id != 0) {
            revert Errors.VaultAlreadyExists(params.vaultId);
        }

        self.id = params.vaultId;
        self.depositCap = params.depositCap;
        self.withdrawalDelay = params.withdrawalDelay;
        self.indexToken = params.indexToken;
        self.collateral = params.collateral;
        self.depositFee = params.depositFee;
        self.redeemFee = params.redeemFee;
        self.engine = params.engine;
        self.isLive = true;
    }

// Contract State Variables:
using Collateral for Collateral.Data;
using DexSwapStrategy for DexSwapStrategy.Data;
using EnumerableMap for EnumerableMap.AddressToUintMap;
using Market for Market.Data;
using MarketMakingEngineConfiguration for MarketMakingEngineConfiguration.Data;
using SafeCast for uint256;
using SafeCast for uint128;
using SafeCast for int256;
using SafeERC20 for IERC20;
using Vault for Vault.Data;

// Function Implementation:
function calculateSwapAmount(
        address dexAdapter,
        address assetIn,
        address assetOut,
        uint256 vaultUnsettledDebtUsdAbs
    )
        public
        view
        returns (uint256 amount)
    {
        // calculate expected asset amount needed to cover the debt
        amount = IDexAdapter(dexAdapter).getExpectedOutput(assetIn, assetOut, vaultUnsettledDebtUsdAbs);
    }
# Vulnerability Analysis: Vault Credit Capacity Recalculation Bypass

## Vulnerability Details

In the `connectVaultsAndMarkets` function, there's a critical vulnerability in the credit capacity recalculation logic. The function attempts to recalculate credit capacity only for vaults that already have connected markets, but fails to recalculate for newly connected vaults that previously had no markets.

```solidity:VaultManager.sol
// ... existing code ...
for (uint128 i; i < vaultIds.length; i++) {
    // if vault has connected markets
    if (Vault.load(vaultIds[i].toUint128()).connectedMarkets.length > 0) {
        // cache vault id
        vaultIdToRecalculate[0] = vaultIds[i];

        // recalculate the credit capacity of the vault
        Vault.recalculateVaultsCreditCapacity(vaultIdToRecalculate);
    }
}
// ... existing code ...
```

## Exploit Steps

1. Assume there is a vault (Vault A) with ID 1 that currently has no connected markets
2. An attacker can observe when the owner is about to connect new markets to Vault A
3. The attacker can front-run this transaction and deposit a large amount of assets into Vault A
4. When the owner executes `connectVaultsAndMarkets`:
   - The function checks `connectedMarkets.length > 0`
   - Since Vault A had no markets, this check fails
   - No credit capacity recalculation occurs
   - The markets get connected without proper credit capacity adjustment
5. The vault now has an inflated credit capacity because it wasn't recalculated after connecting markets
6. This allows the attacker to borrow more than they should be able to against their deposited collateral

## Impact

This vulnerability allows an attacker to:
- Bypass credit capacity limits
- Over-borrow against their collateral
- Create an imbalance in the vault's risk management system

## Fix Recommendation

```solidity:VaultManager.sol
function connectVaultsAndMarkets(uint256[] calldata marketIds, uint256[] calldata vaultIds) external onlyOwner {
    // ... existing code ...
    
    // First connect the markets and vaults
    for (uint256 i; i < marketIds.length; i++) {
        _configureMarketConnectedVaults(marketIds[i].toUint128(), vaultIds);
    }

    for (uint256 i; i < vaultIds.length; i++) {
        _configureVaultConnectedMarkets(vaultIds[i].toUint128(), marketIds);
    }

    // Then recalculate credit capacity for ALL vaults, regardless of previous state
    for (uint128 i; i < vaultIds.length; i++) {
        vaultIdToRecalculate[0] = vaultIds[i];
        Vault.recalculateVaultsCreditCapacity(vaultIdToRecalculate);
    }
}
```

This fix ensures that credit capacity is recalculated for all vaults after connecting markets, preventing any potential manipulation of the vault's credit capacity.

        First analyze this vulnerability step by step, and then determine if it really exists based on the analysis result or need deeper function code.
        Please note the following points:
        1. If the vulnerability is an integer overflow vulnerability, directly conclude that the vulnerability does not exist
        2. If the vulnerability is a reentrancy vulnerability, directly conclude that the vulnerability does not exist
        3. If the vulnerability requires inserting new address transaction operations from external sources during function execution, directly determine it does not exist, because transactions are atomic
        4. When assessing vulnerabilities in functions with permission controls, consider not only the functionality itself but also how easily these permission roles can be obtained, as functions with "permission protection" may still be vulnerable if the permissions are easily accessible
        5. If more information is needed to confirm the vulnerability, please clearly state what content needs to be understood (e.g., specific function implementations, variable usage patterns, permission check logic, etc.)
        6. Any vulnerability or risk that could cause potential losses is valid(event small losses), it doesn't necessarily need to cause major security issues
        Please format your output as follows:
        1. Detailed analysis process
        2. Whether more information is needed (if yes, please specify what content needs to be understood and why)
        3. Preliminary conclusion based on current information
        
